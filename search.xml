<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS中的crash]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%E4%B8%AD%E7%9A%84crash%2F</url>
    <content type="text"><![CDATA[异常的种类Mach异常 、Unix Signal 和 NSException 1) Mach异常是最底层的内核级异常，如EXC_BAD_ACCESS（内存访问异常)，可以参考 Mach的exception_types定义 2) Unix Signal是Unix系统中的一种异步通知机制，Mach异常在host层被ux_exception转换为相应的Unix Signal，并通过threadsignal将信号投递到出错的线程。如SIGABRT(程序中止命令中止信号)、 SIGALRM（程序超时信号)，具体信号枚举在iOS的sys/signal.h文件中。 它们可以利用Unix标准的signal机制来处理。 3) NSException是OC层，由iOS库或者各种第三方库或Runtime验证出错误而抛出的异常。如NSRangeException（数组越界异常），它们可以被try catch捕获（苹果不建议用），如果未被捕获或被@throw抛出，可以通过注册NSSetUncaughtExceptionHandler函数来捕获处理。 4) 当错误发生时候，先在最底层产生Mach异常；Mach异常在host层被转换为相应的Unix Signal; 在OC层如果有对应的NSException（OC异常），就转换成OC异常，OC异常可以在OC层得到处理；如果OC异常一直得不到处理，程序会强行发送SIGABRT信号中断程序。在OC层如果没有对应的NSException，就只能让Unix标准的signal机制来处理了。 5) 在捕获Crash事件时，优选Mach异常。因为Mach异常处理会先于Unix信号处理发生，如果Mach异常的handler让程序exit了，那么Unix信号就永远不会到达这个进程了。而转换Unix信号是为了兼容更为流行的POSIX标准(SUS规范)，这样就不必了解Mach内核也可以通过Unix信号的方式来兼容开发。 6) 在方案实现时，通过捕获Mach异常+Unix信号组合方式来捕获Crash事件。在选择具体方案时，可以选择PLCrashReporter这样优秀的开源项目，也可以选择友盟、Bugly 这类完善的Crash上报和统计的产品(试项目需求而定)。 3、捕获CrashNSException是OC层的异常。 在OC中虽然可以通过try catch捕获NSException，阻止其继续往外抛而导致Crash，但是苹果不建议这么做。不使用try catch，就意味着放弃捕获OC层的异常。最后只能注册NSSetUncaughtExceptionHandler这个函数来捕获，记录异常信息，帮助解决问题。 1) OC层中未被捕获的异常，通过注册NSUncaughtExceptionHandler捕获异常信息 12345678//注册异常处理函数NSSetUncaughtExceptionHandler(&amp;uncaught_exception_handler);//异常处理函数static void uncaught_exception_handler (NSException *exception) &#123; //可以取到 NSException 信息 //... abort();&#125; 2) OC中层不能转换的Mach异常，利用Unix标准的signal机制，注册SIGABRT, SIGBUS, SIGSEGV等信号发生时的处理函数。 12345678//注册处理SIGSEGV信号signal(SIGSEGV,handleSignal); // 注册处理其他信号 ....//信号处理函数static void handleSignal( int sig ) &#123;&#125; 常见Crash常见的Crash####有一些Crash比较常见，下面罗列出5种常见的Crash。 1、数组操作场景1：取数据索引越界。一般发生在UITableView的使用中，因为cellForRowAtIndexPath代理方法是异步执行的，UITableView对象的dataSource一旦在加载数据过程中发生变化，极有可能发生数组越界的异常。在多线程场景下，列表界面的数据有可能经常变化，很可能发生；当列表界面数据不怎么变化的时候，几乎感知不到这种异常的存在。解决办法：从数组中取数据前，校验索引是否正确。 12345678910111213@implementation NSMutableArray (Safe)- (id)safeObjectAtIndex:(NSUInteger)index&#123; if (index &lt; self.count)&#123; return [self objectAtIndex:index]; &#125;else&#123; NSLog(@&quot;警告:数组越界!!!&quot;); &#125; return nil;&#125;@end 场景2：数组添加数据对象时nil解决办法：添加对象到数组前，判断是否是nil 说明：数组的删除等操作处理类似，数组操作前要进行数据校验。 2、多线程下的Crash一般多线程发生的Crash，会收到SIGSEGV信号，表明试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据。 场景1：子线程中更新UI 解决办法：将UI更新操作放在主线程中，可以使用performSelectorOnMainThread 或 GCD 123456789//子线程中，使用宏将更新UI的任务派发到主队列#define dispatch_main_sync_safe(block) \if ([NSThread isMainThread]) &#123; \ block(); \&#125; else &#123; \ dispatch_sync(dispatch_get_main_queue(), block); \&#125; #define dispatch_async_main(block) dispatch_async(dispatch_get_main_queue(), block) 场景2：多线程中创建单例 解决办法：使用dispatch_once，保证代码只执行一次，保证线程安全。 1234567891011121314151617181920212223 //以QSAccountManager单例为例 static QSAccountManager *_shareManager = nil; + (instancetype)shareManager&#123; static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; _shareManager = [[self alloc] init]; &#125;); return _shareManager; &#125; + (instancetype)allocWithZone:(struct _NSZone *)zone&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _shareManager = [super allocWithZone:zone]; &#125;); return _shareManager; &#125;- (nonnull id)copyWithZone:(nullable NSZone *)zone&#123; return _shareManager; &#125; 场景3：多线程下非线程安全类的使用，如NSMutableArray、NSMutableDictionary 解决办法：使用派发队列或锁保证数据读写安全。具体实现详见 iOS实录12：NSMutableArray使用中忽视的问题中第一部分。 场景4：数据缓存到磁盘和读取。 解决办法：使用派发队列或锁保证数据读写安全。如将数据的读取和写异步放入串行同步队列，保证数据同步，线程安全。 3、WatchDog 超时造成的Crash一般异常编码是0x8badf00d ，表示应用是因为发生watchdog超时而被iOS终止的。通常是应用花费太多时间而无法启动、终止或响应用系统事件。 场景1：主线程中执行耗时的操作，导致主线程被卡超过一定的时间。 解决办法：主线程中只负责UI的更新和响应，将耗时的操作采用异步的方式放到后台线程执行。耗时操作包括：网络请求，数据库读写等。 4、performSelector:withObject:afterDelay下的Crash场景1：对象释放比performSelector:afterDelay要早 解决办法：在对应类的dealloc中执行cancelPreviousPerformRequestsWithTarget取消执行。 5、SIGPIPE导致的程序退出当服务器close一个连接时，若client端接着发数据。根据TCP协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。而根据信号的默认处理规则，SIGPIPE信号的默认执行动作是terminate(终止、退出),所以client会退出。 场景：长连接socket或重定向管道进入后台，没有关闭 解决办法1：切换到后台时，关闭长连接和管道，回到前台再重建； 解决办法2：使用signal(SIGPIPE,SIG_IGN)，将SIGPIPE交给了系统处理。这么做将SIGPIPE设为SIG_IGN，使得客户端不执行默认动作，即不退出。 关于僵尸对象主要还是依赖于runtime、Foundation和CoreFoundation框架。如果我们打开了Zombie Objects选项，当一个对象即将deallocated的时候，将会额外多一步，就是额外的这一步将该对象转换为僵尸对象而不是直接deallocated。下面一段代码做参考： 12345678910111213141516171819202122@interface EOCClass : NSObject@end@implementation EOCClass @endvoid PrintClassInfo(id obj) &#123; Class cls = object_getClass(obj); Class superCls = class_getSuperclass(cls); NSLog(@&quot;===%s : %s ===&quot;,class_getName(cls),class_getName(superCls));&#125;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; EOCClass *obj = [[EOCClass alloc] init]; NSLog(@&quot;Before release:&quot;); PrintClassInfo(obj); [obj release]; NSLog(@&quot;After release:&quot;); PrintClassInfo(obj); &#125;&#125; 这段代码用了MRC,以此更方便展示将是对象的产生。最后的运行结果如下： 1234Before release:=== EOCClass : NSObject ===After release:=== _NSZombie_EOCClass : nil === 从上可以看出，当一个对象变成僵尸的时候，它的类也从EOCClass变成了_NSZombie_EOCClass。问题是，这个类是哪里来的？自然而然我们会想到runtime创建了这个僵尸类。以上这个僵尸类是模板NSZombie类的一个副本，它并没有什么别的作用，只是简单的作为一个标记。以下是一段伪代码，大致展现了这个僵尸类是如何创建的，并且该对象是如何变成一个僵尸对象的： 12345678910111213141516171819202122//Obtain the class of the object being deallocated 获得将要释放的对象的类Class cls = object_getClass(self);//Get the class&apos;s name 获得类名const char *clsName = class_getName(cls);//Prepend _NSZombie_ to the class name 提前扩展好需要的类名const char *zombieClsName = &quot;_NSZombie_&quot; + clsName;// See if the specific zombie class exists 检查该类是否存在Class zombieCls = objc_lookUpClass(zombieClsName);//If the specific zombie class doesn&apos;t exist,//then it needs to be created 如果不存在，则创建if (!zombieCls) &#123; //Obtain the template zombie class called _NSZombie_ 获得模板类_NSZombie_ Class baseZombieCls = objc_loopUpClass(&quot;_NSZombie_&quot;); //Duplicate the base zombie class,where the new class&apos;s name is the prepended string from above 以模板为基础重建一个类，类名为以上的zombieClsName字符串 zombieCls = objc_duplicateClass(baseZombieCls,zombieClsName,0);&#125;//Perform normal destruction of the object being deallocated 执行一般的销毁流程objc_destructInstance(self);//Set the class of the object being deallocated to the zombie class 讲对象的类设置为僵尸类objc_setClass(self,zombieCls);//the class of &apos;self&apos; is now _NSZombie_OriginalClass 当NSZombieEnabled 这个选项开启的时候，runtime会将上述代码与之前常规的dealloc代码进行互换，由此来保证对象的类变成僵尸类。关键一点是，这个内存中的对象其实还是活着的，内存并没有被释放，因此该内存也不会被重复使用。因为对象被标记为了僵尸，所以接收到消息的时候能提示我们异常所在。之所以大费周章的给每一个对象的类都重新制定一个相对应的僵尸类是因为这样在反馈问题的时候会显得更加精准一些，如果都简单的报错NSZombie对象无法识别方法，那么debug效果就几乎没有了 NSZombie NSZombie本身并不实现任何方法，也没有父类，所以它是一个基类，就像NSObject一样。因为它不实现任何方法，所以当接收到消息的时候，会完整的走一遍消息转发流程。消息转发中关键的一环是forwarding,它做的其中一件事情就是先检查对象的类名是否含有前缀NSZombie,如果检测到了，那么就直接走报告僵尸对象的流程。再打印完错误信息之后程序就结束运行了。以下这段伪代码可以帮助理解在forwarding里是怎么处理zombie对象的： 12345678910111213141516//Obtain the object&apos;s class 取得对象的类Class cls = object_getClass(self);//Get the class&apos;s name 取得类名const char *clsName = class_getName(cls);//Check if the class is prefixed with _NSZombie_ 检查是否含有前缀_NSZombie_if(string_has_prefix(clsName,&quot;_NSZombie_&quot;)) &#123; //if so, this object is a zombie 如果前缀符合，那么它是一个僵尸对象 //Get the original class name by skipping past the _NSZombie_, i.e. taking the substring from character 10 获取原始的类名 const char *originalClsName = substring_from(clsName,10); //Get the selector name of the message 获取方法名 const char *selectorName = sel_getName(_cmd); //Log a message to indicate which selector is being sent yo which zombie 打印错误信息 Log(&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;, originalClsName,selectorName,self); //Kill the application 结束程序 abort();&#125; 参考 野指针定位–大神作品]]></content>
  </entry>
  <entry>
    <title><![CDATA[组件化平台构建记录]]></title>
    <url>%2F2018%2F07%2F25%2F%E7%BB%84%E4%BB%B6%E5%8C%96%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[先来思考一些问题如何做到各业务单独开发，单独测试？如何加快测试包编译速度如何做到不同业务代码安全如何在客户端实现千人千面，同一个按钮跳转不同的页面？如果App出现bug了，如何不用JSPatch，就能做到简单的热修复功能？比如App上线突然遇到了紧急bug，能否把页面动态降级成H5，ReactNative，Weex？或者是直接换成一个本地的错误界面？ 如何在每个组件间调用和页面跳转时都进行埋点统计？每个跳转的地方都手写代码埋点？利用Runtime AOP ？如何在App任何界面都可以调用同一个界面或者同一个组件？只能在AppDelegate里面注册单例来实现？比如App出现问题了，用户可能在任何界面，如何随时随地的让用户强制登出？或者强制都跳转到同一个本地的error界面？或者跳转到相应的H5，ReactNative，Weex界面？如何让用户在任何界面，随时随地的弹出一个View ？ 以上问题都可以通过一个跳转中心来完成 关于解偶组件化的几种方案 计算机中所有的问题都可以用增加一层来解决。 先说解耦的最高层次是互相不知道。本质上我们是要试图构建信息孤岛，这样就带来两个问题，就是 class-protocol 相互跳转的解耦 相互调用的解耦 之后将带来三个问题： 整app生命周期同步 模块间的微弱通信 公共数据同步 根据单一职责，跳转和通信是两个问题，所以分开来处理 页面间跳转这里要实现一个跳转中心，具体来说做三个事情 跳转h5／RN／原生 是否需要登录的校验，无论哪个页面强制跳转登录页 是否需要控制器对象(可能需要返回使用，比如3Dtouch) 跳转逻辑选择 下边这段代码展示了跳转逻辑的核心，通过拼接字符串制造SEL，然后进行方法寻找，那么某个模块内实现跳转中心的分类，然后在分类中添加方法 跳转中心实现 12345678910111213141516//+ (BOOL)nativeView:(JumpEntity *)jumpEntity &#123;// NSParameterAssert(clickEntity != nil);// BOOL isclicked = NO;// NSString *methodString = [NSString stringWithFormat:@&quot;%@&quot;,@(jumpEntity.jumpNavi)];// SEL selector = MTLSelectorWithCapitalizedKeyPattern(&quot;enter&quot;,methodString,&quot;NativeView:&quot;);// if ([self respondsToSelector:selector]) &#123;// NSMethodSignature *singnature = [self methodSignatureForSelector:selector];// NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:singnature];// invocation.target = self;// invocation.selector = selector;// [invocation setArgument:&amp;clickEntity atIndex:2];// [invocation invoke];// isclicked = YES;// &#125;// return isclicked;//&#125; 模块中的代码实现 12345678@implementation JumpCenter (Test1)+(void)jrJumpTo1NativeView:(ClickEntity*)clickEntity&#123; UIVIewController *vc = [[UIVIewController alloc] init]; [JRJumpCenter clickToView:vc withClick:clickEntity];//JRJumpCenter下沉到pod &#125; 这样一来，上边的问题就都解决了。 模块与模块之间的通信？通知通过实现一个全局的中间层，可以很好的实现解耦，但是无法方便的实现双向通信。那我们能不能借鉴通知的思路，在这个中间层的基础上，实现一个通信通道？ 要解决两个问题 怎么找到这个对象？ 怎么找到这个方法？ 用router的方式 如果大家都用到我就下沉到pod，比如说跳转中心这种 采用协议的方式的问题？ 要使用delegate？ 那么如果多个对象实现了这个delegate怎么办？或者都设置为delegate，前边的岂不是会失效？ 中间层怎么声明这些协议？定义不同的delegate？ 为什么不采用openUrl这种方式？ 传参限制，不能传递对象，如果是一个字典还需要进行转换 编码过程没有编译器参与，可靠性下降 pod基本使用转:cocoapod基本使用 指定源CocoaPods支持私有 Spec 仓库的，我们可以建立自己的源，也可以使用非官方的源，只要是符合规定的都可以指定。 12source &apos;https://github.com/artsy/Specs.git&apos; source &apos;https://github.com/CocoaPods/Specs.git&apos; 抑制警告inhibit_warnings参数能够有效的抑制CocoaPods引入的第三方代码库产生的warning。可以全部指定。 inhibit_all_warnings!也可以针对指定。 pod ‘ReactiveCocoa’, ‘~&gt; 2.4’, :inhibit_warnings =&gt; true 使用git的HEAD指向的分支pod &#39;ISO8601DateFormatter&#39;, :head 使用 master 分支1pod &apos;ARAnalytics/Mixpanel&apos;, :git =&gt; &apos;https://github.com/orta/ARAnalytics.git&apos; 指定branch1pod &apos;Reachability&apos;, :git =&gt; &apos;https://github.com/ashfurrow/Reachability.git&apos;, :branch =&gt; &apos;frameworks&apos; 指定tag1pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :tag =&gt; &apos;0.7.0&apos; 指定commit1pod &apos;ARTiledImageView&apos;, :git =&gt; &apos;https://github.com/dblockARTiledImageView&apos;, :commit =&gt; &apos;1a31b864d1d56b1aaed0816c10bb55cf2e078bb8&apos; 使用子库可以这样1pod &apos;QueryKit/Attribute&apos; 也可以这样指定多个子库 1pod &apos;QueryKit&apos;, :subspecs =&gt; [&apos;Attribute&apos;, &apos;QuerySet&apos;] 使用本地代码通过:path可以指定本地代码，不过需要确保目录包含podspec文件。1234pod &apos;AFNetworking&apos;, :path =&gt; &apos;~/Documents/AFNetworking&apos;``### 指定target的依赖库 target :ZipApp do pod ‘SSZipArchive’end12### 排除taget target ‘Artsy Tests’, :exclusive =&gt; true do pod ‘FBSnapshotTestCase’, ‘1.4’end123###指定xcodeproj默认会使用Podfile文件同级目录下第一个xcodeproj，但也可以指定 xcodeproj ‘MyProject’target :test do This Pods library links with a target in another project. xcodeproj ‘TestProject’end12345678### 指定连接的target如果不显式指定连接的target，Pods会默认连接project的第一个target。如果需要，可以使用link_with指定连接一个或多个target`link_with &apos;MyApp&apos;, &apos;MyOtherApp&apos;`### 指定依赖库的配置文件 pod ‘PonyDebugger’, :configuration =&gt; [‘Release’]12### 指定target的配置文件 xcodeproj ‘TestProject’, ‘Mac App Store’ =&gt; :release, ‘Test’ =&gt; :debug1234567891011使用Dynamic Frameworks代替Static Libraries通过标志use_frameworks!就可知开启这个功能。如果需要使用Swift的库，就必须加上这个标志了。### 加快pod install/update 速度使用CocoaPods来添加第三方类库，无论是执行pod install还是pod updat很多时候都卡在了Analyzing dependencies不动，这是更新本地的pod spec所以文件导致的。通过–no-repo-update标志可以不更新本地pod spec索引。当然首次install不应该添加这个标志，后续修改Podfile的时候可以适当使用，加快pod速度。pod install --no-repo-update pod update --no-repo-update### 输出详细日志 pod update –verbose12345678### 随意吧#### 索引文件存储`.cocoapods/repos`在这个文件夹下可能有两个文件夹，一个是master，另一个是你配置的私有库。 cbpmgt-git-jrmobilerepomaster123456#### 缓存文件目录`Library/Caches/CocoaPods/Pods`#### 工程的Podfile长什么样 Uncomment the next line to define a global platform for your projectplatform :ios, ‘8.0’source ‘https://github.com/CocoaPods/Specs.git‘ //默认的源source ‘http://jcode.cbpmgt.com/git/jrMobileRepo.git‘ //私有的源 workspace ‘cocoaTestEntity.xcworkspace’ //最终生成的workspace就是用的这个名字 project ‘cocoaTest/cocoaTest.xcodeproj’ //下边那个cocoaTest就是取的这个，如果不配置它会在同级目录找，找不到就报错，这样写它就会多一个地方去找.xcodeproj这个文件 target ‘cocoaTest’ do Uncomment the next line if you’re using Swift or would like to use dynamic frameworksuse_frameworks!Pods for cocoaTest pod ‘MJExtension’, ‘~&gt; 3.0.0’ pod ‘FMDB’, ‘~&gt; 2.6.2’ pod ‘FLEX’, ‘~&gt; 2.0’, :configurations =&gt; [‘Debug’] #调试用 pod ‘JDJRMqttSocket’ end 12#### 私有库的spec文件长什么样？ # Be sure to run `pod lib lint JDJRMqttSocket.podspec’ to ensure this is avalid spec before submitting.# Any lines starting with a # are optional, but their use is encouragedTo learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html# Pod::Spec.new do |s| s.name = ‘New’ s.version = ‘0.1.0’ s.summary = ‘基于MQTT的私有协议socket通讯库’ s.description = &lt;&lt;-DESC 一个基于MQTT的私有协议socket通讯库,提供实时数据需求的长连接socket通道，服务于有实时数据需求的业务场景。 DESC s.homepage = ‘http://jr.jd.com‘ s.license = { :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ } s.author = { ‘hbz19870606’ =&gt; ‘hudahai@jd.com’ } s.source = { :git =&gt; ‘http://jcode.cbpmgt.com/git/JDJRMqttSocket.git‘, :tag =&gt; s.version.to_s } //git地址和对应的tag s.ios.deployment_target = ‘8.0’ s.source_files = ‘JDJRMqttSocket/Classes/*/‘ s.frameworks = ‘UIKit’, ‘AnotherFramework’ s.dependency ‘fishhook’, ‘~&gt; 0.2’ # 添加依赖 s.dependency ‘MJExtension’, ‘~&gt; 3.0.0’ # 添加依赖 end12345678910111213141516171819202122232425262728293031323334我们可以通过`pod spec lint New.podspec`来验证一个spec文件是否符合规范。我们可以通过`pod spec create New.podspec`来创建一个spec文件。### 基于cocoapod的组件化平台方案概述- 首先我们需要一个壳工程 - 壳工程中包含启动一个app所需要的功能，比如delegate和一个基本的rootcontroller - 一个跳转中心的跳转逻辑 - 还有一个空的podfile- 我们需要一堆的功能模块，包含基础模块和业务模块， - 包含自己的功能代码 - 一个跳转中心分类，用来注册自己里边的功能的跳转和sel - 一个podspec文件 从分工来看:- 工程代码拆分，跳转中心建设- 自动管理工具建设从发展阶段来看:- 多project开发阶段- 组件化平台阶段#### 正常开发如何进行- 下载壳工程- 根据开发需求需要哪些业务模块，获取他们的git地址以及branchname，进行下载，之所以不依赖pod是因为，pod管理的内容没有.git文件，这样就无法直接进行git的操作- 修改壳工程中的podfile文件，使用本地路径- 执行`pod install`，它会将我开发功能模块所需的依赖根据功能模块里边的podspec文件的描述进行模块的下载- 进行正常开发 Uncomment the next line to define a global platform for your projectplatform :ios, ‘8.0’source ‘https://github.com/CocoaPods/Specs.git‘source ‘http://jcode.cbpmgt.com/git/jrMobileRepo.git‘ workspace ‘cocoaTestEntity.xcworkspace’ project ‘cocoaTest/cocoaTest.xcodeproj’ target ‘cocoaTest’ do Uncomment the next line if you’re using Swift or would like to use dynamic frameworksuse_frameworks!Pods for cocoaTest pod ‘JDJRMqttSocket’, :path =&gt; ‘/Users/jrmacpro/Desktop/JDJRMqttSocket’ // 这是能够进行push代码的写法end ``` 多模块联合开发如何进行对git进行封装，每次进行git push操作，其实后边会自动的对多个库分别进行git的命令操作，git pull同样的道理 如何切换源码和.framework.cocoapod中维护另外一套自己的库，比如说叫做A，当我选择用源码的时候，我直接用A中的同名文件夹去替换目标文件夹中的文件，同时删除Library/Cache/CocoaPod中的缓存。 pod repo update ~/.cocoapods/repos/cbpmgt-git-jrmobilerepo更新私有源的文件 功能模块里边的git代码长什么样子里边应该是有两个project，运行可以打出来一个framework，但是pod进行代码拉取的时候，可以只拉取核心代码，这里不能只持有核心代码，这样你打framework将是一个很麻烦的问题。 多个工程依赖同一个包的版本如果不一致怎么办？低版本升级，如果是不同的feature这样，那要用不同的名字 怎么打回归包全部使用源码 分支与tag的协作怎么打framework在git库中创建一个framework的project，这个就是pod管理的地址，只不过只拉取我所需要的源码，不拉取project文件。 另外我们需要的是一个静态库，而不是动态库 动态库与静态库的选择动态库形式：.dylib和.framework 静态库形式：.a和.framework 所以pod提供的是静态库。 动态库的话会把依赖一起打进去，但是静态库只会编译自己不依赖，所以我们选择静态库。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS平台的调试]]></title>
    <url>%2F2018%2F07%2F24%2FiOS%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[x/16xg mem p objc po objc p *objc]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何进行技术深度学习]]></title>
    <url>%2F2018%2F07%2F18%2F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[flag]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS编译原理]]></title>
    <url>%2F2018%2F07%2F10%2F2015%2FiOS%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于指令集模拟器跑在mac上，所以需要支持mac的处理器架构，而真机上就不需要。 armv7｜armv7s｜arm64都是ARM处理器的指令集 i386｜x86_64 是Mac处理器的指令集 这些指令集在那些设备中有用到呢？ 12345678910111213141516171819202122232425262728293031323334arm64：iPhone6s | iphone6s plus｜iPhone6｜ iPhone6 plus｜iPhone5S | iPad Air｜ iPad mini2(iPad mini with Retina Display)armv7s：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)armv7：iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4``` i386是针对intel通用微处理器32位处理器x86_64是针对x86架构的64位处理器 - 模拟器32位处理器测试需要i386架构，- 模拟器64位处理器测试需要x86_64架构，- 真机32位处理器需要armv7,或者armv7s架构，- 真机64位处理器需要arm64架构。### C/C++编译过程: 1、预处理阶段 ： 从hello.c变成hello.i文件，预处理一般就是将include或者define之类的东西，插入到代码中； 2、编译 ： 从hello.i 变成hello.s文件，过程：检查语法、规范，在确定无误之后，将代码翻译成汇编语言。 3、汇编 ： 从hello.s 变成hello.o文件，过程：将汇编代码转换成二进制文件。 4、连接 ： 根据目标文件以及库文件，完成链接之后，生成可执行文件。 &lt;!--more--&gt; [iOS编译过程](https://blog.csdn.net/aas319/article/details/78606342)### 判断一个framework是动态库还是静态库用file命令 /Users/jrmacpro/Desktop/appNew/framewortT.framework/framewortT: Mach-O 64-bit dynamically linked shared library x86_641这个就是动态 /Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Products/Debug-iphonesimulator/libPods-appNew.a: current ar archive random librar1234567891011121314这个就是静态### xcode编译过程中使用的命令[objc中国-Build 过程](https://objccn.io/issue-6-1/)#### 大概的流程执行一次XCode build的流程当你在XCode中，选择build的时候（快捷键command+B），会执行如下过程- 首先编译依赖的文件或者taget- 编译信息写入辅助文件，创建编译后的文件架构(name.app)- 处理文件打包信息，例如在debug环境下 Entitlements:{ “application-identifier” = “app的bundleid”; “aps-environment” = development;}123- 执行CocoaPod编译前脚本 例如对于使用CocoaPod的工程会执行CheckPods Manifest.lock- 编译各个.m文件，使用CompileC和clang命令。 CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compilerexport LANG=en_US.US-ASCIIexport PATH=”…”clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I 上文提到的文件 -F 所需要的Framework -iquote 所需要的Framework … -c ClassName.c -o ClassName.o12通过这个编译的命令，我们可以看到 clang是实际的编译命令-x objective-c 指定了编译的语言-arch x86_64制定了编译的架构，类似还有arm7等-fobjc-arc 一些列-f开头的，指定了采用arc等信息。这个也就是为什么你可以对单独的一个.m文件采用非ARC编程。-Wno-missing-field-initializers 一系列以-W开头的，指的是编译的警告选项，通过这些你可以定制化编译选项-DDEBUG=1 一些列-D开头的，指的是预编译宏，通过这些宏可以实现条件编译-iPhoneSimulator10.1.sdk 制定了编译采用的iOS SDK版本-I 把编译信息写入指定的辅助文件-F 链接所需要的Framework-c ClassName.c 编译文件-o ClassName.o 编译产物12345678910111213141516171819- 链接需要的Framework，Foundation.framework,AFNetworking.framework,ALiPay.fframework- 编译xib文件- 拷贝xib，图片等资源文件到结果目录- 编译ImageAssets- 处理info.plist- 执行CocoaPod脚本- 拷贝Swift标准库- 创建.app文件和对其签名#### 具体过程![](../../images/2018-07-312.35.14.png)xcode会详细记录编译过程，点击留言那个标志，然后选择一个build，就能看到这个build的所有日志，每一个大的项目下边还会有具体的调用的命令。先编译依赖的project或者pods，最后编译.app CompileC /Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Intermediates.noindex/appNew.build/Debug-iphonesimulator/appNew.build/Objects-normal/x86_64/AppDelegate.o appNew/AppDelegate.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler cd /Users/jrmacpro/Desktop/appNew export LANG=en_US.US-ASCII export PATH=”/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin” /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch x86_64 -fmessage-length=0 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -std=gnu11 -fobjc-arc -fmodules -gmodules -fmodules-cache-path=/Users/jrmacpro/Library/Developer/Xcode/DerivedData/ModuleCache -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/Users/jrmacpro/Library/Developer/Xcode/DerivedData/ModuleCache/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Wno-trigraphs -fpascal-strings -O0 -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=return-type -Wdocumentation -Wunreachable-code -Wno-implicit-atomic-properties -Werror=deprecated-objc-isa-usage -Werror=objc-root-class -Wno-arc-repeated-use-of-weak -Wduplicate-method-match -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wuninitialized -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wno-float-conversion -Wnon-literal-null-conversion -Wobjc-literal-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wundeclared-selector -Wno-deprecated-implementations -DDEBUG=1 -DCOCOAPODS=1 -DOBJC_OLD_DISPATCH_PROTOTYPES=0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk -fasm-blocks -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -mios-simulator-version-min=11.2 -g -Wno-sign-conversion -Winfinite-recursion -Wcomma -Wblock-capture-autoreleasing -Wstrict-prototypes -Wunguarded-availability -fobjc-abi-version=2 -fobjc-legacy-dispatch -index-store-path /Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Index/DataStore -iquote /Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Intermediates.noindex/appNew.build/Debug-iphonesimulator/appNew.build/appNew-generated-files.hmap -I/Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Intermediates.noindex/appNew.build/Debug-iphonesimulator/appNew.build/appNew-own-target-headers.hmap -I/Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Intermediates.noindex/appNew.build/Debug-iphonesimulator/appNew.build/appNew-all-target-headers.hmap -iquote /Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Intermediates.noindex/appNew.build/Debug-iphonesimulator/appNew.build/appNew-project-headers.hmap -I/Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Products/Debug-iphonesimulator/include -I/Users/jrmacpro/Desktop/appNew/Pods/Headers/Public -I/Users/jrmacpro/Desktop/appNew/Pods/Headers/Public/SDWebImage -I/Users/jrmacpro/Desktop/appNew/framewortT.framework/Headers -I/Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Intermediates.noindex/appNew.build/Debug-iphonesimulator/appNew.build/DerivedSources/x86_64 -I/Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Intermediates.noindex/appNew.build/Debug-iphonesimulator/appNew.build/DerivedSources -F/Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Products/Debug-iphonesimulator -F/Users/jrmacpro/Desktop/appNew/appNew -F/Users/jrmacpro/Desktop/appNew -isystem /Users/jrmacpro/Desktop/appNew/Pods/Headers/Public -isystem /Users/jrmacpro/Desktop/appNew/Pods/Headers/Public/SDWebImage -MMD -MT dependencies -MF /Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Intermediates.noindex/appNew.build/Debug-iphonesimulator/appNew.build/Objects-normal/x86_64/AppDelegate.d –serialize-diagnostics /Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Intermediates.noindex/appNew.build/Debug-iphonesimulator/appNew.build/Objects-normal/x86_64/AppDelegate.dia -c /Users/jrmacpro/Desktop/appNew/appNew/AppDelegate.m -o /Users/jrmacpro/Library/Developer/Xcode/DerivedData/appNew-ejnvdfggkggjygdnwozcflupzmkj/Build/Intermediates.noindex/appNew.build/Debug-iphonesimulator/appNew.build/Objects-normal/x86_64/AppDelegate.o123456789上边这一大堆，简化一下就做了三件事情- CompileC- cd 切换了一次工作目录- export设置了环境变量- 然后调用clang将.m编译成了.o##### CompileC的解释 CompileC is a logged representation of an internal function for xcodebuild. It is a source of basic information about the compilation in the build.log file. For a simple terminal app with a main.m class, information after CompileC indicates: the object file (main.o, temporarily stored in a hashed directory during the xcodebuild process)the method file (main.m)compilation mode (normal - I don’t know the other options - anyone?)architecture (X86_64)language (objective-c)the compiler (com.apple.compilers.llvm.clang.1_0.compiler)You cannot access CompileC from the command line directly, but you can have lots of control over the Xcode build process from the command line if you wish12345678910##### 各种文件格式的解释- 一个.m 对应一个.o- 多个.o生成一个.a- 多个.a生成一个framework#### 现在开始编译主target PhaseScriptExecution …DataModelVersionCompile …Ld …GenerateDSYMFile …CopyStringsFile …CpResource …CopyPNGFile …CompileAssetCatalog …ProcessInfoPlistFile …ProcessProductPackaging /…/some-hash.mobileprovision …ProcessProductPackaging objcio/objcio.entitlements …CodeSign …12345在上面的任务列表中，根据名称不能区分的唯一任务可能就是 Ld，Ld 是一个 linker 工具的名称，与 libtool 非常相似。实际上，libtool也是简单的调用 ld 和 lipo。&apos;ld&apos;被用来构建可执行文件，而libtool则用来构建 library 文件。阅读Daniel 和 Chris两篇文章，可以了解到更多关于编译和链接的工作原理。### 具体到某一个具体的文件的编译过程 clang -ccc-print-phases -framework Foundation Demo.m -o Demo0: input, “Foundation”, object1: input, “Demo.m”, objective-c2: preprocessor, {1}, objective-c-cpp-output//预处理3: compiler, {2}, ir //编译生成IR(中间代码)4: backend, {3}, assembler//汇编器生成汇编代码5: assembler, {4}, object//生成机器码6: linker, {0, 5}, image//链接7: bind-arch, “x86_64”, {6}, image//生成Image，也就是最后的可执行文件 ``` 又可以分为前端编译和后端编译。 前端编译oc使用clang，swift使用swift() 编译器前端的任务是进行：语法分析，语义分析，生成中间代码(intermediate representation )。在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。 编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSDictionary实现(转)]]></title>
    <url>%2F2018%2F07%2F10%2F2015%2FNSDictionary%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[原文链接 NSDictionary 内部结构、实现原理 不知道大家有没有思考过NSDictionary和NSArray内部是怎么实现的，那么今天就深挖一下NSDictionary&amp; NSArray的 内部结构。 首先咱们了解一下这几个概念：哈希表、时间复杂度、链表看了上面的文章，估计大家都懵逼了。。。好吧，正文来了 NSDictionaryNSDictionary（字典）是使用 哈希表来实现key和value之间的映射和存储的， hash函数设计的好坏影响着数据的查找访问效率。数据在hash表中分布的越均匀，其访问效率越高。而在Objective-C中，通常都是利用NSString 来作为键值，其内部使用的hash函数也是通过使用 NSString对象作为键值来保证数据的各个节点在hash表中均匀分布。 - (void)setObject:(id)anObject forKey:(id &lt;NSCopying&gt;)aKey;NSDictionary中的key是唯一的，key可以是遵循NSCopying 协议和重载- (NSUInteger)hash;、- (BOOL)isEqual:(id)object;方法的任何对象。也就是说在NSDictionary内部，会对 aKey 对象 copy 一份新的。而 anObject 对象在其内部是作为强引用（retain或strong)。 hash 方法是用来计算该对象的 hash 值，最终的 hash 值决定了该对象在 hash 表中存储的位置。所以同样，如果想重写该方法，我们尽量设计一个能让数据分布均匀的 hash 函数。�isEqual : 方法是为了通过 hash 值来找到 对象 在hash �表中的位置。在调用setObject: forKey: 后，内部会去调用 � key 对象的 hash 方法确定 object 在hash表内的入口位置，然后会调用 isEqual : 来确定该值是否已经存在于 NSDictionary中。注：关于hash，isEqual :可以看看这篇文章 iOS开发 之 不要告诉我你真的懂isEqual与hash! 其实，NSDictionary使用NSMapTable实现。NSMapTable同样是一个key－value的容器，下面是NSMapTable的部分代码： 1234567@interface NSMapTable : NSObject &#123; NSMapTableKeyCallBacks *keyCallBacks; NSMapTableValueCallBacks *valueCallBacks; NSUInteger count; NSUInteger nBuckets; struct _NSMapNode **buckets;&#125; 可以看出来NSMapTable是一个哈希＋链表的数据结构，因此在NSMapTable中插入或者删除一对对象时 寻找的时间是O（1）＋O（m），m最坏时可能为n。 O（1）：为对key进行hash得到bucket的位置 O（m）：遍历该bucket后面冲突的value，通过链表连接起来。NSDictionary中的key Value遍历时是无序的，至如按照什么样的顺序，跟hash函数相关。NSMapTable使用NSObject的哈希函数。 -(NSUInteger)hash { return (NSUInteger)self&gt;&gt;4;}上述是NSObject的哈希值的计算方式，简单通过移位实现。右移4位，左边补0.因为对象大多存于堆中，地址相差4位应该很正常。 补充一个小知识：iOS setValue和setObject的区别： 12- (void)setObject:(ObjectType)anObject forKey:(KeyType &lt;NSCopying&gt;)aKey;- (void)setValue:(nullable ObjectType)value forKey:(NSString *)key; 首先：setObject: ForKey:是NSMutableDictionary特有的；setValue: ForKey:是KVC的主要方法。 区别：&gt;(1) setValue: ForKey:的value是可以为nil的（但是当value为nil的时候，会自动调用removeObject：forKey方法）；setObject: ForKey:的value则不可以为nil。(2) setValue: ForKey:的key必须是不为nil的字符串类型；setObject: ForKey:的key可以是不为nil的所有继承NSCopying的类型。]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSNotificationCenter实现]]></title>
    <url>%2F2018%2F07%2F10%2F2015%2FNSNotification%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[多次添加多次执行 iOS8之后不需要移除，移除方法自动添加 unsafe_unretained修饰 关于为什么允许多次添加通知？一允许开发者自己控制，二对事件复杂度的妥协，它的实现原理决定了，要在数组中找到这个完全一样的通知对象并不容易 原文链接 透彻理解 NSNotificationCenter 通知（含实现代码） 写在前面NSNotificationCenter这个东西作为iOS工程师想必都不陌生，但是有人可能连参数的意义都没搞明白，写这篇文章的目的不止是为了让不会用的人会用，更是为了让会用的人理解得更透彻。本篇文章主要是梳理NSNotificationCenter的特性和值得注意的地方，并且在后面结合对其特性的分析手动利用代码来实现它。 一、分析1、 基本使用方法直接进入NSNotification文件。@property (class, readonly, strong) NSNotificationCenter *defaultCenter;该属性是获取NSNotificationCenter唯一单例，它就是一个消息分发中心，通过使用这个唯一的实例我们进行添加通知、发送通知、移除通知。 (1) 添加通知1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(respondsToNotification:) name:@&quot;test0&quot; object:_obj0]; _obj0是创建的一个实例，这里暂时不讨论object参数的用法。Observer即为响应者无需多说；selector即为一个响应通知的方法，需要SEL类型；name是一个标识，通知中心主要是通过它来实现消息的精确分发（当然object也有定位作用）。 (2) 发送通知12345//便利方法[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;test0&quot; object:_obj0 userInfo:@&#123;@&quot;key&quot;:@&quot;_obj0&quot;&#125;];//使用NSNotificationNSNotification *notification = [[NSNotification alloc] initWithName:@&quot;test0&quot; object:_obj2 userInfo:@&#123;@&quot;key&quot;:@&quot;_obj2&quot;&#125;]; [[NSNotificationCenter defaultCenter] postNotification:notification]; 发送通知和添加通知对应，需要name、object参数，这里多了一个userInfo，该参数可以把你需要携带的数据发送给该通知的响应者。其实我们可以很轻易的想到，便利发送通知方法不过是对于使用NSNotification发送通知的一个语法糖，NSNotification才是消息体。 (3) 移除通知123456//移除该响应者的全部通知[[NSNotificationCenter defaultCenter] removeObserver:self];//移除该响应者 name==@&quot;test0&quot; 的全部通知[[NSNotificationCenter defaultCenter] removeObserver:self name:@&quot;test0&quot; object:nil];//移除该响应者 name==@&quot;test0&quot; 且 object==_obj0 的全部通知[[NSNotificationCenter defaultCenter] removeObserver:self name:@&quot;test0&quot; object:_obj0]; 移除通知这里有点讲究，从上至下越来越“精准”。在合理的位置移除通知是至关重要的： 1、让不希望继续接受通知的响应者失去对该通知的响应； 2、避免重复添加相同通知（响应者的内存为同一块的时候）； 3、通知中心对响应者observer是使用unsafe_unretained修饰，当响应者释放会出现野指针，向野指针发送消息造成崩溃；在iOS n(更新的系统版本有待考证)之后，苹果对其做了优化，会在响应者调用dealloc方法的时候执行removeObserver:方法。注意：在后文会详细分析该问题。 当然，常规的业务场景一般是在该响应者释放的时候移除。 123- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; (4) 响应通知12345- (void)respondsToNotification:(NSNotification *)noti &#123; id obj = noti.object; NSDictionary *dic = noti.userInfo; NSLog(@&quot;\n- self:%@ \n- obj:%@ \n- notificationInfo:%@&quot;, self, obj, dic);&#125; 响应通知的时候会将NSNotification消息体传递过来，如代码所示。 2、object:(nullable id)anObject参数添加通知时，若指定了object参数，那么该响应者只会接收发送通知时object参数指定为同一实例的通知。发送通知时，若指定了object参数，并不会影响添加通知时没有指定object参数的响应者接收通知。如果感觉有点绕，看如下代码便知。 1234//添加通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(respondsToNotification:) name:@&quot;test0&quot; object:nil];//发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;test0&quot; object:_obj0]; //由于添加通知时，object==nil，所以该响应者仍然能接收到该通知。复制代码 1234//添加通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(respondsToNotification:) name:@&quot;test0&quot; object: _obj0];//发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;test0&quot; object:nil]; //由于添加通知时，指定了object==_obj0，而发送通知时，object==nil，所以无法接收到通知//（只有当object==_obj0才能接收到通知）。复制代码 3、通知线程问题我们进入全局队列发送这个通知 1234dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;发送通知 currentThread : %@&quot;, [NSThread currentThread]); [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;test0&quot; object:nil];&#125;); 在接收通知的地方将线程打印出来 12发送通知 currentThread : &lt;NSThread: 0x60400046aec0&gt;&#123;number = 3, name = (null)&#125;响应通知 currentThread : &lt;NSThread: 0x60400046aec0&gt;&#123;number = 3, name = (null)&#125; 结论：通知发送线程和通知接收线程是一致的。 由此看来，如果当我们不是百分之百确认通知的发送队列是在主队列中时，我们最好加上如下代码从而对我们的UI进行处理。 1234567if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) &#123; //UI处理&#125; else &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; //UI处理 &#125;);&#125; 4、是否需要移除通知？以下代码模拟重复添加通知的情况，所以如果可能会重复添加通知，我们都应该做好相应的处理。 123for (int i = 0; i &lt; 3; i++) &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(respondsToNotification:) name:@&quot;test0&quot; object:nil];&#125; //该代码导致的结果是，响应通知回调会走三次。复制代码可能有人会问，为什么系统库没有做个重复添加的判断？当然，这可能是为了让我们更灵活的运用，也可能是对时间复杂度的一种妥协吧😁。 有过比较长开发经验的同学应该都有过，没有及时的移除通知而导致意外崩溃的情况。前面也说过，通知中心对响应者observer是使用unsafe_unretained修饰，当响应者释放会出现野指针，如果向野指针发送消息造成崩溃。在iOS8系统之后（更早版本没有测试），[NSNotificationCenter defaultCenter]会在响应者observer调用-dealloc方法的时候执行-removeObserver:方法。 动手做个小实验：新建一个NSNotificationCenter的分类，代码如下： 1234567891011@implementation NSNotificationCenter (YB)+ (void)load &#123; Method origin = class_getInstanceMethod([self class], @selector(removeObserver:)); Method current = class_getInstanceMethod([self class], @selector(_removeObserver:)); method_exchangeImplementations(origin, current);&#125;- (void)_removeObserver:(id)observer &#123; NSLog(@&quot;调用移除通知方法: %@&quot;, observer);// [self _removeObserver:observer];&#125;@end 然后新建一个类正常的使用通知，但是请不要手动在-dealloc中释放通知（我们要做实验）。然后我们释放掉这个类（可以使用控制器present、dismiss）。 调用移除通知方法: 复制代码神奇的现象发生了，通过比较内存地址，[NSNotificationCenter defaultCenter]确实是调用了removeObserver :方法移除对应响应者的通知监听。 注意上面的代码中，我将[self _removeObserver:observer];注释掉了，意味着该方法已经被我截取了，我们再向该“移除通知未遂”的响应者observer发送通知，直接崩溃。当去除注释，正常运行，无需手动移除。 结论：如果iOS支持版本在iOS8以上，多数情况理论上可以不用移除通知，但是由于历史遗留、开发者习惯等因素，看个人喜好了 二、代码实现NSNotification 代码实现地址心血来潮，看着NSNotification.h的API和本着对其的理解，决定着手实现一波。其实仔细一想，通知的功能类似于一个路由，它的基本实现思路并不复杂。我们要做的无非是“添加”、“发送”、“移除”三件事。但是在具体实现中，还是有些比较麻烦的地方，下面具体叙述（最好下载demo便于理解）。 1、添加通知首先，创建了一个YBNotificationCenter类，属性如下： 12@property (class, strong) YBNotificationCenter *defaultCenter;@property (strong) NSMutableDictionary *observersDic; defaultCenter类属性不用说，它是唯一单例（具体实现看代码）；observersDic即为用来存储添加通知相关信息的字典。 然后创建了一个YBObserverInfoModel类，属性如下： 12345678@property (weak) id observer;@property (strong) id observer_strong;@property (strong) NSString *observerId;@property (assign) SEL selector;@property (weak) id object;@property (copy) NSString *name;@property (strong) NSOperationQueue *queue;@property (copy) void(^block)(YBNotification *noti); 该类就是响应者信息存储模型类，也就是会放在上面observersDic字典内的元素。先回忆一下，当我们使用- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSString *)aName object:(nullable id)anObject;或- (id&lt;NSObject&gt;)addObserverForName:(nullable NSString *)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(YBNotification *note))block;方法时，这些配置的变量是不是在YBObserverInfoModel都有体现呢？ 是的，添加通知的操作不过就是将我们需要配置的变量统统存储起来，但是注意几点：一是对observer和object不能强持有，否则其无法正常释放；二是对name属性最好使用copy修饰，保证其不会受外部干扰；三是observer_strong属性是在使用代码块回调的那个添加通知方法时，需要使用到的强引用属性；四是observerId属性会比较陌生，它的作用大家可以先不管，之后会有用处。 添加通知核心代码 123456789101112131415- (void)addObserverInfo:(YBObserverInfoModel *)observerInfo &#123; //添加进observersDic NSMutableDictionary *observersDic = YBNotificationCenter.defaultCenter.observersDic; @synchronized(observersDic) &#123; NSString *key = (observerInfo.name &amp;&amp; [observerInfo.name isKindOfClass:NSString.class]) ? observerInfo.name : key_observersDic_noContent; if ([observersDic objectForKey:key]) &#123; NSMutableArray *tempArr = [observersDic objectForKey:key]; [tempArr addObject:observerInfo]; &#125; else &#123; NSMutableArray *tempArr = [NSMutableArray array]; [tempArr addObject:observerInfo]; [observersDic setObject:tempArr forKey:key]; &#125; &#125;&#125; 我们传入一个配置好的YBObserverInfoModel模型进入方法，构建一个树形结构，用传入的name作为key（如果name为空使用key_observersDic_noContent常量代替），把所有使用相同name的通知放进同一个数组作为value，并且添加了线程锁保证observersDic数据读写安全。 这么做的理由：在通知的整个功能体系中，“添加”、“发送”、“移除”哪一步对效率的要求最高？毫无疑问是“发送”的时候，我们通常使用- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject方法发送通知，aName参数将是我们找到对应通知的第一匹配点。如果我们将其它参数作为observersDic的key，我们发送通知的时候不得不遍历整个observersDic；而如上代码实现，发送通知的时候，直接就能通过key直接找到对应的通知信息了，有效降低了时间复杂度。 使用代码块回调通知方法的实现 12345678910111213141516- (id&lt;NSObject&gt;)addObserverForName:(NSString *)name object:(id)obj queue:(NSOperationQueue *)queue usingBlock:(void (^)(YBNotification * _Nonnull))block &#123; if (!block) &#123; return nil; &#125; YBObserverInfoModel *observerInfo = [YBObserverInfoModel new]; observerInfo.object = obj; observerInfo.name = name; observerInfo.queue = queue; observerInfo.block = block; NSObject *observer = [NSObject new]; observerInfo.observer_strong = observer; observerInfo.observerId = [NSString stringWithFormat:@&quot;%@&quot;, observer]; [self addObserverInfo:observerInfo]; return observer;&#125; 这里有个地方需要提出来谈谈，在使用系统的这个方法的时候，一经实验就能发现，不管我们强引用或者弱引用这个返回值id时，都能在业务类dealloc释放的时候有效的移除该通知。 由于使用该方法添加通知的时候不会传入observer参数，这里创建了一个observer，如果这里使用observerInfo.observer = observer;，而业务类没有强引用这个返回值observer，它将会自然释放。所以，这里做了一个特殊处理，让observerInfo实例强持有observer。 值得注意的是，外部如果强引用返回的id类型的observer，会造成observer无法及时的释放，但是这点内存我认为还是可以接受的，当然业务类使用弱引用该observer是最好的选择。 2、发送通知和系统通知一样，同样创建了一个类YBNotification发送通知消息体，属性就我们熟悉的几个：123456789101112131415161718192021222324252627282930313233343536@property (copy) NSString *name;@property (weak) id object;@property (copy) NSDictionary *userInfo;复制代码然后将&lt;NSCopying, NSCoding&gt;两个协议实现一下就好了，具体看demo。发送通知核心代码- (void)postNotification:(YBNotification *)notification &#123; if (!notification) &#123; return; &#125; NSMutableDictionary *observersDic = YBNotificationCenter.defaultCenter.observersDic; NSMutableArray *tempArr = [observersDic objectForKey:notification.name]; if (tempArr) &#123; [tempArr enumerateObjectsUsingBlock:^(YBObserverInfoModel *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if (obj.block) &#123; if (obj.queue) &#123; NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; obj.block(notification); &#125;]; NSOperationQueue *queue = obj.queue; [queue addOperation:operation]; &#125; else &#123; obj.block(notification); &#125; &#125; else &#123; if (!obj.object || obj.object == notification.object) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; obj.observer?[obj.observer performSelector:obj.selector withObject:notification]:nil;#pragma clang diagnostic pop &#125; &#125; &#125;]; &#125;&#125; 发送通知相对简单，只需要分清是使用代码块回调，还是通过执行SEL回调。在使用代码块回调时，如果传入了队列queue，就让该代码块在该队列中执行，否则正常执行。!obj.object || obj.object == notification.objectif语句中这个判断值得注意。 3、移除通知移除通知本身简单，有些麻烦的是自动移除。先贴上移除代码： 12345678910111213141516171819202122232425- (void)removeObserverId:(NSString *)observerId name:(NSString *)aName object:(id)anObject &#123; if (!observerId) &#123; return; &#125; NSMutableDictionary *observersDic = YBNotificationCenter.defaultCenter.observersDic; @synchronized(observersDic) &#123; if (aName &amp;&amp; [aName isKindOfClass:[NSString class]]) &#123; NSMutableArray *tempArr = [observersDic objectForKey:[aName mutableCopy]]; [self array_removeObserverId:observerId object:anObject array:tempArr]; &#125; else &#123; [observersDic enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSMutableArray *obj, BOOL * _Nonnull stop) &#123; [self array_removeObserverId:observerId object:anObject array:obj]; &#125;]; &#125; &#125;&#125;- (void)array_removeObserverId:(NSString *)observerId object:(id)anObject array:(NSMutableArray *)array &#123; @autoreleasepool &#123; [array.copy enumerateObjectsUsingBlock:^(YBObserverInfoModel *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([obj.observerId isEqualToString:observerId] &amp;&amp; (!anObject || anObject == obj.object)) &#123; [array removeObject:obj]; &#125; &#125;]; &#125;&#125; 所有移除通知的方法，最终落脚点都是在这里。上面方法中，如果aName不是合理的，就需要遍历observersDic移除对应的通知；如果aName是合理的，就直接查找对应的数组移除内容。下面方法中，由于array.copy造成了局部变量，而上级可能是一个遍历，所以得加上自动释放池避免内存泄露。 使用observerId属性移除通知，而不用observer响应者来直接比较移除：还记得添加通知时YBObserverInfoModel类的@property (strong) NSString *observerId;属性么？在添加通知的时候，我将响应者的地址信息作为该属性的值（保证其唯一性）： observerInfo.observerId = [NSString stringWithFormat:@”%@”, observer];复制代码然后在移除的时候通过比较进行相应的操作。 实现自动移除通知（解释为何使用observerId移除通知而不用observer）实现自动移除通知，思路是在响应者observer走dealloc的时候移除对应的通知，难点就是在ARC中是不允许对dealloc做继承和交换方法等操作的，所以我使用了一个缓兵之计——动态给observer添加一个属性，我们监听这个属性的dealloc方法移除对应的通知，代码如下： 1234567891011121314151617181920212223242526- (void)addObserverInfo:(YBObserverInfoModel *)observerInfo &#123; //为observer关联一个释放监听器 id resultObserver = observerInfo.observer?observerInfo.observer:observerInfo.observer_strong; if (!resultObserver) &#123; return; &#125; YBObserverMonitor *monitor = [YBObserverMonitor new]; monitor.observerId = observerInfo.observerId; const char *keyOfmonitor = [[NSString stringWithFormat:@&quot;%@&quot;, monitor] UTF8String]; objc_setAssociatedObject(resultObserver, keyOfmonitor, monitor, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //添加进observersDic NSMutableDictionary *observersDic = YBNotificationCenter.defaultCenter.observersDic; @synchronized(observersDic) &#123; NSString *key = (observerInfo.name &amp;&amp; [observerInfo.name isKindOfClass:NSString.class]) ? observerInfo.name : key_observersDic_noContent; if ([observersDic objectForKey:key]) &#123; NSMutableArray *tempArr = [observersDic objectForKey:key]; [tempArr addObject:observerInfo]; &#125; else &#123; NSMutableArray *tempArr = [NSMutableArray array]; [tempArr addObject:observerInfo]; [observersDic setObject:tempArr forKey:key]; &#125; &#125;&#125; 只不过在添加通知到observersDic之前，添加一个monitor实例，使用objc_setAssociatedObject动态关联方法给resultObserver添加一个强引用的属性，注意objc_setAssociatedObject方法的第二个参数必须保证其唯一性，因为同一个响应者可能添加多个通知。 好了，现在基本工作都完成了，只需要在这个YBObserverMonitor方法中做简单的移除逻辑就OK了，代码如下： 12345678910//监听响应者释放类@interface YBObserverMonitor : NSObject@property (strong) NSString *observerId;@end@implementation YBObserverMonitor- (void)dealloc &#123; NSLog(@&quot;%@ dealloc&quot;, self); [YBNotificationCenter.defaultCenter removeObserverId:self.observerId];&#125;@end 机智的你发现了什么了么？类释放的顺序是先自己释放然后其属性释放，也就是说理论上在走YBObserverMonitor的 dealloc时，observer响应者对象已经释放了。这就是为什么不直接使用observer响应者对象对比做释放操作。 写在后面关于实现部分，虽然我做了个大致的测试，可能还是会存在一些潜在的问题，希望各位大佬不惜笔墨点拨一番😁。]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv使用入门]]></title>
    <url>%2F2018%2F06%2F06%2F2018%2Fopencv%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[DCT信息的获取12345678910111213141516import cv2import numpy as npdef dct(m): # img = np.uint8(dst)*255.0 m = np.float32(m)/255.0 return cv2.dct(m)*255img = cv2.imread(&apos;new.jpeg&apos;,0)#cv2.IMREAD_COLOR，最后一个参数留空代表彩色，如果用0代表灰度载入cv2.namedWindow(&apos;image&apos;,cv2.WINDOW_NORMAL)cv2.imshow(&apos;image&apos;,img)#显示图像，cv2.waitKey(0)#等待键盘输入，为毫秒级cv2.destroyAllWindows()#可以轻易删除任何我们建立的窗口，括号内输入想删除的窗口名 分通道，合并，存储图片12345678910111213141516171819202122232425262728293031323334import cv2 import numpy as np import matplotlib.pyplot as plt img = cv2.imread(&quot;new.jpeg&quot;) #全色彩b, g, r = cv2.split(img)#通道拆分out = cv2.merge([b,g,r])img1 = cv2.imread(&apos;new.jpeg&apos;,0) #一个通道的色彩def dct(m): m = np.float32(m)/255.0 return cv2.dct(m)*255img_dct = dct(img1) #进行离散余弦变换 img_dct_log = np.log(abs(img_dct)) #进行log处理 img_recor2 = cv2.idct(img_dct) #进行离散余弦反变换 plt.subplot(121) plt.imshow(img, &apos;gray&apos;) plt.title(&apos;original image&apos;) plt.subplot(122) plt.imshow(out,&apos;gray&apos;) plt.title(&apos;IDCT2(cv2_idct)&apos;) cv2.imwrite(&quot;ouput.jpg&quot;,img) #存储要注意，只能存储为jpg格式，因为我解出来后没有进行压缩，不知道压缩后不能不能存储为jpeg，这里如果改为jpeg会报错 could not find a writer for the specified extension in function cv::imwrite_plt.show() 自行分离123456789101112131415161718自行分离三通道函数定义了三个函数来获取三个通道的子矩阵。获取红色通道：def get_red(img): redImg = img[:,:,2] return redImg获取绿色通道：def get_green(img): greenImg = img[:,:,1] return greenImg获取蓝色通道def get_blue(img): blueImg = img[:,:,0] return blueImg opencv的DCT使用123456789101112131415161718192021import cv2import numpy as npB = np.array([[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8]])#最少需要8*8B = B.astype(&apos;float&apos;) #int转floatprint Bprint type(B)print B.shapedctn = cv2.dct(B) #dct变换print dctn.shapeprint dctnB1 = cv2.idct(dctn) #逆dct变换成原来的数据print B1 opencv加载图像123456789101112131415161718import cv2import numpy as npimport matplotlib.pyplot as plt B=8 # blocksize (In Jpeg theimg1 = cv2.imread(&quot;new.jpeg&quot;)h,w=np.array(img1.shape[:2])/B * B #进行像素个数的格式化，因为这样就可以保证是8*8的个数配比了print h,wimg1=img1[:h,:w] #这一步去掉无用的数据，而不是像我想的，增加像素#Convert BGR to RGBimg2=np.zeros(img1.shape,np.uint8)img2[:,:,0]=img1[:,:,2]img2[:,:,1]=img1[:,:,1]img2[:,:,2]=img1[:,:,0]# plt.imshow(img1) #这个显示的时候是BGR颜色有点奇怪plt.imshow(img2) 完整例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import cv2 import numpy as np import matplotlib.pyplot as plt img = cv2.imread(&quot;ori.jpg&quot;) #全色彩b,g,r = cv2.split(img)imgYCC = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)y,cr,cb = cv2.split(imgYCC)QY=np.array([[16,11,10,16,24,40,51,61], [12,12,14,19,26,48,60,55], [14,13,16,24,40,57,69,56], [14,17,22,29,51,87,80,62], [18,22,37,56,68,109,103,77], [24,35,55,64,81,104,113,92], [49,64,78,87,103,121,120,101], [72,92,95,98,112,100,103,99]])def compile(y): print &apos;y&apos; print y b = y.astype(&apos;float&apos;)# b = y.astype(&apos;float&apos;) print type(b) print &apos;b&apos; print b bd = b[:8,:8] print bd.shape print &apos;bd&apos; print bd bdct = cv2.dct(bd) print &apos;bdct&apos; print bdct print &apos;8&apos; print bdct.astype(&apos;int16&apos;) # dct1 = np.uint8(bdct) dct1 = bdct.astype(&apos;int16&apos;) dct1 = dct1 / QY print &apos;dct1&apos; print dct1 return dct1dct1 = compile(y)dct1 = dct1 * QYimgf = dct1.astype(&apos;float&apos;)# print &apos;imgf&apos;,imgfiTrans = cv2.idct(imgf)# print &apos;iTrans&apos;,iTransy2 = iTrans.astype(&apos;int16&apos;)print &apos;y2&apos;,y2dct2 = compile(y2.astype(&apos;float&apos;))dst = cv2.cvtColor(img_YUV, cv2.COLOR_YUV2BGR)# dct2 = compile(y2) 基于DCT和RBG方差的隐写算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396import cv2import numpy as npimport matplotlib.pyplot as pltfrom compiler.ast import flattenQC=np.array([[17,18,24,47,99,99,99,99], [18,21,26,66,99,99,99,99], [24,26,56,99,99,99,99,99], [47,66,99,99,99,99,99,99], [99,99,99,99,99,99,99,99], [99,99,99,99,99,99,99,99], [99,99,99,99,99,99,99,99], [99,99,99,99,99,99,99,99]])QY=np.array([[16,11,10,16,24,40,51,61], [12,12,14,19,26,48,60,55], [14,13,16,24,40,57,69,56], [14,17,22,29,51,87,80,62], [18,22,37,56,68,109,103,77], [24,35,55,64,81,104,113,92], [49,64,78,87,103,121,120,101], [72,92,95,98,112,100,103,99]])# QY=np.array([[8,1,1,1,1,1,1,1],# [1,1,1,1,1,1,1,55],# [1,1,1,1,1,1,69,56],# [1,1,1,1,1,87,80,62],# [1,1,1,1,68,109,103,77],# [1,1,1,64,81,104,113,92],# [1,1,78,87,103,121,120,101],# [1,92,95,98,112,100,103,99]])zag = [(7,7),(7,6),(6,7),(5,7),(6,6),(7,5),(7,4),(6,5), (5,6),(4,7),(3,7),(4,6),(5,5),(6,4),(7,3),(7,2), (6,3),(5,4),(4,5),(3,6),(2,7),(1,7),(2,6),(3,5), (4,4),(5,3),(6,2),(7,1),(7,0),(6,1),(5,2),(4,3), (3,4),(2,5),(1,6),(0,7),(0,6),(1,5),(2,4),(3,3), (4,2),(5,1),(6,0),(5,0),(4,1),(3,2),(2,3),(1,4), (0,5),(0,4),(1,3),(2,2),(3,1),(4,0),(3,0),(2,1), (1,2),(0,3),(0,2),(1,1),(2,0),(1,0),(0,1),(0,0)]singleO = &apos;0b&apos;output = &apos;&apos;printindex = []writeinfolist = []index = 0def convertcontenttobit(content): #把文字转化为二进制进行写入 global writeinfolist strnew = content# bits = [] for item in list(strnew): bit = ord(item) #转位置编码 bitstring = bin(bit) #位置编码转二进制 bitnew = bitstring[2:] bitnew = &apos;0&apos; * (8 - len(bitnew)) + bitnew bitnewlist = [] for bi in bitnew: bitnewlist.append(int(bi)) writeinfolist = writeinfolist + bitnewlist end = [1,1,1,1,1,1,1,1] writeinfolist = writeinfolist + end print writeinfolist def convertbittocontent(bit): #把二进制读取然后转化为文字 global singleO global output bits = str(bit) if len(singleO) == 9: singleO = singleO + bits if singleO.count(&apos;1&apos;) &gt; 6: print &apos;eeeeeend&apos;,singleO return False inten = int(singleO,2) output = output + chr(inten) print &apos;*********&apos;,singleO,chr(inten) singleO = &apos;0b&apos; else: singleO = singleO + bits return True def writeinfo(origin): global index global writeinfolist if index &gt;= len(writeinfolist) - 1: return origin data = writeinfolist[index] # data = 1 lower_bit=origin%2 # print index,len(writeinfolist),lower_bit,data,origin if lower_bit==data:# print index,len(writeinfolist),lower_bit,data,origin# print &apos;---------------&apos; index = index + 1 return origin elif origin&gt;0: if (lower_bit,data) == (0,1): origin = origin+1 elif (lower_bit,data) == (1,0): origin = origin-1 elif origin&lt;0: if (lower_bit,data) == (0,1): origin=origin-1 elif (lower_bit,data) == (1,0): origin=origin+1 # print index,len(writeinfolist),lower_bit,data,origin# print &apos;---------------&apos; index = index + 1 return origindef findcanwritedct(dct): global index global writeinfolist change = False # if index == len(writeinfolist) - 1:# return dct,change dcttemp = dct.copy() dcttemp[0,0] = 0 z = np.fabs(dcttemp) z = flatten(z.tolist()) lenz = len(z) zerocount = z.count(0) sumz = np.sum(z) total = sumz * 1.0 / (lenz - zerocount)# if total &gt; 1 and dct[0,0] &lt; 100: change = True dct[0,0] = writeinfo(dct[0,0])# for i in range(63):# target = dct[zag[i]]# if target not in [-1,0,1]:# dct[zag[i]] = writeinfo(target)# change = True# break return dct,changedef findwriteddct(dct): # dcttemp = dct.copy()# dcttemp[0,0] = 0 # z = np.fabs(dcttemp)# z = flatten(z.tolist())# lenz = len(z)# zerocount = z.count(0)# sumz = np.sum(z)# total = sumz * 1.0 / (lenz - zerocount)# if total &gt; 1 and dct[0,0] &lt; 100: change = True# dct[0,0] = writeinfo(dct[0,0]) return dct[0,0]# for i in range(63):# if dct[zag[i]] not in [-1,0,1]:# return dct[zag[i]]# break # return Nonedef converttodct(y): global QY b = y.astype(&apos;float&apos;) bdct = cv2.dct(b) dct1 = bdct.tolist() dct1 = np.around(dct1) #四舍五入 dct1 = dct1 / QY dct1 = dct1.tolist() dct1 = np.around(dct1) #再次四舍五入 dct1 = dct1.astype(&apos;int16&apos;) dct1,change = findcanwritedct(dct1) return dct1,changedef converttoycr(dct): global QY dct = dct * QY imgf = dct.astype(&apos;float&apos;) iTrans = cv2.idct(imgf) iTrans = iTrans.tolist() iTrans = np.around(iTrans) cr = iTrans.astype(&apos;int16&apos;) return crdef readinfofromyc(cr8): global QY global index global printindex global writeinfolist b = cr8.astype(&apos;float&apos;) aver = b.mean() if aver &gt; 200 or aver &lt; 60: return True bdct = cv2.dct(b) dct1 = bdct.tolist() dct1 = np.around(dct1) #四舍五入 dct1 = dct1 / QY dct1 = dct1.tolist() dct1 = np.around(dct1) #再次四舍五入 dct1 = dct1.astype(&apos;int16&apos;) var = b.var()# print var# print dct1# key = aver / 2# topline = aver * 1.4# m = b[np.where(b &lt; key)].shape[0]# n = b[np.where(b &gt; topline)].shape[0]# if var &gt; 5 or m &gt; 10 or n &gt; 5:# return True if var &gt; 1: return True # if dct1[0,0] % 2 == 1:# print &apos;aver&apos;,aver# print &apos;shape+++++++&apos;,m# print &apos;origin&apos;,b# print &apos;dct&apos;,dct1# print &apos;var&apos;,b.var() if (index - 1) in printindex: print &apos;new############start&apos;,writeinfolist[index - 1],index - 1 print dct1 print cr8 print &apos;new############end&apos; origin = findwriteddct(dct1) if (origin != None): return convertbittocontent(origin % 2)def addinfotoyc(yc8): global index global printindex global writeinfolist aver = yc8.mean() if aver &gt; 200 or aver &lt; 60: return yc8 var = yc8.var()# key = aver / 2# topline = aver * 1.4# m = yc8[np.where(yc8 &lt; key)].shape[0]# n = yc8[np.where(yc8 &gt; topline)].shape[0]# if var &gt; 3 or m &gt; 10 or n &gt; 5:# print yc8# print &apos;var&apos;,var# print &apos;m&apos;,m# print &apos;n&apos;,n# print &apos;topline&apos;,topline# print &apos;key&apos;,key# print &apos;aver&apos;,aver# return yc8 if var &gt; 1: return yc8 dct,change = converttodct(yc8) if change == False: return yc8 cr = converttoycr(dct) if cr.var() &gt; 1: index = index - 1# print &apos;origin&apos;# print yc8# print &apos;oldvar&apos;,var# print &apos;new&apos;# print cr# print &apos;newvar&apos;,cr.var()# print &apos;index&apos;,index return yc8 # print dct# print cr.var() if (index - 1) in printindex: print &apos;origin###########start&apos;,writeinfolist[index-1],index - 1 print dct print cr print &apos;origin###########end&apos; readinfofromyc(cr) cr[np.where(cr &gt; 254)] = 254 cr[np.where(cr &lt; 1)] = 0 return crdef convertimg(img): B = 8 imgYCC = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB) h,w=np.array(imgYCC.shape[:2])/B * B #进行像素个数的格式化，因为这样就可以保证是8*8的个数配比了 imgYCC = imgYCC[:h,:w] #这一步去掉无用的数据，而不是像我想的，增加像素 y = imgYCC[:,:,0] cr = imgYCC[:,:,1] cb = imgYCC[:,:,2] return y,cr,cbdef scanpiex(cr): global index # crn = np.zeros(cr.shape) crn = cr.copy() (h,w) = cr.shape h = h/8 w = w/8 print h,w for i in range(0,h): for j in range(0,w): cr8 = cr[i*8:i*8+8,j*8:j*8+8] crn[i*8:i*8+8,j*8:j*8+8] = addinfotoyc(cr8) if index &gt;= len(writeinfolist) - 1: print &apos;stop&apos;,&apos;i=&apos;,i,&apos;j=&apos;,j,&apos;i*j=&apos;,i * j index = 0 return crn index = 0 return crndef readinfo(cr): global output (h,w) = cr.shape h = h/8 w = w/8 print h,w for i in range(0,h): for j in range(0,w): cr8 = cr[i*8:i*8+8,j*8:j*8+8] out = readinfofromyc(cr8)# print &apos;stop&apos;,&apos;i=&apos;,i,&apos;j=&apos;,j,&apos;i*j=&apos;,i * j if out == False or (i == (h - 1) and j == (w - 1)): print output breakdef test(): print &apos;write&apos;,writeinfolist img = cv2.imread(&quot;WechatIMG37.jpeg&quot;) #全色彩 y,cr,cb = convertimg(img) y = scanpiex(y) y = y.astype(&apos;uint8&apos;) print &apos;分割线分割线分割线&apos; img_YCbCr = cv2.merge([y,cr,cb]) imgnew = cv2.cvtColor(img_YCbCr, cv2.COLOR_YCR_CB2BGR)# cv2.imwrite(&quot;newpress.jpg&quot;,imgnew,[cv2.IMWRITE_JPEG_QUALITY, 50]) cv2.imwrite(&quot;newpress.jpg&quot;,imgnew) imgout = cv2.imread(&quot;newpress.jpg&quot;) #全色彩 y,cr,cb = convertimg(imgout) print &apos;read&apos; readinfo(y) def writecontent(): global writeinfolist global output convertcontenttobit(&apos;wangxiugang618wangxiugang618wangxiugang618wangxiugang618wangxiugang618&apos;) def readimage(imagename): imgout = cv2.imread(imagename) #全色彩 y,cr,cb = convertimg(imgout) print &apos;read&apos; readinfo(y)writecontent()test()# readimage(&apos;WechatIMG65.jpeg’)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS包大小计算备忘]]></title>
    <url>%2F2018%2F05%2F30%2F2018%2FiOS%E5%8C%85%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[首先需要LinkMap文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359#!/usr/bin/env python#coding:utf-8import os,shutilimport urllib2import time, sys,copyfrom pymongo import MongoClientfrom biplist import *from prettytable import PrettyTablefrom numpy import *# 0源码 1SDK# (projectname,sdkname,filename,size)projectNameList = []#记录工程名字列表def parItemText(text): global projectNameList fileNumberList = []#文件编号列表 fileSizeDic = &#123;&#125;#文件尺寸字典 projectNameDic = &#123;&#125;#工程名字字典，记录大小 fileItems = text.split(&apos;\n&apos;) count = 0 for singleItem in fileItems: # 最后是括号 # 最后是.o # 最后是 projectname = &apos;&apos; # 最外层name，比如Library sdkname = &apos;&apos; # 编译完之后的名字.a或者.framework filename = &apos;&apos; # .o的名字 if len(singleItem) &gt; 0 and singleItem[0] == &apos;[&apos;: if singleItem[-1] == &apos;)&apos;: if &apos;Analyse-iphoneos&apos; in singleItem:#源码 # print singleItem + &apos;源码&apos; filenameitem = singleItem.split(&apos;/&apos;)[-1] count = count + 1 nameL = filenameitem.split(&apos;(&apos;)[0].replace(&apos;.a&apos;,&apos;&apos;) nameR = filenameitem.split(&apos;(&apos;)[1].replace(&apos;.o&apos;,&apos;&apos;).replace(&apos;)&apos;,&apos;&apos;) filename = nameR if &apos;lib&apos; in nameL: nameL = nameL.replace(&apos;lib&apos;,&apos;&apos;) sdkname = nameL else: projectname = nameL elif &apos;JRMobileAnalyse/&apos; in singleItem or &apos;../&apos; in singleItem:#SDK # print singleItem + &apos;SDK文件&apos; filenameitems = singleItem.split(&apos;/&apos;) filenameitem = filenameitems[-1] indexJR = -1 indexVe = -1 indexPods = -1 if &apos;JRLibrary&apos; in filenameitems: indexJR = filenameitems.index(&apos;JRLibrary&apos;) if &apos;Vendors&apos; in filenameitems: indexVe = filenameitems.index(&apos;Vendors&apos;) if &apos;Pods&apos; in filenameitems: indexVe = filenameitems.index(&apos;Pods&apos;) index = 0 if indexJR != -1: index = indexJR + 1 elif indexVe != -1: index = indexVe + 1 elif indexPods != -1: index = indexPods + 1 count = count + 1 nameL = filenameitem.split(&apos;(&apos;)[0].replace(&apos;.a&apos;,&apos;&apos;) nameR = filenameitem.split(&apos;(&apos;)[1].replace(&apos;.o&apos;,&apos;&apos;).replace(&apos;)&apos;,&apos;&apos;) filename = nameR projectname = filenameitems[index] sdkname = nameL else: # print singleItem + &apos;其他的&apos; filenameitem = singleItem.split(&apos;/&apos;)[-1] filename = filenameitem projectname = &apos;Apple&apos; sdkname = &apos;Apple&apos; count = count + 1 elif &apos;] /Applications&apos; in singleItem: # print singleItem + &apos;系统文件&apos; filenameitem = singleItem.split(&apos;/&apos;)[-1] filename = filenameitem projectname = &apos;Apple&apos; sdkname = &apos;Apple&apos; count = count + 1 else: if singleItem[-1] == &apos;o&apos;: # print singleItem + &apos;主工程&apos; count = count + 1 projectname = &apos;JDMobile&apos; filename = singleItem.split(&apos;/&apos;)[-1].replace(&apos;.o&apos;,&apos;&apos;) # print &apos;-------&gt;&apos;,&apos;projectname,filename filenumber = singleItem.split(&apos;] &apos;)[0] + &apos;]&apos; if filenumber not in fileNumberList: fileNumberList.append(filenumber) # print filenumber,projectname,sdkname,filename fileSizeDic[filenumber] = [projectname,sdkname,filename,0] elif singleItem[:2] == &apos;0x&apos;: if chr(9) + &apos;[&apos; in singleItem: sizestring = singleItem.split(chr(9)+&apos;[&apos;)[0].split(chr(9))[1] size = int(sizestring,16) filenumber = &apos;[&apos; + singleItem.split(chr(9)+&apos;[&apos;)[1].split(&apos;]&apos;)[0] + &apos;]&apos; fileList = fileSizeDic.get(filenumber) if type(fileList) != type(None): fileSize = fileList[3] fileList[3] = fileSize + size else: print singleItem print filenumber for item in fileNumberList: fileList = fileSizeDic[item] projectname = fileList[0] sdkname = fileList[1] size = fileList[3] name = &apos;&apos; if len(projectname) == 0: name = sdkname else: name = projectname if name not in projectNameList: projectNameList.append(name) objec = projectNameDic.get(name) if type(objec) == type(None): projectNameDic[name] = (size,1) else: (projectSize,count) = objec projectNameDic[name] = (size + projectSize,count + 1) return projectNameDicdef saveDataToMongo(): global projectNameList mc = MongoClient(&quot;localhost&quot;,27017) db = mc.classsize baseinfo = db.baseinfo sourceFileList = [&apos;JDMobile&apos;,&apos;Pods&apos;,&apos;CommunityTools&apos;,&apos;JRAssemblyUITools&apos;,&apos;JRBankCardModule&apos;,&apos;JRHomeChannel&apos;,&apos;RecognitionTools&apos;,&apos;MobileTopUpModule&apos;,&apos;ReactNative&apos;,&apos;TradeOrderModule&apos;,&apos;JRTemPlateTools&apos;,&apos;FinancingModule&apos;,&apos;JRWebViewTools&apos;,&apos;CrowdfundModule&apos;,&apos;JRBrickTools&apos;,&apos;IousModule&apos;,&apos;JROperateModule&apos;,&apos;JRContainerModule&apos;,&apos;JDWallet&apos;] sdkFileList = [&apos;BankCard&apos;,&apos;LDBraceletSDK&apos;,&apos;TencentMapSDK&apos;,&apos;TencentMapSDK_2D&apos;,&apos;JDTDRisk&apos;,&apos;TSMKit&apos;,&apos;JRDnsAks&apos;,&apos;JRStat&apos;,&apos;JDMA_v13&apos;,&apos;JDPayJR&apos;,&apos;LiveSDK&apos;,&apos;Stock&apos;,&apos;React&apos;,&apos;SingularitySDK&apos;,&apos;UMSocial_Sdk&apos;,&apos;SouFang&apos;,&apos;MTASDK&apos;,&apos;JDKPL&apos;,&apos;FireEye&apos;,&apos;JDJROCRSDK&apos;,&apos;OCR&apos;,&apos;JDCNSDK&apos;,&apos;YITUSDK&apos;,&apos;BUGLY&apos;,&apos;Apple&apos;] podFileList = [] appversion = &apos;&apos; plistPath = os.popen(&apos;find /Users/jdjr/Documents/Build/JRMobileAnalyse -name JDMobile-Info.plist&apos;).read().split(&apos;\n&apos;)[0] if os.path.exists(plistPath): plist = readPlist(plistPath) appversion = plist[&apos;CFBundleShortVersionString&apos;] print appversion time1 = time.time() text1 = open(&apos;/Users/jdjr/Documents/Build/JRMobileAnalyse/Build/Products/JDMobile-LinkMap-normal-arm64.txt&apos;).read() text2 = open(&apos;/Users/jdjr/Documents/Build/JRMobileAnalyse/Build/Products/JDMobile-LinkMap-normal-armv7.txt&apos;).read() projectDic1 = parItemText(text1) projectDic2 = parItemText(text2) totalCount = 0 totalSize = 0 podsize = 0 podscount = 0 dataSoureList = [] dataSdkList = [] for item in projectNameList: obj1 = projectDic1.get(item) obj2 = projectDic2.get(item) if type(obj1) == type(None): print item,0 else: (size1,count1) = obj1 (size2,count2) = obj2 totalCount = totalCount + count2 totalSize = totalSize + size1 + size2 if item in sourceFileList: dataSoureList.append((item,&apos;%.2fM&apos; % ((size1 + size2) / 1024.0 / 1024.0),&apos;%.2fK&apos; % ((size1 + size2) / 1024.0),size1 + size2,count2)) elif item in sdkFileList: dataSdkList.append((item,&apos;%.2fM&apos; % ((size1 + size2) / 1024.0 / 1024.0),&apos;%.2fK&apos; % ((size1 + size2) / 1024.0),size1 + size2,count2)) else: podsize = podsize + size1 + size2 podscount = podscount + count2 podString = &apos;Pods &apos; + &apos;%.2fM&apos; % (podsize / 1024.0 / 1024.0) + &apos;------&gt;&apos; + &apos;%.2fK&apos; % (podsize / 1024.0) + &apos; 文件个数%d&apos; % podscount dataSoureList.append((&apos;Pods&apos;,&apos;%.2fM&apos; % (podsize / 1024.0 / 1024.0),&apos;%.2fK&apos; % (podsize / 1024.0),podsize,podscount)) print &apos;总文件个数%d&apos; % totalCount print &apos;总文件体积%.2fM&apos; % (totalSize / 1024.0 / 1024.0) dataSoureList = sorted(dataSoureList, key=lambda sortItem: sortItem[3],reverse=True) dataSdkList = sorted(dataSdkList, key=lambda sortItem: sortItem[3],reverse=True) lastinfoDict = &#123;&#125; lastinfoDict[&apos;sorcedata&apos;] = dataSoureList lastinfoDict[&apos;sdkdata&apos;] = dataSdkList bds = baseinfo.find(&#123;&apos;appversion&apos;:appversion&#125;) bdscount = 0 for item in bds: bdscount = bdscount + 1 if bdscount &gt; 0 and len(dataSoureList) &gt; 0 and len(dataSdkList) &gt; 0: baseinfo.remove(&#123;&apos;appversion&apos;:appversion&#125;) baseinfo.save(&#123;&apos;appversion&apos;:appversion,&apos;lastinfo&apos;:lastinfoDict&#125;)def buildProject(branchName): os.chdir(&apos;/Users/jdjr/Documents/Build/JRMobileAnalyse&apos;) os.system(&apos;git add .&apos;) os.system(&apos;git checkout -f&apos;) os.system(&apos;git checkout &apos; + branchName) os.system(&apos;git pull origin &apos; + branchName) os.system(&apos;!wq&apos;) os.system(&apos;xcodebuild -workspace JDFinance.xcworkspace -scheme JDMobile -configuration Analyse clean&apos;) os.system(&apos;xcodebuild -workspace JDFinance.xcworkspace -scheme JDMobile -configuration Analyse build&apos;) saveDataToMongo()def findHistoryData(): mc = MongoClient(&quot;localhost&quot;,27017) db = mc.classsize baseinfo = db.baseinfo bds = baseinfo.find(&#123;&#125;).sort([(&apos;appversion&apos;, 1)]) ItemDataList = []#因为我们的bds用一次之后就会释放，所以我们需要把它保存起来 count = 0 lastItem = &apos;&apos; TotalSize = [] for item in bds: count = count + 1 lastItem = item#获得最后一个版本的数据，我们用这个作为标准排序的顺序 sdkList = item[&apos;lastinfo&apos;][&apos;sdkdata&apos;] sorceList = item[&apos;lastinfo&apos;][&apos;sorcedata&apos;] total = 0 for obj in sdkList: total = total + obj[3] for obj in sorceList: total = total + obj[3] TotalSize.append(total) ItemDataList.append(item)#保存bds if count == 0: print &apos;没有数据&apos; sys.exit(1) showdataList = [] titlesdk = [&apos;sdk文件名字*版本&apos;] titlesource = [&apos;源码文件名字*版本&apos;] sourcetitleList = [&apos;JDMobile&apos;,&apos;CommunityTools&apos;,&apos;JRAssemblyUITools&apos;,&apos;JRBankCardModule&apos;,&apos;JRHomeChannel&apos;,&apos;Pods&apos;,&apos;RecognitionTools&apos;,&apos;MobileTopUpModule&apos;,&apos;ReactNative&apos;,&apos;TradeOrderModule&apos;,&apos;JRTemPlateTools&apos;,&apos;FinancingModule&apos;,&apos;JRWebViewTools&apos;,&apos;CrowdfundModule&apos;,&apos;JRBrickTools&apos;,&apos;IousModule&apos;,&apos;JROperateModule&apos;,&apos;JRContainerModule&apos;,&apos;JDWallet&apos;] sdktitleList = [&apos;BankCard&apos;,&apos;LDBraceletSDK&apos;,&apos;TencentMapSDK&apos;,&apos;TencentMapSDK_2D&apos;,&apos;JDTDRisk&apos;,&apos;TSMKit&apos;,&apos;JRDnsAks&apos;,&apos;JRStat&apos;,&apos;JDMA_v13&apos;,&apos;JDPayJR&apos;,&apos;LiveSDK&apos;,&apos;Stock&apos;,&apos;React&apos;,&apos;SingularitySDK&apos;,&apos;UMSocial_Sdk&apos;,&apos;SouFang&apos;,&apos;MTASDK&apos;,&apos;JDKPL&apos;,&apos;FireEye&apos;,&apos;JDJROCRSDK&apos;,&apos;OCR&apos;,&apos;JDCNSDK&apos;,&apos;YITUSDK&apos;,&apos;BUGLY&apos;,&apos;Apple&apos;] # sdktitleList = []#sdk的名字顺序 # sourcetitleList = []#源码文件的名字顺序 sdkitemList = lastItem[&apos;lastinfo&apos;][&apos;sdkdata&apos;] sourceitemList = lastItem[&apos;lastinfo&apos;][&apos;sorcedata&apos;] # for titleItem in sdkitemList: # sdktitleList.append(titleItem[0]) # for titleItem in sourceitemList: # sourcetitleList.append(titleItem[0]) for item in ItemDataList: version = item[&apos;appversion&apos;] titlesdk.append(version) titlesource.append(version) x = PrettyTable(titlesdk) y = PrettyTable(titlesource) for title in sdktitleList: rowList = [title] for item in ItemDataList: sdkDataList = item[&apos;lastinfo&apos;][&apos;sdkdata&apos;] hasAdd = False for data in sdkDataList: if data[0] == title: dataString = data[1].encode(&quot;utf-8&quot;) + &apos; &apos; + data[2].encode(&quot;utf-8&quot;) + &apos; &apos; + &apos;%d&apos; % data[4] rowList.append(dataString) hasAdd = True if hasAdd == False: rowList.append(&apos;Nan&apos;) x.add_row(rowList) for title in sourcetitleList: rowList = [title] for item in ItemDataList: sourceDataList = item[&apos;lastinfo&apos;][&apos;sorcedata&apos;] hasAdd = False for data in sourceDataList: if data[0] == title: dataString = data[1].encode(&quot;utf-8&quot;) + &apos; &apos; + data[2].encode(&quot;utf-8&quot;) + &apos; &apos; + &apos;%d&apos; % data[4] rowList.append(dataString) hasAdd = True if hasAdd == False: rowList.append(&apos;Nan&apos;) y.add_row(rowList) print y print x print array(TotalSize)/1024.0/1024.0,&apos;M&apos;command = sys.argv[1]argv1 = &apos;&apos;argv2 = &apos;&apos;argv3 = &apos;&apos;argv4 = &apos;&apos;if (len(sys.argv) &gt;= 3): argv1 = sys.argv[2]if (len(sys.argv) &gt;= 4): argv2 = sys.argv[3]if command == &apos;--h&apos;: print &apos;jdjr analyse branchname 分析某个分支&apos; print &apos;jdjr history 查看历史数据&apos;elif command == &apos;analyse&apos;: if len(argv1) == 0: print &apos;请输入分支名称&apos; else: buildProject(argv1) findHistoryData()elif command == &apos;history&apos;: findHistoryData()elif command == &apos;analyseCommon&apos;: saveDataToMongo()else: print &apos;jdjr analyse branchname 分析某个分支&apos; print &apos;jdjr history 查看历史数据&apos;# buildProject()# saveDataToMongo()]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端图片隐写术的实现思路]]></title>
    <url>%2F2018%2F04%2F17%2F2015%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[JPEG压缩算法理解参考 https://thecodeway.com/blog/?p=69 首先这是一种有损的信息压缩方式，压缩的核心原理是，将信息分为重要和不重要，然后舍弃掉不重要的信息，我们将会通过两部信息区分来完成这个任务，第一个是RGB转YCbCr，第二个是DCT转化和量化，这两步每一步都是有信息损耗，都是不可逆的，而哈夫曼编码和压缩是可逆的，要深刻的理解这些个点。 图片会以不同的数据格式存在于不同的时刻，在屏幕中显示的时候肯定是RGB格式，在存储的时候却不是，是经过编码和压缩之后的数据 第一步，每一个点都是由RBG三个值组成，在移动端是四个值RGBA，每个值又由8位来存储，所以每个颜色内存中需要32位来存储，我们在压缩处理图片的时候并不是一个点一个点的处理，这样效率很低，我们是64个点作为一个单元去处理，8x8的矩阵 颜色空间转换RGB-&gt;YCbCr 看一下RGB和YCbCr相互转化的c++代码 1234567891011121314151617181920212223242526272829303132float computeY(float red,float green,float blue) &#123; float Y = 0.299 * red + 0.587 * green + 0.114 * blue; return float(roundfunc(Y));&#125;float computeCr(float red,float green,float blue) &#123; float Cr = 0.500 * red - 0.419 * green - 0.081 * blue; Cr = Cr + 128.0; return float(roundfunc(Cr));&#125;float computeCb(float red,float green,float blue) &#123; float Cb = 0.500 * blue - 0.169 * red - 0.331 * green; Cb = Cb + 128.0; return float(roundfunc(Cb));&#125;int16_t computeR(float Y,float Cb,float Cr) &#123; float R = 1.000 * Y + 0.000 * (Cb - 128) + 1.400 * (Cr - 128); R = int16_t(roundfunc(R)); return int16_t(roundfunc(R));&#125;int16_t computeG(float Y,float Cb,float Cr) &#123; float G = 1.000 * Y - 0.343 * (Cb - 128) - 0.711 * (Cr - 128); return int16_t(roundfunc(G));&#125;int16_t computeB(float Y,float Cb,float Cr) &#123; float B = 1.000 * Y + 1.765 * (Cb - 128) + 0.000 * (Cr - 128); return int16_t(roundfunc(B));&#125; python代码 12BGR转化imgYCC = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB) DCT变换，这里转化的YCbCr数据，但是肯定是选择一个通道，不可能全都转换一遍，不过都转化也没啥问题，这样我们信息容量会更大 DCT量化，量化的理解是最大限度的去处不重要的信息，所以这个量化表本质是可选的，但是推荐官方的标准量化表 哈弗曼编码和压缩 JPEG载入信息方法理解方法有两种，第一种是直接在RGB信息中存入信息，第二种是在DCT信息中加入信息，下边来分别分析。 在RGB中直接隐藏信息这种做法是基于LBS，更改信息的最低有效位，首先不会更改人眼可分别的图片认知，因为颜色改变极小，但是如果是jpeg文件，存储再读取你写入的信息就会错乱，就是因为这是一种有损压缩，你把Red值改成了220，等你存储损失之后，再读取可能就变成了119，总之就是这个值不靠谱。 基于DCT的隐藏DCT的信息是比较稳定的，但是仍然会有变化的情况，这是因为图像存在极值，比如一个255的色值，你藏信息的时候增加了这个值，但是返回回来之后计算的值是256，但是这个值是无效的，那么你怎么处理就很重要了，你如果直接将其约为255，那么你的数据将会错乱，如果你不采取这样的点，那么盲提取你仍然会错乱，因为如果你的判断标准是，这个值不能是255，你写的时候不是，更改之后读的时候可能就是了，这也是一种不稳定的处理方法。 解决办法就是将隐藏信息的处理扩张改为收缩，这样即使遇到极值情况，仍然不会被裁减，就这样轻松绕过这个问题，同时配合四舍五入的规则替换为退一的方法，这样我们能够保证所有的数据是缩减的，这样肯定不会触碰那个临界了，这样的话我们如果不考虑反检测的问题，我们可以大方的将信息写在DC数据上。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Seaborn数据展示入门]]></title>
    <url>%2F2018%2F03%2F21%2F2018%2FSeaborn%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[都有什么类型的图 都能做哪几种分析 Seaborn有五个预设好的主题：darkgrid, whitegrid, dark, white,和ticks distplot() kdeplot()distplot()为hist加强版，kdeplot()为密度曲线图 箱型图 boxplot()联合分布jointplot()热点图heatmap()Histograms直方图Kernel density estimaton核密度估计]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的正则表达式使用]]></title>
    <url>%2F2018%2F03%2F20%2F2018%2Fpython%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以： ‘00\d’可以匹配’007’，但无法匹配’00A’； ‘\d\d\d’可以匹配’010’； ‘\w\w\d’可以匹配’py3’； .可以匹配任意字符，所以：’py.’可以匹配’pyc’、’pyo’、’py!’等等。 要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符： 123456789101112131415来看一个复杂的例子：\d&#123;3&#125;\s+\d&#123;3,8&#125;。我们来从左到右解读一下：\d&#123;3&#125;表示匹配3个数字，例如&apos;010&apos;；\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配&apos; &apos;，&apos; &apos;等；\d&#123;3,8&#125;表示3-8个数字，例如&apos;1234567&apos;。综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。如果要匹配&apos;010-12345&apos;这样的号码呢？由于&apos;-&apos;是特殊字符，在正则表达式中，要用&apos;\&apos;转义，所以，上面的正则是\d&#123;3&#125;\-\d&#123;3,8&#125;。但是，仍然无法匹配&apos;010 - 12345&apos;，因为带有空格。所以我们需要更复杂的匹配方式。 进阶要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’Py3000’等等； [a-zA-Z_][0-9a-zA-Z_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量； [a-zA-Z_][0-9a-zA-Z_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(P|p)ython可以匹配’Python’或者’python’。 ^表示行的开头，^\d表示必须以数字开头。 $表示行的结束，\d$表示必须以数字结束。 你可能注意到了，py也可以匹配’python’，但是加上^py$就变成了整行匹配，就只能匹配’py’了。 python中的正则123456789101112131415import redef handlere(rematchs, inputString): for match in rematchs: matchout = match.findall(inputString) for item in matchout: if type(item) == type((1, 2, 3)): inputString = inputString.replace(item[0], &apos;&apos;) else: inputString = inputString.replace(item, &apos;&apos;) return inputString matchs = [re.compile(u&apos;周[一二三四五六日]&apos;),re.compile(r&apos;(\d&#123;1,2&#125;\:\d&#123;1,2&#125;)&apos;), re.compile(r&apos;(\d&#123;4&#125;(\.|\-|\/)\d&#123;1,2&#125;(\.|\-|\/)\d&#123;1,2&#125;)&apos;)] comment = handlere(matchs, comment)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[skleanrn文本分类代码记录]]></title>
    <url>%2F2018%2F03%2F19%2F2018%2Fskleanrn%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[文本分类模型以及使用代码记录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500import os,re import sys,jiebaimport codecs,timeimport shutilimport numpy as npimport pandas as pdimport matplotlibimport scipy,json,pinyinfrom sklearn.externals import joblibfrom sklearn.svm import SVCimport matplotlib.pyplot as pltfrom sklearn.naive_bayes import MultinomialNB from sklearn.naive_bayes import GaussianNBfrom sklearn.linear_model import Perceptronfrom sklearn.model_selection import train_test_splitfrom sklearn import feature_extraction from sklearn.feature_extraction.text import TfidfTransformer from sklearn.feature_extraction.text import CountVectorizerfrom sklearn.feature_extraction.text import HashingVectorizer from pandas import DataFrame import enchantcheckeng = enchant.Dict(&quot;en_US&quot;) reload(sys) # Python2.5 初始化后会删除 sys.setdefaultencoding 这个方法，我们需要重新载入 sys.setdefaultencoding(&apos;utf-8&apos;) jieba.load_userdict(&apos;customdict.txt&apos;)stopwords = open(&apos;stopwords.txt&apos;,&apos;r&apos;).read().split(&apos;\n&apos;)stopwordsadv = open(&apos;stopwordsadv.txt&apos;,&apos;r&apos;).read().split(&apos;\n&apos;)stopwords = open(&apos;teststopwords.txt&apos;,&apos;r&apos;).read().split(&apos;\n&apos;) + stopwords + stopwordsadvdef handleadvkeywords(inputString): if hasNumbers(inputString) == False: return inputString pinyinlist = [] for char in inputString: pin = pinyin.get(char, format=&apos;strip&apos;, delimiter=&quot;&quot;) pinyinlist.append(pin) setp = 2 indexwei = 100 indexxin = 200 indexjia = 300 indexhao = 400 indexxing = 500 indexkou = 600 if &apos;wei&apos; in pinyinlist: indexwei = pinyinlist.index(&apos;wei&apos;) if &apos;v&apos; in pinyinlist: indexwei = pinyinlist.index(&apos;v&apos;) if &apos;xin&apos; in pinyinlist: indexxin = pinyinlist.index(&apos;xin&apos;) if &apos;xing&apos; in pinyinlist: indexxin = pinyinlist.index(&apos;xing&apos;) if &apos;hao&apos; in pinyinlist: indexhao = pinyinlist.index(&apos;hao&apos;) if &apos;jia&apos; in pinyinlist: indexjia = pinyinlist.index(&apos;jia&apos;) if &apos;zhao&apos; in pinyinlist: indexjia = pinyinlist.index(&apos;zhao&apos;) if abs(indexxin - indexwei) &lt; setp: inputString = u&apos;微信&apos; + inputString if abs(indexhao - indexwei) &lt; setp: inputString = u&apos;微号&apos; + inputString if abs(indexwei - indexjia) &lt; setp: inputString = u&apos;加微&apos; + inputString # if indexwei - indexjia &lt;= 2:# inputString = &apos;加微&apos; + inputString if abs(indexxing - indexwei) &lt; setp: inputString = u&apos;微信&apos; + inputString if pinyinlist.count(&apos;kou&apos;) &gt;= 2: inputString = &apos;qq&apos; + inputString if abs(indexkou - indexjia) &lt; setp: inputString = u&apos;qq&apos; + inputString if &apos;加微微&apos; in inputString: inputString = inputString.replace(&apos;加微微&apos;,&apos;加微&apos;) return inputString def getwordcount(inputString): df = pd.read_excel(&apos;lowfrequency.xls&apos;) negkeydicstring = open(&apos;negkeydic.json&apos;,&apos;r&apos;).read() negkeydic = json.loads(negkeydicstring) count = 0 countdic = negkeydic.get(inputString) if type(countdic) != type(None): count = countdic[1] print df[df[&apos;name&apos;] == inputString],countdef cos_sim(vector_a, vector_b): &quot;&quot;&quot; 计算两个向量之间的余弦相似度 :param vector_a: 向量 a :param vector_b: 向量 b :return: sim &quot;&quot;&quot; vector_a = np.mat(vector_a) vector_b = np.mat(vector_b) num = float(vector_a * vector_b.T) denom = np.linalg.norm(vector_a) * np.linalg.norm(vector_b) cos = num / denom sim = 0.5 + 0.5 * cos return simdef hasNumbers(inputString): return any(char.isdigit() for char in inputString) def replacenum(inputString): replaceDic = &#123;&apos;yi&apos;:&apos;1&apos;,&apos;yao&apos;:&apos;1&apos;,&apos;er&apos;:&apos;2&apos;,&apos;san&apos;:&apos;3&apos;,&apos;si&apos;:&apos;4&apos;,&apos;wu&apos;:&apos;5&apos;,&apos;liu&apos;:&apos;6&apos;,&apos;qi&apos;:&apos;7&apos;,&apos;ba&apos;:&apos;8&apos;,&apos;jiu&apos;:&apos;9&apos;,&apos;ling&apos;:&apos;0&apos;&#125;# .replace(u&apos;腰&apos;,&apos;1&apos;).replace(u&apos;一&apos;,&apos;1&apos;).replace(u&apos;二&apos;,&apos;2&apos;).replace(u&apos;三&apos;,&apos;3&apos;).replace(u&apos;斯&apos;,&apos;4&apos;).replace(u&apos;四&apos;,&apos;4&apos;).replace(u&apos;五&apos;,&apos;5&apos;).replace(u&apos;六&apos;,&apos;6&apos;).replace(u&apos;齐&apos;,&apos;7&apos;).replace(u&apos;七&apos;,&apos;7&apos;).replace(u&apos;扒&apos;,&apos;8&apos;).replace(u&apos;八&apos;,&apos;8&apos;).replace(u&apos;九&apos;,&apos;9&apos;).replace(u&apos;零&apos;,&apos;0&apos;) returnString = &apos;&apos; if len(inputString) &lt;= 2: for item in inputString: pin = pinyin.get(item, format=&apos;strip&apos;, delimiter=&quot;&quot;) output = replaceDic.get(pin) if type(output) == type(&apos;1&apos;): returnString = returnString + output if returnString == &apos;&apos; or len(returnString) &lt; len(inputString): returnString = inputString return returnString def handlenum(inputString): if inputString.count(&apos;0&apos;) &gt;= 2: inputString = inputString.replace(&apos;0&apos;,&apos;&apos;) if hasNumbers(inputString): s = re.findall(&quot;\d+&quot;,inputString) for item in s: if len(item) == 11: inputString = inputString.replace(item,&apos;䞄&apos;) #电话 else: if len(inputString.replace(&apos;0&apos;,&apos;&apos;).replace(&apos;g&apos;,&apos;&apos;)) &gt;= 5 and inputString[-1] != &apos;0&apos;: if &apos;988511&apos; in inputString: inputString = &apos;京东&apos; else: if len(item) &gt;= 2: inputString = inputString.replace(item,&apos;藨&apos;) #qq微信之类的 else: inputString = inputString.replace(item,&apos;&apos;) outList = jieba.lcut(inputString) if &apos;&apos; in outList: outList.remove(&apos;&apos;) if &apos; &apos; in outList: outList.remove(&apos; &apos;) outListNew = [] for item in outList: if (&apos;䞄&apos; in item) or (&apos;藨&apos; in item) or (&apos;京东&apos; in item): outListNew.append(item) else: if hasNumbers(item) == False: if checkeng.check(item): outListNew.append(&apos;isenglish&apos;) else: outListNew.append(item) return outListNew if inputString.isalpha() == True and len(inputString) &gt; 5:#如果是纯英文，并且英文长度大于5 if &apos;jd&apos; in inputString: inputString = &apos;京东&apos; else: if checkeng.check(inputString): inputString = &apos;isallenglish&apos; return [inputString]def translate(comment): testline = re.sub(u&quot;[\s+\.\!\/_,$%^*(+\&quot;\&apos;]+|[+——！，！。？、~@#￥%……&amp;*（）]+&quot;, &apos;&apos;, comment) testline = testline.replace(u&apos;[&apos;,&apos;&apos;).replace(u&apos;丨&apos;,&apos;&apos;).replace(chr(32),&apos;&apos;).replace(u&apos;！&apos;, u&apos;&apos;).replace(u&apos;，&apos;, u&apos;&apos;).replace(u&apos;。&apos;, u&apos;&apos;).replace(u&apos;\n&apos;, u&apos;&apos;).replace(u&apos;\t&apos;, u&apos;&apos;).replace( u&apos;?&apos;, u&apos;&apos;).replace(u&apos;【&apos;,&apos;&apos;).replace(u&apos;o&apos;,&apos;&apos;).replace(u&apos;O&apos;,&apos;&apos;).replace(u&apos;丶&apos;,&apos;&apos;).replace(u&apos;‘&apos;,&apos;&apos;).replace(&apos;:&apos;,&apos;&apos;).replace(u&apos;：&apos;,&apos;&apos;).replace(&apos;(&apos;,&apos;&apos;).replace(&apos;)&apos;,&apos;&apos;).replace(&apos;&#123;&apos;,&apos;&apos;).replace(&apos;&#125;&apos;,&apos;&apos;).replace(u&apos;？&apos;, u&apos;&apos;).replace(u&apos;-&apos;,&apos;&apos;) if &apos;危险性&apos; in testline: testline = testline.replace(&apos;危险性&apos;,&apos;&apos;) if &apos;2018&apos; in testline: testline = testline.replace(&apos;2018&apos;,&apos;&apos;) if &apos;行为&apos; in testline: testline = testline.replace(&apos;行为&apos;,&apos;&apos;) if &apos;vivox&apos; in testline: testline = testline.replace(&apos;vivox&apos;,&apos;&apos;) if &apos;越来越扣&apos; in testline: testline = testline.replace(&apos;越来越扣&apos;,&apos;&apos;) if &apos;weixin&apos; in testline: testline = testline.replace(&apos;weixin&apos;, &apos;微信&apos;) if &apos;vxin&apos; in testline: testline = testline.replace(&apos;vxin&apos;,&apos;微信&apos;) if &apos;wxin&apos; in testline: testline = testline.replace(&apos;wxin&apos;,&apos;微信&apos;) testline = testline.lower() return testline def changeToWords(sentence): global stopwords out = translate(sentence) out = handleadvkeywords(out) jiebalistnew = [] jiebalist = jieba.lcut(out) forcut = &apos;&apos; for item in jiebalist: item = replacenum(item) forcut = forcut + item jiebalist = jieba.lcut(forcut) for item in jiebalist: if item not in stopwords: jiebalistnew = jiebalistnew + handlenum(item) if &apos;&apos; in jiebalistnew: jiebalistnew.remove(&apos;&apos;) if &apos; &apos; in jiebalistnew: jiebalistnew.remove(&apos; &apos;) string = &apos; &apos;.join(jiebalistnew) print string return stringdef getkeywords(corpus): #应该是计算每个词个数除以我这个阵营的词总数，倒数，这样来衡量占的比重，如果两者比重接近，那么无意义 corpus = map(changeToWords,corpus) vectorizer = CountVectorizer(token_pattern=u&apos;(?u)\w+&apos;) X = vectorizer.fit_transform(corpus) names = vectorizer.get_feature_names() count = X.toarray().sum(axis=0) dictn = &#123;&#125; values = vectorizer.vocabulary_.values() sum = np.array(values).sum() for i in range(len(names)): key = names[i] value = sum * 1.0 / count[i] valuenew = count[i] dictn[key] = (value,valuenew) return dictndef getcompare(cols1,cols2):#比较两边的占比情况 coldic1 = getkeywords(cols1) coldic2 = getkeywords(cols2) negkeydicstring = json.dumps(coldic1) f = open(&apos;negkeydic.json&apos;,&apos;w&apos;) f.write(negkeydicstring) f.close() listn = sorted(coldic1.items(), key=lambda d: d[1][0], reverse=True) returnList = [] for item in listn: name = item[0] count = coldic1.get(name)[0] if name in coldic2.keys(): count1 = coldic2.get(name)[0] ratio = count * 1.0 / count1 if ratio &gt; 0.7 and ratio &lt; 1.5: returnList.append(name) countppos = coldic2.get(name)[1] countpneg = coldic1.get(name)[1] if countppos * 1.0 / countpneg &gt; 3: returnList.append(name) return returnList def trainmodel(): ######################################################################### # 第一步 计算TFIDF #文档预料 空格连接 corpus = [] global stopwords #读取预料 一行预料为一个文档 neg = pd.read_excel(&apos;adver.xls&apos;) negcontents = neg[&apos;content&apos;].dropna() negcorpus = list(negcontents) negcorpus = map(changeToWords,negcorpus) #读取预料 一行预料为一个文档 pos = pd.read_excel(&apos;notadver.xls&apos;) poscontents = pos[&apos;content&apos;].dropna() poscorpus = list(poscontents) poscorpus = map(changeToWords,poscorpus) stopwords = getcompare(negcorpus,poscorpus) + stopwords #停止词，两边比重差不多或者正常的多的词 tostop = CountVectorizer(stop_words=stopwords,token_pattern=u&apos;(?u)\w+&apos;) #第一个fit_transform是计算tf-idf 第二个fit_transform是将文本转为词频矩阵 tostopcount = tostop.fit_transform(poscorpus+negcorpus) words = tostop.get_feature_names() sumlist = list(tostopcount.toarray().sum(axis=0)) a1 = np.array([words,sumlist]) a1 = np.transpose(a1) dfnew = DataFrame(a1,columns=[&apos;name&apos;,&apos;count&apos;]) dfnew[&apos;count&apos;] = dfnew[&apos;count&apos;].astype(int) dfnew.to_excel(&apos;lowfrequency.xls&apos;) tostopwords = list(dfnew[dfnew[&apos;count&apos;] &lt; 7][&apos;name&apos;]) #去除频次小于7的词组 stopwords = stopwords + tostopwords if os.path.exists(&apos;teststopwords.txt&apos;): os.popen(&apos;rm -rf teststopwords.txt&apos;) f = open(&apos;teststopwords.txt&apos;,&apos;w&apos;) for item in stopwords: if item.isalpha() == False: f.write(item + &apos;\n&apos;) f.close() # #该类会统计每个词语的tf-idf权值 transformer = TfidfTransformer() vectorizer = CountVectorizer(token_pattern=u&apos;(?u)\w+&apos;) count0 = vectorizer.fit_transform(poscorpus+negcorpus) tfidf = transformer.fit_transform(count0) #将tf-idf矩阵抽取出来，元素w[i][j]表示j词在i类文本中的tf-idf权重 weight = tfidf.toarray() x = weight y = np.concatenate((np.zeros(len(poscorpus)), np.ones(len(negcorpus)))) list0 = list(poscontents) + list(negcontents) list1 = list(poscorpus+negcorpus) list2 = list(weight) list3 = [] for item in list2: item = list(item) list3.append(&apos;/&apos;.join(&apos;%s&apos; % id for id in item)) a2 = np.array([list0,list1,list3,y]) a2 = np.transpose(a2) dftosave = DataFrame(a2,columns=[&apos;content&apos;,&apos;name&apos;,&apos;weight&apos;,&apos;isadver&apos;]) dftosave.to_csv(&apos;vecdict.csv&apos;) x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.01) # 构建支持向量机分类模型# model = SVC(kernel=&apos;rbf&apos;, verbose=True) # model = GaussianNB() modelnew = MultinomialNB()# model = Perceptron() # model.fit(x_train, y_train) modelnew.fit(x_train, y_train) # score = model.score(x_test, y_test) scorenew = modelnew.score(x_test, y_test)# print score print scorenew print &apos;donetest&apos; joblib.dump(modelnew, &apos;bayes.pkl&apos;) joblib.dump(transformer, &apos;transformer&apos;) joblib.dump(vectorizer, &apos;vectorizer&apos;) def testmodel(testString): isadver = False testList = [testString] negtestcorpus = map(changeToWords,testList) foruse = negtestcorpus[0].split(&apos; &apos;) nums = re.findall(r&apos;\d+&apos;, testString) numstring = &apos;&apos;.join(nums) count = len(numstring) forteststring = translate(testString) + &apos;&apos;.join(negtestcorpus) abList = [u&apos;微号&apos;,u&apos;QQ&apos;,u&apos;qq&apos;,u&apos;微我&apos;,u&apos;微信&apos;,u&apos;加微&apos;,u&apos;卫星&apos;,u&apos;*信&apos;,u&apos;维新&apos;,u&apos;企鹅&apos;,u&apos;加扣&apos;] if count &gt;= 2: for item in abList: if item in forteststring: isadver = True if (&apos;http&apos; in testString and &apos;jd&apos; not in testString) or (&apos;www&apos; in testString and &apos;jd&apos; not in testString) or ((&apos;com&apos; in testString and &apos;jd&apos; not in testString)): isadver = True if isadver == True: return isadver model = joblib.load(&apos;bayes.pkl&apos;) vectorizer = joblib.load(&apos;vectorizer&apos;) transformer = joblib.load(&apos;transformer&apos;) counts_train = vectorizer.transform(negtestcorpus) testtfidf = transformer.transform(counts_train) result = model.predict(testtfidf.toarray()) if result[0] == 0.0: isadver = False if result[0] == 1.0: isadver = True return isadverdef tagalldata(): negtest = pd.read_excel(&apos;notadver.xls&apos;) print negtest.info() negtest = negtest.dropna() negtestcontents = negtest[&apos;content&apos;] df1 = map(testmodel,negtestcontents) negtest[&apos;isadnew&apos;] = df1 f = open(&apos;outputpos.txt&apos;,&apos;w&apos;) for item in negtest[negtest[&apos;isadnew&apos;] == True][&apos;content&apos;]: f.write(item + &apos;\n&apos;) f.close() print &apos;done&apos;def getsimiliar(testString): vecdic = pd.read_csv(&apos;vecdict.csv&apos;) namelist = list(vecdic[&apos;name&apos;]) weightlist = list(vecdic[&apos;weight&apos;]) contentlist = list(vecdic[&apos;content&apos;]) adverlist = list(vecdic[&apos;isadver&apos;]) weightlistnew = [] for item in weightlist: itemlist = item.split(&apos;/&apos;) outlist = [] for i in itemlist: outlist.append(float(i)) weightlistnew.append(outlist) testList = [testString] negtestcorpus = map(changeToWords,testList) model = joblib.load(&apos;bayes.pkl&apos;) transformer = joblib.load(&apos;transformer&apos;) vectorizer = joblib.load(&apos;vectorizer&apos;) names = vectorizer.get_feature_names() counts_train = vectorizer.transform(negtestcorpus) testtfidf = transformer.transform(counts_train) sentence = testtfidf.toarray()[0] for item in weightlist: itemlist = item.split(&apos;/&apos;) outlist = [] for i in itemlist: outlist.append(float(i)) similar = cos_sim(sentence,outlist) if similar &gt; 0.65: print contentlist[weightlist.index(item)],&apos;+++++++&apos;,namelist[weightlist.index(item)],&apos;------&apos;,adverlist[weightlist.index(item)] def testsentence(inputString): global contentlist time1 = time.time() print testmodel(inputString) print time.time() - time1 getsimiliar(inputString) print time.time() - time1 # print testmodel(u&apos;京东，白，条好啊，白，条，可，以，唤，线，金。秒，到手。 有无，闪，付都一样，秒，到。还可以任，性，福，花，把。任，性，带。卫，星（q29206）&apos;)# tagalldata()print &apos;******&apos;time1 = time.time()# trainmodel()# tagalldata()testsentence(u&apos;我不相信weixinasdfasdf&apos;)# print getwordcount(u&apos;开户&apos;)# changeToWords(u&apos;想获得白条联系我qw6727444&apos;)print time.time() - time1]]></content>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题总结]]></title>
    <url>%2F2018%2F03%2F17%2F2015%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[转点面试题 中小型公司谈下iOS开发中知道的哪些锁? 哪个性能最差?SD和AFN使用的哪个? 一般开发中你最常用哪个? 哪个锁apple存在问题又是什么问题? iOS下如何实现指定线程数目的线程池? 如何用HTTP实现长连接？ http的post和get啥区别 使用atomic一定是线程安全的吗？ 数据库建表的时候索引有什么用？ 介绍下iOS设备获取唯一设备号的历史变迁 如何使用runtime hook一个class的某个方法，又如何hook某个instance的方法？ 聊下HTTP的POST的body体使用form-urlencoded和multipart/form-data的区别。 通过[UIImage imageNamed:]生成的对象什么时候被释放？ applicationWillEnterForeground和applicationDidBecomeActive都会在哪些场景下被调用？举例越多越好。 如何终止正在运行的工作线程？ iOS下所有的本地持久化方案。 weak修饰的释放则自动被置为nil的实现原理 HTTPS的加密原理 网络通讯中加密方式有哪些，各自的原理? 谈下开发中iOS缓存的理解 你认为开发中那些导致crash? 分析下SDWebImage (q3:内部做Decoder的原因 (典型的空间换时间)) crash的收集和定位bug的方式谈下 SEL和Method和IMP分别说下再谈下对IMP的理解? Autorelease的原理 ? ARC的工作原理 weak弱引用的代码逻辑实现? 大文件离线下载怎么处理?会遇到哪些问题?又如何解决 Socket建立网络连接的步骤 用户需要上传和下载一个重要的资料文件，应该如何判断用户本次是否上传成功和下载成功了? ReactiveCocoa(RAC)如何防止UIButton短时间内多次重复点击，大概思路? 倒计时如何实现 ？ 熟悉 CocoaPods 么？能大概讲一下工作原理么？ 使用SDWebImage内存爆涨的问题遇到没,怎么解决 isa指针的作用 测试都有哪些方式?优缺点呢 项目中你是怎么处理网络速度慢、中断抖动等网络请求中的问题? 对数组中的元素去重复 (四种) 请简单写出增、删、改、查的SQL语句 与 NSURLConnection 相比，NSURLsession 改进哪些? 使用drawRect有什么影响？ 什么时候会报unrecognized selector的异常？如何避免? 界面多个网络请求,如何处理刷新的? 如果tableView界面网络请求有缓存数据逻辑? init方法私有化? 线程中栈与堆是公有的还是私有的 ? 项目中的图片上传功能如何实现，为什么使用队列上传，为什么不用异步上传? 去哪儿网一面自我介绍 atomic 和 nonatomic 的区别 手写@property (nonatomic, strong, readonly) NSString *context 的get 方法。前提是线程安全，lazy load的方式 @property (atomic, strong) NSString *str; 如果重写了str的set方法，那atomic还有效吗？ 写一个method 能满足输入[6, 5, 4, 3, 2, 1]数组 输出 [1, 2, 3, 4, 5, 6]数组 http socket的区别，http是在网络里面的那一层。这里考的是网络传输的那7层。如何知道消息体的数据已经发送完成了。tcp udp的理解。 一个新的app的设计思路，主要看架构方面的想法 多个登录方式，比如qq， 微信，微博，手机号，邮箱等的登录，如果真对变化进行封装。这里考虑的更多的是设计模式上的问题。 事件响应链（比如点击事件） GCD中group的优点，及串行，并行队列 framework时动态链接库还是静态链接库，和.a的区别是什么 将对象加入字典，array时的引用计数是多少 weak的实现原理 strong的实现原理 关于引用计数的知识点 手写一个set方法 block中的弱引用强引用，什么情况会导致循环引用，什么时候需要__strong保持强引用 app的性能优化，都有哪些 对于image加载的优化方案有哪些 Runloop, runtime的理解 阿里一面第一组(p5)Android的activity Category支持添加属性与成员变量吗 是否了解设计模式, 用过哪些 iOS7之后, 蓝牙的围栏功能 MVC是否了解?介绍下使用情况。 MVC里面, View怎么通知到Model 了解delegate吗?并介绍 说说Cell重用原理 异步下载如何实现 做过最大的项目是什么?主要难点在哪里 如果现在要实现一个下载功能, 你要如何设计。说说每个类具体做什么 学过哪些语言 C++里面虚函数作用 对o2o有什么看法(他是o2o部门的) 有没有什么想问的 第二组(p5)MVC具有什么样的优势，各个模块之间怎么通信，比如点击 Button 后 怎么通知 Model？ 两个无限长度链表（也就是可能有环） 判断有没有交点 UITableView的相关优化 KVO、Notification、delegate各自的优缺点，效率还有使用场景 如何手动通知KVO Objective-C 中的copy方法 runtime 中，SEL和IMP的区别 autoreleasepool的使用场景和原理 RunLoop的实现原理和数据结构，什么时候会用到 block为什么会有循环引用 使用GCD如何实现这个需求：A、B、C 三个任务并发，完成后执行任务 D。 NSOperation和GCD的区别 CoreData的使用，如何处理多线程问题 如何设计图片缓存？ 有没有自己设计过网络控件？ 第三组(p6)介绍下内存的几大区域？ 你是如何组件化解耦的？ runtime如何通过selector找到对应的IMP地址 runloop内部实现逻辑？ 你理解的多线程？ GCD执行原理？ 怎么防止别人反编译你的app？ YYAsyncLayer如何异步绘制？ 优化你是从哪几方面着手？ 阿里二面第一组(p5)什么时候接触iOS 你的这些项目是外包还是自己开发的 OC允许多继承吗 要用什么方式实现多继承 了解内存管理吗, 吧唧吧唧… 了解设计模式吗 具体说说MVC 了解KVO吗 如果让你设计KVO, 要怎么设计 现在你是如何适配的 比较下storyboard和全代码 印象比较深的项目, 难点在哪 Cell重用机制具体怎么实现 如果有1w张图片要在屏幕滚动显示(每张图片满屏), 至少要几个cell, 如何实现循环滚动 平时是怎么进行测试的, 内存方面怎么测试 平时如何实现网络请求, 一般返回的数据是什么格式, 如何解析.. 平时自己有没有封装过比较复杂的控件 在什么情况使用Notification 如何实现类似 “Find My iPhone” 这样功能 第二组(p5)怎么判断某个 cell 是否显示在屏幕上 进程和线程的区别 TCP 与 UDP 区别 TCP 流量控制 数组和链表的区别 UIView 生命周期 如果页面 A 跳转到 页面 B，A 的 viewDidDisappear 方法和 B 的 viewDidAppear 方法哪个先调用？ block 循环引用问题 ARC 的本质 RunLoop 的基本概念，它是怎么休眠的？ Autoreleasepool 什么时候释放，在什么场景下使用？ 如何找到字符串中第一个不重复的字符 哈希表如何处理冲突 第三组(p6)在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么 代码文件编译生成过程，做了哪些事情； app启动做了哪些事情； AFN原理 说说你项目中常用到的调试技巧？ 阿里三面第一组(p5)dSYM你是如何分析的？ 多线程有哪几种？你更倾向于哪一种？ 单例弊端？ 如何把异步线程转换成同步任务进行单元测试？ 介绍下App启动的完成过程？ 比如App启动过慢，你可能想到的因素有哪些？ 0x8badf00d表示是什么？ 怎么防止反编译？ 说说你遇到到的技术难点？ 说说你了解的第三方原理或底层知识？ 蚂蚁金服在KVO中，他是怎么知道监听的对象发生了变化？ 字典的工作原理 ？怎100w个中是怎么快速去取value？ 一个上线的项目，知道这个方法可能会出问题，在不破坏改方法前提下，怎么搞？ Block和函数指针的区别？ 支付宝iOS多线程有哪些？他们之间各有什么区别，优劣性？ UIView和NSObject这两个类，所有里面的方法和原理都需要了解一下。 Runloop和线程的关系？ Runloop的作用？RunloopMode的原理？ 饿了么面试题automic一定是线程安全的吗 iOS中的消息传递是怎么一步一步实现的 category和extension有什么区别 iOS中的私有属性如何设置 串行队列和同步锁两者在保护线程安全上的性能对比 并行队列是同时执行的吗 iOS中有哪些锁，你了解多少 iOS中UIKit框架的架构 UIView和CALayer之间的关系 UIView、CoreAnimation和CoreGraphics的关系 应该知道SegmentFault，这个在iOS中是什么错误，那StackOverFlow呢 GCD、NSThread、NSOperation性能上有何区别 网易一面第一组自我介绍 学习iOS动机 对iOS的看法 谈项目 怎么看待审核被拒 怎么完成后期检测, 优化 id ,NSObject, id区别 了解iOS内存管理吗 release 和 autorelease 区别 autorelease 和 @autorelease区别 weak什么时候用 unsafe_unretained , weak, assign 区别 __block什么时候用 在block里面, 对数组执行添加操作, 这个数组需要声明成 __block吗 在block里面, 对NSInteger进行修改, 这个NSInteger是否需要声明成__blcok 了解循环引用吗 NSThread, NSOperation, GCD区别 如何在异步下载时候, 取消下载, 保证流量不浪费 了解runtime吗 runtime什么时候用 通知和KVO区别 有序和无序set实现原理区别 深度遍历和广度遍历使用场景 算法题 * 2 常用的设计模式 哪些设计模式属于观察者模式 总结下刚才面试中哪些不足 自己有什么优点 有什么想问的 第二组你一般学习iOS是如何学习的？ app内存你是如何分析的？ 用过 TableView 吗，平时怎么解决 TableView 滑动卡顿问题的？ 网络模型了解么？有哪几种？说说你的看法？ block本质是什么？ KVC机制是如何通过key找到value。 说说你最熟悉的第三方，知晓其原理么？ 网易二面第一组如何实现一个数组每个元素依次向右移动k位。(后头的往前面补) 比如: [1, 2, 3, 4, 5] 挪两位变成[4, 5, 1, 2, 3] 实现连连看算法 T9算法如何实现, 全拼算法]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sklearn中文文本分类实战]]></title>
    <url>%2F2018%2F03%2F12%2F2018%2Fsklearn%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[训练步骤 数据集合 文本分词 去除停用词，低频词 抽取特征 计算特征向量权值 训练分类器 使用模型步骤 文本分词 去除停用词，低频词 计算特征向量权值 使用模型进行分类 去除停用词和低频词因为在自然语言中每个词代表一个特征，所以自然语言注定了是一种超高纬特征的机器学习问题，但是在分类问题中很多词是不具备分类能力的，比如，啊，我等等，这些是要去除的停用词，这些词语在不同场景下可以是通用的。另外就是要去除低频词，如果某些词在在整个训练数据集中只出现了一两次，那么这样的特征将会导致表示向量大量的0000存在，是徒增加计算成本而不会对精准分类有什么贡献，所以最好的办法就是直接忽略这些词。 具体在sklearn中我们用到的是from sklearn.feature_extraction.text import CountVectorizer这个类 1vectorizer = CountVectorizer(vocabulary=vocabularyDic,stop_words=[&apos;中国&apos;],token_pattern=u&apos;(?u)\w+&apos;,max_features=200) 那么是不是使用stop_words这个参数呢，这个要区分，如果是英文文本分类是可以的，但是中文不行，这就是坑啊，所以中文去除停用词只能靠自己。 1234567891011121314151617181920212223def translate(comment): testline = re.sub(u&quot;[\s+\.\!\/_,$%^*(+\&quot;\&apos;]+|[+——！，！。？、~@#￥%……&amp;*（）]+&quot;, &apos;&apos;, comment) testline = testline.replace(chr(32),&apos;&apos;).replace(u&apos;！&apos;, u&apos;&apos;).replace(u&apos;，&apos;, u&apos;&apos;).replace(u&apos;。&apos;, u&apos;&apos;).replace(u&apos;\n&apos;, u&apos;&apos;).replace(u&apos;\t&apos;, u&apos;&apos;).replace( u&apos;?&apos;, u&apos;&apos;).replace(u&apos;【&apos;,&apos;&apos;).replace(u&apos;o&apos;,&apos;&apos;).replace(u&apos;O&apos;,&apos;&apos;).replace(u&apos;丶&apos;,&apos;&apos;).replace(u&apos;‘&apos;,&apos;&apos;).replace(&apos;:&apos;,&apos;&apos;).replace(u&apos;：&apos;,&apos;&apos;).replace(&apos;(&apos;,&apos;&apos;).replace(&apos;)&apos;,&apos;&apos;).replace(&apos;&#123;&apos;,&apos;&apos;).replace(&apos;&#125;&apos;,&apos;&apos;).replace(u&apos;？&apos;, u&apos;&apos;).replace(u&apos;-&apos;,&apos;&apos;).replace(u&apos;一&apos;,&apos;1&apos;).replace(u&apos;二&apos;,&apos;2&apos;).replace(u&apos;三&apos;,&apos;3&apos;).replace(u&apos;四&apos;,&apos;4&apos;).replace(u&apos;五&apos;,&apos;5&apos;).replace(u&apos;六&apos;,&apos;6&apos;).replace(u&apos;七&apos;,&apos;7&apos;).replace(u&apos;八&apos;,&apos;8&apos;).replace(u&apos;九&apos;,&apos;9&apos;).replace(u&apos;零&apos;,&apos;0&apos;) testline = testline.lower() return testlinedef changeToWords(sentence): global stopwords out = translate(sentence) jiebalistnew = [] jiebalist = jieba.lcut(out) for item in jiebalist: if item not in stopwords:#去除停用词 jiebalistnew = jiebalistnew + handlenum(item) if &apos;&apos; in jiebalistnew: jiebalistnew.remove(&apos;&apos;) if &apos; &apos; in jiebalistnew: jiebalistnew.remove(&apos; &apos;) string = &apos; &apos;.join(jiebalistnew)# return string,jiebalistnew return string 仔细看translate主要作用就是去除一些特殊字符，同时对大写数字进行转化，这个一个广告识别的预处理，因为好多广告要留下来号码什么的。 抽取特征抽取特征呢，主要是形成一个词典，然后把每句话对应到词典里的词，存在就是1，不存在就是0，通过这种方式把每句话转换成10100001这种向量。 我们应该输入什么，输出的又是什么123456 #该类会统计每个词语的tf-idf权值transformer = TfidfTransformer()vectorizer = CountVectorizer(token_pattern=u&apos;(?u)\w+&apos;)#第一个fit_transform是计算tf-idf 第二个fit_transform是将文本转为词频矩阵count0 = vectorizer.fit_transform(inputList)tfidf = transformer.fit_transform(count0) 看一下上边的代码，我们的输入是inputList，那么这个变量明显就是我们的一个个的句子了，这是list类型，每个元素是一个句子，如果是英文文本，这样直接输入就好了，但是中文要进行一个转换，参照英文的样式，用空格分隔开，所以输入是下边这样的1inputList = [&apos;我 爱 中国&apos;,&apos;我 是 中国人&apos;] 输出： 特征提取，输出的当然是特征了 123456789101112131415161718transformer = TfidfTransformer()vectorizer = CountVectorizer(token_pattern=u&apos;(?u)\w+&apos;)count0 = vectorizer.fit_transform(pos)tran = transformer.fit_transform(count0)print vectorizer.vocabulary_ #这个字典里边存储了我们的关键字，以关键词为key，然后后边的value是它在向量字典里边的位置索引names = vectorizer.get_feature_names() #这个就是我们的向量词典了print count0.toarray() #这个是将为本转换为了向量，比如[0,2,1,2]2呢代表出现了两次for item in names: print itemsumlist = list(count0.toarray().sum(axis=0))#这里呢是将所有的词以及出现的次数进行了加和，看看每个词一共出现了多少次，后边两行代码都是为了这个事a1 = np.array([names,sumlist])a1 = np.transpose(a1)df = DataFrame(a1,columns=[&apos;name&apos;,&apos;count&apos;]) token提取规则这个说的是token_pattern这个参数，它决定了每个单独的特征是如何提取的，如果你不赋值，这个初始值是&#39;(?u)\\b\\w\\w+\b&#39;意思是，提取字符加空格，所以我们用空格来区分，但是这个有个坑，默认是提取两个以上的字符，这就意味着如果你的一些特征只有一个字符那么这个特征就被自动忽略了，因为我们已经有了停用词去除机制，所以这里尽量做个修改，token_pattern=u&#39;(?u)\w+&#39;这样写就能够提取一个的中文了，网上基本上都在说英文咋整，难道大家做的都是英文的文本分类….中文的表示心累… 最大特征数1vectorizer = CountVectorizer(token_pattern=u&apos;(?u)\w+&apos;，max_features=200) 这个值可以和去除低频词是异曲同工，如果我们经过分析发现特征词有1000个，然后低频是300，这样直接设置这个值是700就好了，它会自动选取最高频的700个词作为特征 训练模型以及使用模型1234567891011121314151617181920212223242526272829303132333435363738394041pos = [u&apos;i&apos;,u&apos;中国/爱你 中国&apos;,u&apos;中国)爱谁 asf i&apos;,u&apos;我+爱你&apos;,u&apos;我+爱你&apos;]# pos = [&apos;this is a dog&apos;,&apos;the dog is cute,oh lovely dog&apos;,&apos;my dauter is smiling&apos;]# pos = [&apos;i love you&apos;, &apos;i hate you&apos;, &apos;i&apos;]#该类会统计每个词语的tf-idf权值transformer = TfidfTransformer()vectorizer = CountVectorizer(analyzer=&apos;word&apos;,token_pattern=u&apos;(?u)\w+&apos;)# u&apos;(?u)\\b\\w\\w+\\b&apos;# vectorizer = CountVectorizer()#第一个fit_transform是计算tf-idf 第二个fit_transform是将文本转为词频矩阵count0 = vectorizer.fit_transform(pos)tran = transformer.fit_transform(count0)x = weighty = np.concatenate((np.zeros(len(poscorpus)), np.ones(len(negcorpus)))) x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3) modelnew = MultinomialNB()modelnew.fit(x_train, y_train)scorenew = modelnew.score(x_test, y_test)print scorenewprint &apos;donetest&apos;##必须要保存三个东西，一个是训练之后的模型，然后是joblib.dump(modelnew, &apos;bayes.pkl&apos;)joblib.dump(transformer, &apos;transformer&apos;) # 保存分类器joblib.dump(vectorizer, &apos;vectorizer&apos;) # 保存分类器print vectorizer.vocabulary_print count0.toarray()## 这里用于新数据的预测，我们需要训练好的模型，vec，tran这三个东西modelnew = joblib.load(&apos;bayes.pkl&apos;)transformer1 = joblib.load(&apos;transformer&apos;)vectorizer1 = joblib.load(&apos;vectorizer&apos;)CountVectorizer(vocabulary=vectorizer.vocabulary_,analyzer=&apos;word&apos;,token_pattern=u&apos;(?u)\w+&apos;) #注意这个会去除特殊字符count1 = vectorizer1.transform([u&apos;中国/爱你 中国&apos;])tran1 = transformer1.transform(count1) 注意训练用fit_transform，而使用的时候我们用的是transform 模型的改进方法 例如可以调节如下一些参数，观察它们对垃圾邮件过滤的实际效果的影响： 训练数据的大小 词典的大小 不同的机器学习模型，包括 GaussianNB，BernoulliNB，SVC 不同的 SVM 模型参数 删除无关紧要的词来改进词典 （例如手动删除） 采用其他特征模型 （寻找 td-idf）]]></content>
      <tags>
        <tag>python</tag>
        <tag>sklearn</tag>
        <tag>文本分类</tag>
        <tag>自然语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学-pandas]]></title>
    <url>%2F2018%2F02%2F28%2F2018%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-pandas%2F</url>
    <content type="text"><![CDATA[Series1234567891011121314151617181920212223242526In [28]: s1 = Series([1, 2, 3, 4, 5])In [29]: s1Out[29]:0 11 22 33 44 5dtype: int64In [30]: s2 = Series([1, 2, 3, 4, 5], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;])In [31]: s2Out[31]:a 1b 2c 3d 4e 5dtype: int64In [32]: s2.index.name = &apos;index&apos;In [33]: s2.indexOut[33]: Index([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;], dtype=&apos;object&apos;, name=&apos;index&apos;) pandas基本操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#新建或者读取数据df1 = DataFrame(np.arange(9).reshape(3,3), colums=list(&apos;ABC&apos;), index = list(&apos;abc&apos;))df2 = pd.read_json(&quot;/Users/Hanxiaoyang/Titanic_data/Train.json&quot;) #读 df = pd.read_csv(&quot;/Users/Hanxiaoyang/Titanic_data/Train.csv&quot;) #读import pandas as pd# JSON 文件pd.read_json# HTML 文件pd.read_html# 本地剪切板pd.read_clipboard# MS Excel 文件pd.read_excel# HDF5Format 文件pd.read_hdf # Feather 格式pd.read_feather#Msgpackpd.read_msgpack# Statapd.read_stata# SASpd.read_sas # Python Pickle 格式pd.read_pickle# SQL 数据库pd.read_sql# Google Big Querypd.read_gbq## 数据查看df.info()df.describe()df.head(10)df.info()df.describe()df.indexdf.columnslen(df[df[&apos;Age&apos;] == 10].index)age=10的是多少行# 取数据df[0:3] #第一行到第三行df[&apos;Age&apos;][0:10] #pandas.core.series.Series Age这个列的第一行到第十行 df.Age[0:10] #Age这一列的前十个df[&apos;Age&apos;].mean() #平均值df[[&apos;Sex&apos;,&apos;Pclass&apos;,&apos;Age&apos;]] #显示多个列df[df.columns[0:2]] #显示多列df[df[&apos;Age&apos;]&gt;60][[&apos;Sex&apos;,&apos;Pclass&apos;,&apos;Age&apos;,&apos;Survived&apos;]] #大于60岁的df[df[&apos;Age&apos;].isnull()][[&apos;Sex&apos;, &apos;Pclass&apos;, &apos;Age&apos;]]#为空的df[&apos;Gender&apos;] = 4 #增加一列df[&apos;Gender&apos;] = df[&apos;Sex&apos;].map( &#123;&apos;female&apos;: 0, &apos;male&apos;: 1&#125; ).astype(int) #对应的把sex的female和male变换为0，1映射到对应的行df[&apos;FamilySize&apos;] = df[&apos;SibSp&apos;] + df[&apos;Parch&apos;] df[&apos;Age*Class&apos;] = df.FamilySize * df.Pclass #构造新特征df = df.drop([&apos;Name&apos;, &apos;Sex&apos;, &apos;Ticket&apos;, &apos;Cabin&apos;, &apos;Embarked&apos;], axis=1) #删除无用列df.loc[:,[&apos;Age&apos;,&apos;Pclass&apos;]] df.iloc[0:2,[0,2]] # 前边是行，后边是是列，loc必须用label，iloc可以用数字注意这里iloc和loc代表的是行known_age = age_df[age_df.Age.notnull()].as_matrix()unknown_age = age_df[age_df.Age.isnull()].as_matrix()import pylab as P df[&apos;Age&apos;].dropna().hist(bins=16, range=(0,80), alpha = .5) P.show() #画直方图## 修改列名称123456789101112131415161718192021问题：有一个DataFrame，列名为：[&apos;$a&apos;, &apos;$b&apos;, &apos;$c&apos;, &apos;$d&apos;, &apos;$e&apos;]现需要改为：[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]有何办法？import pandas as pddf = pd.DataFrame(&#123;&apos;$a&apos;: [1], &apos;$b&apos;: [1], &apos;$c&apos;: [1], &apos;$d&apos;: [1], &apos;$e&apos;: [1]&#125;)解决：方式一：columns属性# ①暴力df.columns = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]# ②修改df.columns = df.columns.str.strip(&apos;$&apos;)# ③修改df.columns = df.columns.map(lambda x:x[1:])方式二：rename方法、columns参数# ④暴力（好处：也可只修改特定的列）df.rename(columns=(&apos;$a&apos;: &apos;a&apos;, &apos;$b&apos;: &apos;b&apos;, &apos;$c&apos;: &apos;c&apos;, &apos;$d&apos;: &apos;d&apos;, &apos;$e&apos;: &apos;e&apos;&#125;, inplace=True) 赋值替换12data[&quot;D&quot;] = data[&apos;class&apos;] #将class的给Ddata[&apos;D&apos;].replace([&apos;C1&apos;,&apos;C2&apos;], [0,1], inplace = True) #将class里边的C1和C2替换为0，1 类型转换12345train_data = df.values #pandas转numpy数组Age = df[&apos;Age&apos;]Age = np.array(Age)Age = Age.reshape(Age.size,1) #Serise转numpy数组 图像处理123456789101112data_train.Survived.value_counts().plot(kind=&apos;bar&apos;)# 柱状图plt.scatter(data_train.Survived, data_train.Age)# 散列data_train.Age[data_train.Pclass == 1].plot(kind=&apos;kde&apos;) data_train.Age[data_train.Pclass == 2].plot(kind=&apos;kde&apos;)data_train.Age[data_train.Pclass == 3].plot(kind=&apos;kde&apos;)# 密度图Survived_0 = data_train.Pclass[data_train.Survived == 0].value_counts()Survived_1 = data_train.Pclass[data_train.Survived == 1].value_counts()df=pd.DataFrame(&#123;u&apos;获救&apos;:Survived_1, u&apos;未获救&apos;:Survived_0&#125;)df.plot(kind=&apos;bar&apos;, stacked=True)#柱状图 将dataformat的数据写入csv1df.to_csv(&apos;foo.csv&apos;) 将数据库的数据写入csv1234567891011121314151617181920import csv# 文件头，一般就是数据名fileHeader = [&quot;name&quot;, &quot;score&quot;]# 假设我们要写入的是以下两行数据d1 = [&quot;Wang&quot;, &quot;100&quot;]d2 = [&quot;Li&quot;, &quot;80&quot;]# 写入数据csvFile = open(&quot;instance.csv&quot;, &quot;w&quot;)writer = csv.writer(csvFile)# 写入的内容都是以列表的形式传入函数writer.writerow(fileHeader)writer.writerow(d1)writer.writerow(d1)csvFile.close() 统计信息12345678- `count` 元素值的数量；- `mean` 平均值；- `std` 标准差；- `min` 最小值；- `25%` 下四分位数；- `50%` 中位数；- `75%` 上四分位数；- `max` 最大值； 合并这些数据集有相同的列 12pd.concat([df1, df2])pd.merge(df1, df2) 某个user_id的学习时间总和1234567891011121314151617181920In [471]: df[df[&apos;user_id&apos;] == 5348][&apos;minutes&apos;]Out[471]:0 92 45Name: minutes, dtype: int64In [472]: df[df[&apos;user_id&apos;] == 5348]Out[472]: course minutes user_id0 12 9 53482 23 45 5348In [475]: df[df[&apos;user_id&apos;] == 5348][&apos;minutes&apos;]Out[475]:0 92 45Name: minutes, dtype: int64In [476]: df[df[&apos;user_id&apos;] == 5348][&apos;minutes&apos;].sum()Out[476]: 54 使用groupby 1234567891011121314151617181920In [471]: df[df[&apos;user_id&apos;] == 5348][&apos;minutes&apos;]Out[471]:0 92 45Name: minutes, dtype: int64In [472]: df[df[&apos;user_id&apos;] == 5348]Out[472]: course minutes user_id0 12 9 53482 23 45 5348In [475]: df[df[&apos;user_id&apos;] == 5348][&apos;minutes&apos;]Out[475]:0 92 45Name: minutes, dtype: int64In [476]: df[df[&apos;user_id&apos;] == 5348][&apos;minutes&apos;].sum()Out[476]: 54 缺失值处理查找缺失值查找缺失值，我们依旧可以使用 Pandas 进行处理。Pandas 中，缺失数据一般采用NaN标记NaN 代表 Not a Number。特别地，在时间序列里，时间戳的丢失采用 NaT 标记 Pandas 用于检测缺失值主要用到两个方法，分别是：isnull() 和 notnull()，故名思意就是「是缺失值」和「不是缺失值」。默认会返回布尔值用于判断 12print(df.head(10).isnull())print(df.head(10).notnull()) 关于缺失值处理，主要有两种处理手段：删除缺失值所在的行或列或填充缺失值 处理缺失值删除缺失值是最简单直接的办法之一。它适用于三种情况： 缺失值少，对数据集的影响可以忽略不计。这句话的意思应该很好理解。比如一个数万行的数据集，恰好有某几行缺失了几个特征值。缺失的数据行远远小于全部数据的数量，且删除这几行之后，对原数据集的影响可以忽略。这时候，直接删除缺失值所在的行是最好的。 缺失数据量大，已无法挽救。举个例子，一个数据集有1 万行，存在 10 个特征列。其中某一项特征所在的列存在 9000 个空值。这也就表明该列存在的意义已经不大了。所以也需要删除数据。 该缺失值无法被填充。这种情况也很常见。就拿我们上面一直在用的 test_file.csv 数据集距离。该数据集实际为洛杉矶人口普查数据。我们可以看到数据集中有一列为 Zip Code，也就是邮编。邮编是客观存在的，也是不能随意更改的。如果某几项邮编缺失，你是无法随意通过一些数值来填充邮编。所以，对应这样的数据行已经没有意义，选择直接删除往往是最好的。删除缺失值所在的列或行非常简单，使用Pandas提供的 dropna() 方法。dropna() 方法可以将有缺失值的行或列全部移除。当然，你可以使用 axis=0 参数指定行，或 axis=1 参数指定列 123456import pandas as pddf = pd.read_csv(&quot;test_file_nan.csv&quot;)print(df.dropna(axis=0)) #这个会删除存在空值的行print(df.dropna(axis=1)) #这个会删除存在空值的列 填充缺失值除了删除缺失值，对缺失值处理的另外一种方法就是填充缺失值。如果你第一次接触缺失值处理，你可能会认为填充缺失值的处理好于直接删除缺失值。其实并不一定，原因在于填充缺失值会直接改变原有数据集，这可能会影响后续预测分析的结果。所以，使用填充缺失值时一定要更加谨慎。 一般情况下，填充缺失值有三种方法。 手动填充手动填充虽然是笨办法，但往往是效果最好的方法。手动填充非常适合于一种情形，那就是数据可以被人为有效确定。举个例子：上面的洛杉矶人口普查数据表中，第一列为邮编，它用于标记不同的地区。如果邮编有几项数据缺失，那么通过手动筛选再填充邮编就是最适合的方法。原因在于，邮编和其他数据不一样，如果它不存在或不正确，就直接导致这行数据无效，甚至影响到其他数据。手动填充，充分展现了人的灵活性，但同样是一个费时费力的办法。 临近填充 临近填充，故名思意就是采用与缺失值相邻的数据进行填充缺失值的方法。临近填充比较适合于零散的不确定数据。零散，指的是不会连续缺失数十个或上百个数据值。如果连续缺失的值太多，你用临近填充将其变为同一数据值，这对数据集整体的影响可想而知。不确定数据，就是通过视觉观察，无法发现相邻数据之间有什么联系，前后数据时大时小，无法被人为确定或找出规律。 Pandas 提供了用于临近填充的fillna()方法。该方法的使用示例如下： 12345import pandas as pddf = pd.read_csv(&quot;test_file_nan.csv&quot;)print(df.head(10).fillna(method=&apos;pad&apos;)) 我们可以对照缺失值数据，看到其被前面的临近值进行了填充。 我们也可以更换 method=’bfill’ 参数，使用后面的临近值进行填充。 1print(df.head(10).fillna(method=&apos;bfill&apos;)) 这里因为最后一项为缺失数据，所以有一部分缺失值无法被有效填充。 这里你也注意到，我们的数据其实有 200 多行，第三列的 4-9 行应该能被填充，但为什么还是 NaN ？这是因为，fillna()方法在填充时并不会影响原有数据集。 除了临近填充，有事我们还会用mean()进行平均值填充。 3. 插值填充插值填充就是采用数学的方法对数据进行插值。举个例子，有一列数据为 [2011, 2012, 2013, 缺失值, 缺失值, 2016, 2017] 。这里，无论你采用向前还是向后填充，其实都不是最好的。你可以发现数据是一个等差数列，缺失值应该分别为[2014, 2015]，这也就是一个线性插值的过程。 Pandas 提供了相关插值方法，通过interpolate()方法实现。默认为参数为线性插值，即 method=’linear’。举例： 12345import pandas as pddf = pd.read_csv(&quot;test_file_nan.csv&quot;)print(df.interpolate().head(10)) 注意线性插值结果与前面临近插值结果的区别，第一列明显要好很多。 填充缺失值除了删除缺失值，对缺失值处理的另外一种方法就是填充缺失值。如果你第一次接触缺失值处理，你可能会认为填充缺失值的处理好于直接删除缺失值。其实并不一定，原因在于填充缺失值会直接改变原有数据集，这可能会影响后续预测分析的结果。所以，使用填充缺失值时一定要更加谨慎。 一般情况下，填充缺失值有三种方法。 手动填充。手动填充虽然是笨办法，但往往是效果最好的方法。手动填充非常适合于一种情形，那就是数据可以被人为有效确定。举个例子：上面的洛杉矶人口普查数据表中，第一列为邮编，它用于标记不同的地区。如果邮编有几项数据缺失，那么通过手动筛选再填充邮编就是最适合的方法。原因在于，邮编和其他数据不一样，如果它不存在或不正确，就直接导致这行数据无效，甚至影响到其他数据。手动填充，充分展现了人的灵活性，但同样是一个费时费力的办法。 临近填充。 临近填充，故名思意就是采用与缺失值相邻的数据进行填充缺失值的方法。临近填充比较适合于零散的不确定数据。零散，指的是不会连续缺失数十个或上百个数据值。如果连续缺失的值太多，你用临近填充将其变为同一数据值，这对数据集整体的影响可想而知。不确定数据，就是通过视觉观察，无法发现相邻数据之间有什么联系，前后数据时大时小，无法被人为确定或找出规律。 Pandas 提供了用于临近填充的fillna()方法。该方法的使用示例如下： import pandas as pd df = pd.read_csv(“test_file_nan.csv”) print(df.head(10).fillna(method=’pad’))我们可以对照缺失值数据，看到其被前面的临近值进行了填充。 我们也可以更换 method=’bfill’ 参数，使用后面的临近值进行填充。 print(df.head(10).fillna(method=’bfill’))这里因为最后一项为缺失数据，所以有一部分缺失值无法被有效填充。 这里你也注意到，我们的数据其实有 200 多行，第三列的 4-9 行应该能被填充，但为什么还是 NaN ？这是因为，fillna()方法在填充时并不会影响原有数据集。 除了临近填充，有事我们还会用mean()进行平均值填充。 插值填充。插值填充就是采用数学的方法对数据进行插值。举个例子，有一列数据为 [2011, 2012, 2013, 缺失值, 缺失值, 2016, 2017] 。这里，无论你采用向前还是向后填充，其实都不是最好的。你可以发现数据是一个等差数列，缺失值应该分别为[2014, 2015]，这也就是一个线性插值的过程。 Pandas 提供了相关插值方法，通过interpolate()方法实现。默认为参数为线性插值，即 method=’linear’。举例： 12345import pandas as pddf = pd.read_csv(&quot;test_file_nan.csv&quot;)print(df.interpolate().head(10)) 注意线性插值结果与前面临近插值结果的区别，第一列明显要好很多。 独热编码在对数据的预处理过程中，我们会遇到有一些特征列中的样本并不是连续存在的，而是以分类形式存在的情况。例如，某一装置的状态有三种情况，分别为：正常、机械故障、电路故障。如果我们要将这些数据运用到后续的预测分析中，就需要对文字状态进行转换。一般情况下，可以用 0 表示正常，1 代表机械故障，2 代表电路故障。 但是这种映射方式，往往会让学习器认为 2 代表电路故障比 1 代表机械故障更「大」，从而影响模型分析结果，这肯定是不行的。 所以，对于以分类形式存在的特征变量，我们会采用一种叫独热编码（One-Hot Encoding）的方式将其转换成二元特征编码，进一步对特征进行了稀疏处理。独热编码采用位状态寄存器来对个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候只有一位有效。举例如下： Pandas 提供了更简单的方法来处理以分类形式的变量。我们可以通过 get_dummies() 将以分类形式存在的变量转换为独热编码。123import pandas as pddf = pd.read_csv(&quot;one_hot_demo.csv&quot;, header=0) 在此演示文件中，status 共有 none, electric, engine三类数值。color 有red 和 green两类。 12oneHot = pd.get_dummies(df[[&apos;status&apos;, &apos;color&apos;]])oneHot.head(10) 我们可以看到，字符串被进行了独热编码，特征也从原先的 2 列拓充为 5 列。所以，独热编码的好处多多 重复值处理数据集中包含大量的重复数据也是数据预处理会经常面临的状况。接下来，我们来看一看 Pandas 提供了哪些用于处理重复数据的方法。 pandas.DataFrame.duplicated() 可以用来标识重复数据，数据集中重复数据行会返回布尔类型 True。上面的独热编码示例数据集中存在大量重复数据，我们就拿它举例： 123import pandas as pddf = pd.read_csv(&quot;one_hot_demo.csv&quot;, header=0) print(pd.DataFrame.duplicated(df).head(10))我们可以看到，前 10 行数据中，就有 5 行为重复数据。当然这个是完整数据集的比对结果，这里只是显示了前 10 行。 pandas.DataFrame.drop_duplicates()可以返回一个去重后的数据集。12345import pandas as pddf = pd.read_csv(&quot;one_hot_demo.csv&quot;, header=0)print(pd.DataFrame.drop_duplicates(df)) 去重后的数据集如下，仅有 6 行非重复项。 异常值检测除了缺失值与重复值，在处理数值型数据时，我们还容易遇到一种状况，那就是异常值。异常值检测是处理数值型数据过程中必须重视的一项工作。那些在收集、录入过程中产生的异常数据，如果不及时剔除，很可能对后续的预测分析带来严重不良影响。 应用数学和统计学领域对异常值检测研究比较深入，目前存在的检测方法也非常多。大致来讲，有从概率方法入手的一元正态分布及多元高斯方法，还有通过矩阵分解和神经网络进行异常值检测的相关方法。 在这里，我们介绍一种简单直观的异常值检测方法，那就是通过箱形图（箱线图）来识别异常数据。箱形图是用来观测数据集分布的一种图形类型。箱形图中，从上到下依次有 6 个数据节点，分别是上界、上四分位、均值、中位数、下四分位、下界。而那些超过上界的值就会被标记为离群点，也就是异常数据。 下面我们使用上一节提到的洛杉矶人口数据进行箱形图绘制。12345678910from matplotlib import pyplot as pltimport pandas as pddata = pd.read_csv(&quot;test_file.csv&quot;, header=0)Total_Population = data[&quot;Total Population&quot;]plt.boxplot(Total_Population)plt.show() 我们可以将离群点标记并导出： 123456789101112from matplotlib import pyplot as pltimport pandas as pddata = pd.read_csv(&quot;test_file.csv&quot;, header=0)Total_Population = data[&quot;Total Population&quot;]P = plt.boxplot(Total_Population)outlier = P[&apos;fliers&apos;][0].get_ydata()print(outlier) 其实，DataFrame 带有 boxplot() 方法可以很方便地将所有列数据的箱形图画在一张图中对比： 1234567from matplotlib import pyplot as pltimport pandas as pddata = pd.read_csv(&quot;test_file.csv&quot;, header=0)data.boxplot()plt.show() 异常值在前面的实验中我们学习过四分位数。四分位数，是指将一组数据值按大小排序后分成四等分，每一部分包含 1/4 的数据，这种划分的分割点就是四分位数。其中第1部分和第2部分的分割点称为第1分位数 Q_1, 也被称为第25百分位数（上四分位），第3部分和第4部分的分割点称为第3四分位数 Q_3​​ ，也被称为第75百分位数（下四分位）。而第二部分和第三部分的分割点是第2四分数，也就是中位数。其中四分位距 IQRIQR 是指第三四分位数和第一分四分位数的差，也就是 IQR = Q_3 - Q_1 IQR=Q3−Q1。所有小于 Q_1 - 1.5IQR 或 大于 Q_3 + 1.5IQR Q3​​ +1.5IQR 的数据项被称为异常值 异常值监测的代码 1234567891011121314151617181920import numpy as npdef find_outlier(data): outlier = [] a = np.array(data) # 完成剩余代码 Q1 = np.percentile(a,25) Q3 = np.percentile(a,75) IQR = Q3 - Q1 condition = (a &lt; Q1 - 1.5*IQR) ca = np.extract(condition, a) b = np.extract(condition, a) conditionb = (a &gt; Q3 +1.5*IQR) c = np.extract(conditionb, a) outlier = np.concatenate((b,c)) return outlier Dx5Qup71pt]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据挖掘</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学--绘图--matplotlib+Seaborn+Bokeh]]></title>
    <url>%2F2018%2F02%2F28%2F2018%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-matplotlib%2F</url>
    <content type="text"><![CDATA[matplotlib 是面向对象的绘图工具包，绘制的图形中每一个元素都是一个对象，比如线条，文字，刻度等信息，可以通过修改这些对象的属性，从而改变绘图样式。 matplotlib 中主要的绘图对象列表如下：&gt; Figure 对象，可以想象为一张画布； Axes 对象，字面理解为坐标轴（因为每一个 Axes 都有一套 X Y轴坐标系，绘制图形时基于此坐标系绘制。) 也可以认为是子图，在一个 Figure 对象中可以包含多个 Axes 对象，也就是说一张画布可以包含多个子图；可以通过 plt.gcf() 和 plt.gca() 分别获取当前用于绘图的 Figure 和 Axes 对象 Line2D 对象，代表线条； Text 对象，代表了文字，比如一张子图需要标题，就可以使用一个 Text 对象； 1fig.add_subplot(2, 2, 4）#意思是，添加一个坐标体系，两行两列，然后添加到第四个位置上 123456789101112131415import numpy as npimport matplotlib.pyplot as pltfig1 = plt.figure()ax1 = fig1.add_subplot(2,2,1) #2行2列，我是第1个ax1.plot(np.random.randn(150).cumsum(), &apos;k--&apos;) #ax2 = fig1.add_subplot(2,2,2) #2行2列，我是第2个ax2.hist(np.random.randn(100), bins=20, color=&apos;k&apos;)ax3 = fig1.add_subplot(2,2,3) #2行2列，我是第3个ax3.scatter(np.arange(30), np.arange(30) + 3 * np.random.randn(30)) #散点plt.show() 其他的一些设置 12345678910111213141516171819202122232425262728import numpy as np import matplotlib.pyplot as plt fig = plt.figure() ax = fig.add_subplot(1,1,1) # 设置标题ax.set_title(&quot;Axes Example&quot;)major_ticks = np.arange(0, 101, 20) minor_ticks = np.arange(0, 101, 5) # 设置刻度ax.set_xticks(major_ticks) ax.set_xticks(minor_ticks, minor=True) ax.set_yticks(major_ticks) ax.set_yticks(minor_ticks, minor=True) # 设置 X, Y 轴 标签ax.set_xlabel(&quot;X axis&quot;)ax.set_ylabel(&quot;Y axis&quot;)# 设置网格 ax.grid(which=&apos;minor&apos;, alpha=0.2) ax.grid(which=&apos;major&apos;, alpha=0.5)# 添加文字ax.text(42.5, 50, &quot;shiyanlou&quot;) 常用图形线性图1234567891011import numpy as npimport matplotlib.pyplot as pltfig = plt.figure() ax = fig.add_subplot(1,1,1)x = np.random.randn(100)y = np.random.randn(100)ax.plot(x, y)fig.show() 直方图1234data = np.random.normal(0, 20, 1000)bins = np.arange(-100, 100, 5)ax.hist(data, bins=bins)fig.show() 上面的代码首先通过 np.random.normal 方法，在 0 到 20 的范围产生 1000 个符合正态分布的数据值，然后通过 np.arange(-100, 100, 5) 创建了 X 轴的区间刻度 散点图散点图，将所有的数据值在图形中绘制成点，这样有多少数据值在图形中就会有多少个点。通过这些数据点可以看出数据值的分布模式，比如是否有聚类模式，或者相关关系或者发现离群点。在 matplotlib 中可以通过 Axes.scatter 绘制散点图： 1234x = np.arange(1, 101)y = 20 + 3 * x + np.random.normal(0, 60, 100)ax.scatter(x, y)fig.show() 为了模拟散点图，我们先通过 np.arange(1, 101) 创建了 100 个数据值，接着基于此创建了 100 个 Y 轴数据，可以看到这里两组数据值之间有相关关系，因为是基于线性关系然后加上随机数生成的，绘制的散点图也证明了这点（图形向上倾斜） 箱线图箱线图可以看出数据的分散程度，异常值等信息，箱线图根据一组数据的以下 5 个统计值进行绘制： 最小值；第1四分位数；中位数；第3四分位数；最大值；其中四分位数，是指将一组数据值按大小排序后分成四等分，每一部分包含 1/4 的数据，这种划分的分割点就是四分位数。其中第1部分和第2部分的分割点称为第1分位数 Q_1Q​1​​ , 也被称为第25百分位数，第3部分和第4部分的分割点称为第3四分位数 Q_3Q​3​​ ，也被称为第75百分位数。而第二部分和第三部分的分割点是第2四分数，也就是中位数。其中四分位距 IQRIQR 是指第三四分位数和第一分四分位数的差，也就是 IQR = Q_3 - Q_1 IQR=Q​3​​ −Q​1​​ 。四分位距反映了中间 50% 数据的离散程度，数值越小代表数据越集中，越大代表数据越分散。 在 matplotlib 中可以使用 Axes.boxplot 方法绘制箱线图： 1234567891011# 产生 50 个小于 100 的随机数spread = np.random.rand(50) * 100# 产生 25 个值为 50 的数据center = np.ones(25) * 50# 异常值outlier_high = np.random.rand(10) * 100 + 100outlier_low = np.random.rand(10) * -100data = np.concatenate((spread, center, outlier_high, outlier_low), 0)ax.boxplot(data)fig.show() 上面的代码中，我们特意创建了 data 数据，可以推断出该数据的中位数是 50，还有一些其他异常值 SeabornBokeh]]></content>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kaggle入门随笔]]></title>
    <url>%2F2018%2F02%2F26%2F2018%2Fkaggle%E5%85%A5%E9%97%A8%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[初级问题 在哪里编码 无所谓，但是kaggle提供了kernal，可以直接使用其硬件资源 在哪里提交，提交的是什么 在问题页面的submit，然后提交的是最后你预测的结果，而不是代码 一般流程 数据集–&gt;认识数据–&gt;数据预处理–&gt;构建特征工程–&gt;选择算法–&gt;生成模型 工具集 sklearn 机器学习算法 pandas 数据处理 numpy 数据处理 matplotlib 作图 Seaborn 作图 matplotlib异常值监测(Outlier detection)找到异常值，然后舍弃这些数据 缺失值处理某些值可能和缺失值存在明显的相关性，所以我们可以通过这些值来推断缺失的值 特征分析(Feature analysis)算法比较好多算法都生成模型，然后来测一下这个值是多少，比较一下用哪个 交叉验证(cross validation)模型融合(Combining models)用到的新函数collections模块Counter 统计关键字计数12In [3]: collections.Counter([&apos;a&apos;,&apos;b&apos;,&apos;b&apos;,&apos;c&apos;,&apos;c&apos;,&apos;c&apos;])Out[3]: Counter(&#123;&apos;c&apos;: 3, &apos;b&apos;: 2, &apos;a&apos;: 1&#125;) 常用单词gaussian distribution – 高斯分布peak corresponding – 峰值cross validation- 交叉验证]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xcode证书相关]]></title>
    <url>%2F2018%2F02%2F24%2F2018%2Fxcode%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[1.如果你的profile文件始终找不到证书，但是这个证书明明在你的证书里边，这个时候查看全部证书，可能存在重名的证书2.证书从网站上下载是不好使的，因为没有私钥，需要证书的创建者去给你导出一个p12，或者拥有p12证书的人给你导出一个p12，记得要带着里边的钥匙3.appid是决定你的app是否唯一的东西，证书是决定的是哪台电脑有签名的能力，profile文件在创建的时候需要绑定id，证书，和设备id，它决定，这个电脑上能够签名哪个app，然后签名出来的app可以给谁安装]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++面试题汇总]]></title>
    <url>%2F2018%2F02%2F17%2F2015%2Fc-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[https://www.jianshu.com/p/cc1bdada166fhttps://www.jianshu.com/p/06d2f28d0747https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.htmlhttps://github.com/huihut/interview]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python/mongo常用记录]]></title>
    <url>%2F2018%2F02%2F05%2F2018%2Fpython%E8%BF%9B%E9%98%B6%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[python常用 多进程 排序 时间模块 查看帮助文档dir(os) 单元测试 多进程multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块提供了一个Process类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束 1234567891011121314import osfrom multiprocessing import Processdef runfunction(d): time.sleep(3) print &apos;%s &apos; % (os.getpid()) + &apos;is the subprocess&apos; if __name__ == &apos;__main__&apos;: print &apos;Parent is %s&apos; % os.getpid() p = Process(target=runfunction, args=(&apos;1&apos;,)) print &apos;Process will start.&apos; p.start() p.join()#这样写其实是同步执行的肯定 print &apos;Process end.&apos; 多个进程，但是异步执行 1234567891011121314151617181920212223242526272829303132# !/usr/bin/env python # -*- coding:utf-8 -*- ## Copyright 2015 mimvp.com import multiprocessingimport timeimport os def func(name, processName): print &apos;Process[%s] hello %s&apos; % (processName, name) print &apos;sub pid: %d, ppid: %d&apos; % (os.getpid(), os.getppid()) time.sleep(0.1) def main(): print &apos;main pid: %d, ppid: %d&apos; % (os.getpid(), os.getppid()) processList = [] for i in xrange(4): pro = multiprocessing.Process(target=func, args=(i, &apos;Process-&apos; + str(i))) pro.start()# pro.join() # 不要在此处阻塞子进程，否则子进程都将是线性顺序执行 processList.append(pro) for pro in processList: pro.join() # 在此处阻塞子进程，可实现异步执行效果，直至子进程全部完成后再继续执行父进程 # 测试if __name__ == &apos;__main__&apos;: main() print(&apos;end.&apos;) 同时创建多个进程 12345678910111213141516171819from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print &apos;Run task %s (%s)...&apos; % (name, os.getpid()) start = time.time() time.sleep(2) end = time.time() print &apos;Task %s runs %0.2f seconds.&apos; % (name, (end - start))if __name__==&apos;__main__&apos;: print &apos;Parent process %s.&apos; % os.getpid() p = Pool(10) for i in range(10): p.apply_async(long_time_task, args=(i,)) print &apos;Waiting for all subprocesses done...&apos; p.close() p.join() print &apos;All subprocesses done.&apos; 根据多个参数，创建多个进程 123456789def sortwithnum(): pass dataList = [1,2,3,4,5] pool = Pool() #创建拥有5个进程数量的进程池rl = pool.map(sortwithnum, dateList) pool.close()#关闭进程池，不再接受新的进程pool.join()#主进程阻塞等待子进程的退出 进程通信 1234567891011121314151617181920212223242526272829303132333435363738import multiprocessingimport timeimport os lock = multiprocessing.Lock() def func(name, processName, queue): p_info = &apos;Process[%s] hello %s&apos; % (processName, name) queue.put(p_info) print &apos;queue put: &apos;, p_info print &apos;sub pid: %d, ppid: %d&apos; % (os.getpid(), os.getppid()) time.sleep(0.5) def main(): print &apos;main pid: %d, ppid: %d&apos; % (os.getpid(), os.getppid()) qu = multiprocessing.Queue() processList = [] for i in xrange(4): pro = multiprocessing.Process(target=func, args=(i, &apos;Process-&apos; + str(i), qu)) pro.start() processList.append(pro) for pro in processList: pro.join() while not qu.empty(): p_info = qu.get(block=False) print &apos;queue get: &apos;, p_info if __name__ == &apos;__main__&apos;: main() print(&apos;end.&apos;) 排序1itemList.sort(key=lambda k : (k.get(&apos;datetime&apos;,0),(&apos;createtime&apos;,0)), reverse=False) 时间模块1234now_time = datetime.datetime.now()now_time_string = now_time.strftime(&apos;%Y-%m-%d&apos;)yes_time = now_time + datetime.timedelta(days=daysl)yes_time_nyr = yes_time.strftime(&apos;%Y-%m-%d&apos;) ```]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS线程安全与原子属性]]></title>
    <url>%2F2018%2F01%2F29%2F2015%2FiOS%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%8E%9F%E5%AD%90%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Objective-C 在声明一个属性的时候，想必大家都是不用经过大脑思考就会写 @property (nonatomic, ... 我们都知道属性可以是 nonatomic 也可以使 atomic 的，但是好像几乎所有属性在声明的时候 nonatomic，atomic 的属性几乎没出现过。atomic 修饰符仿佛已被大家遗忘。 实际上，如果声明属性时既不写 atomic 也不写 nonatomic，那么这个属性默认是 atomic 的。 atomic 的作用和工作原理从字面上来看 nonatomic 是非原子的，atomic 是原子的。 atomic 的作用为：atomic 修饰的属性的写操作是一个原子操作。 什么是原子操作？原子操作就是指不会被线程调度机制打断的操作。这个操作是一个整体，CPU 一旦开始执行它，就会一直到执行结束，在这期间 CPU 不会转而去执行其它线程的操作。 两种加锁的方式12345- (void)setCount:(NSInteger)count &#123; @synchronized (self) &#123; _count = count; &#125;&#125; 上面代码实现了和 atomic 相同的功能，但是底层的工作方式还是有区别的。我们常常用 @synchronized 来加锁，这种锁是互斥锁。而 atomic 修饰的属性自带了一把自旋锁。 互斥锁 当某个资源被先进入的线程上了锁以后，其它后面进入的线程会进入休眠状态。当锁释放后，进入休眠状态的线程变为唤醒状态。 自旋锁 当某个资源被先进入的线程上了锁以后，其它后进入的线程会开启一个循环，不断检查锁有没有释放，当锁释放后，退出循环开始访问资源，整个过程中后进入的线程一直保持运行状态。 对比 nonatomic 和 atomic nonatomic 执行效率高，性能好 不是线程安全的 atomic 线程安全，但是仅能保证写操作的线程安全 大幅降低执行效率 关于线程安全首先理解我们只有一个地址总线，一个内存。即使是在多线程的环境下，也不可能存在两个线程同时访问同一块内存区域的场景，内存的访问一定是通过一个地址总线串行排队访问的，所以在继续后续之前，我们先要明确几个结论： 结论一：内存的访问时串行的，并不会导致内存数据的错乱或者应用的crash。 结论二：如果读写（load or store）的内存长度小于等于地址总线的长度，那么读写的操作是原子的，一次完成。比如bool，int，long在64位系统下的单次读写都是原子操作。 线程不安全举例 针对int类型，可能出现，数值计算不对的情况 针对指针那就是，如果A线程获取了指针，但是在B线程对对这个指针的内存空间进行了释放，那么在A线程就会造成崩溃 1234567891011121314151617181920@property (atomic, strong) NSString* stringA;//thread Afor (int i = 0; i &lt; 100000; i ++) &#123; if (i % 2 == 0) &#123; self.stringA = @&quot;a very long string&quot;; &#125; else &#123; self.stringA = @&quot;string&quot;; &#125; NSLog(@&quot;Thread A: %@\n&quot;, self.stringA);&#125;//thread Bfor (int i = 0; i &lt; 100000; i ++) &#123; if (self.stringA.length &gt;= 10) &#123; NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)]; &#125; NSLog(@&quot;Thread B: %@\n&quot;, self.stringA);&#125; 正确做法 12345678910111213141516171819//thread A[_lock lock];for (int i = 0; i &lt; 100000; i ++) &#123; if (i % 2 == 0) &#123; self.stringA = @&quot;a very long string&quot;; &#125; else &#123; self.stringA = @&quot;string&quot;; &#125; NSLog(@&quot;Thread A: %@\n&quot;, self.stringA);&#125;[_lock unlock];//thread B[_lock lock];if (self.stringA.length &gt;= 10) &#123; NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];&#125;[_lock unlock]; 虽然stringA是atomic的property，而且在取substring的时候做了length判断，线程B还是很容易crash，因为在前一刻读length的时候self.stringA = @”a very long string”;，下一刻取substring的时候线程A已经将self.stringA = @”string”;，立即出现out of bounds的Exception，crash，多线程不安全。 1234567891011121314151617181920@property (atomic, strong) NSArray* arr;//thread Afor (int i = 0; i &lt; 100000; i ++) &#123; if (i % 2 == 0) &#123; self.arr = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;]; &#125; else &#123; self.arr = @[@&quot;1&quot;]; &#125; NSLog(@&quot;Thread A: %@\n&quot;, self.arr);&#125;//thread Bfor (int i = 0; i &lt; 100000; i ++) &#123; if (self.arr.count &gt;= 2) &#123; NSString* str = [self.arr objectAtIndex:1]; &#125; NSLog(@&quot;Thread B: %@\n&quot;, self.arr);&#125; 12345678910111213141516171819//thread A[_lock lock];for (int i = 0; i &lt; 100000; i ++) &#123; if (i % 2 == 0) &#123; self.arr = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;]; &#125; else &#123; self.arr = @[@&quot;1&quot;]; &#125; NSLog(@&quot;Thread A: %@\n&quot;, self.arr);&#125;[_lock unlock]; //thread B[_lock lock];if (self.arr.count &gt;= 2) &#123; NSString* str = [self.arr objectAtIndex:1];&#125;[_lock unlock]; 同理，即使我们在访问objectAtIndex之前做了count的判断，线程B依旧很容易crash，原因也是由于前后两行代码之间arr所指向的内存区域被其他线程修改了。 所以你看，真正需要操心的是这一类内存区域的访问，即使声明为atomic也没有用，我们平常App出现莫名其妙难以重现的多线程crash多是属于这一类，一旦在多线程的场景下访问这类内存区域的时候，要提起十二分的小心。如何避免这类crash后面会谈到。 Property多线程安全小结：简而言之，atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。 参考MrPeak]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户行为路径分析思路]]></title>
    <url>%2F2018%2F01%2F23%2F2018%2F%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[用户特征分析 预测模型 活跃度定义 用户路径分析 交叉销售 用户分层 Predict Customer Behaviourcustomer’s classification 意图识别确定哪些路径可以促进增长，客户忠诚度和满意度，哪些路径会增加用户的抱怨 发现。 机器学习揭示了客户跨越渠道和时间跨越的最关键途径，并识别客户旅程中的关键障碍和机会，以便将注意力集中在针头上。目标。 使用人口统计特性和上下文属性，可以快速查明特定客户群的转换可能性最高。从事。根据每位客户的个人行为，在正确的时间为合适的客户提供个性化的体验，利用Pointillist平台的智慧以及与技术栈中现有的营销工具的集成。监控。评估营销活动和策略对您的KPI的影响并实时监控变化，以便您的团队能够迅速将洞察力转化为推动结果的行动 在一段时间内快速了解所有接触点和渠道中的客户行为发现和预测高影响力的客户旅程推动个性化，多渠道的客户体验 用户分层，分类的依据 目的是什么，有没有达到他的目的 用户在如何使用我们的产品，在我们产品里干什么 通过使用配备先进的机器学习算法的客户旅程分析平台，您可以快速发现旅程中的重要事件，例如客户从旅程中的A点到B点最常见的路径。此外，它使您能够实时预测客户行为，并决定最合适的参与方式。在上面的图表中，机器学习算法用于对数百万次实际旅程进行分类，以揭示客户在在线查看产品和退出之间所采用的最重要路径。 客户旅程分析使营销和CX团队不仅能够发现哪些旅程最重要，而且能够通过他们的首选渠道和相关的个性化方式，在最佳时间自动与每个客户进行互动。通过在旅途中的任何事件中嵌入触发器，您可以在特定事件中激活参与（例如电子邮件发送）到目标客户群 - 转换的客户，向前移动的客户，甚至在特定的点旅程。 这些实时参与触发器比以往的基于规则的编码系统更容易管理和更有效。 高级客户旅程分析平台与常用的营销工具集成在一起，因此您可以使用现有的营销技术堆栈与您的客户进行互动。结果是营销和CX广告系列的性能提高了一个新的水平，通过更好的精度，目标和时间。 内容报告可帮助您了解网站的哪些部分效果理想、哪些页面最受欢迎，并据此为客户营造更佳的体验。 具体来说，目标是： 通过人物角色形象化和映射端到端的客户旅程优化正确的旅程属性可以提高收益30％以上…发现最佳实现目标目标的网络，移动和实体渠道，内容和体验的正确组合使营销人员能够识别个人和团体的旅程瓶颈利用实际行为数据来增强和个性化每个客户的体验 简单的个性化…然后，我们通过简单的“个性化”客户体验，基于浅数据，如购买历史，性别，单身或结婚，住在哪里等等。动态个性化…现在，我们正在进入一个新的阶段，重点是最佳消息+最佳通道+最佳时机+最佳设备。这主要是由预测分析（例如Next Next Offer），机器学习，兴趣图，位置感知上下文敏感度以及大规模个性化所驱动的。 更复杂的公司无缝地创建闭环（分析和参与和机器学习）。它们利用客户身份，位置，当前活动，物理状况（天气，交通等），购买历史，移动模式，隐含和明确的意图信号以及社交图形等实时信号。 几家公司正在将预测分析纳入移动营销平台。通过根据历史数据分析多个实时数据流，算法模型预测未来趋势，用户偏好和行动，让品牌知道客户在做什么之前要做的事情，比如放弃购物车，搅动或分享他们的体验？目标是介入正确的信息或提议来激励或改变他们的行为。 这种分析洞察力使零售商能够转移店内策略和运营，以匹配购物者的兴趣和行为，从而提高客户的忠诚度 客户流失通过收入损失降低盈利能力客户流失导致更大的营销和重新购置成本向现有客户销售的可能性远高于新的前景了解客户流失率有助于计算客户的生命周期价值这是衡量公司健康状况和长远前景的一个指标客户流失决定了客户保留是否在改善它有助于确定哪些客户和细分市场最适合您的产品 一个典型的顾客今天可能会首先通过社交媒体广告找到产品，在公司网站上查看并在实体店购买。但是，您是否有能力将这个客户视为一个人而不是三个不同的购物者？大多数公司仍将每个设备和每个交互作为一个单独的客户，将客户旅程分解成不同的碎片。 用户路径分析 用户典型，频繁路径识别 用户行为特征识别 输出 活跃度定义，符合该分值的用户更容易转化为付费用户啊，新的标准更容易反应和衡量产品的运营效果和效率，比如目标是付费用户，那么符合该指标的用户应该越大程度属于付费用户，那么说明该指标的越合理(主成分析+决策归因) 基于行为路径的用户标签系统(用户分层/分类)可以提供给千人千面+运营 比如流失，付费，活动响应等维度(维度来源增量可以是用户反馈) 实时预测客户行为，并决定最合适的参与方式 通过在旅途中的任何事件中嵌入触发器，您可以在特定事件中激活参与（例如电子邮件发送）到目标客户群 - 转换的客户，向前移动的客户，甚至在特定的点旅程。 这些实时参与触发器比以往的基于规则的编码系统更容易管理和更有效 实时的Journey Map(用户旅行地图) 产品使用模式设计与实际情况对比，提前预想用户可能的操作模式，与实际的对比，如果发现不一致可以深入分析原因调整产品策略和运营策略，为什么这种设计是有效的，而那种是无效的(因素提炼) 频繁路径和典型路径揭示，揭示客户在在线查看产品和退出之间所采用的最重要路径:客户在做什么之前要做的事情，比如放弃购买或分享他们的体验？目标是介入正确的信息或提议来激励或改变他们的行为，具体比如说，通过聚类技术划分付费和非付费，对比两者路径优化页面布局，通过发现付费用户路径中的异常模式来对付费环境进行优化 发现冷僻功能点和路径]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS编译过程详解]]></title>
    <url>%2F2018%2F01%2F22%2F2017%2FiOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[通过Xcode设置工程依赖之后，Xcode会先编译被依赖工程，最后编译有依赖工程。达到控制编译顺序的目的。 下面是编译过程完整步骤 编译信息写入辅助文件，创建文件架构 .app 文件 处理文件打包信息 执行 CocoaPod 编译前脚本，checkPods Manifest.lock 编译.m文件，使用 CompileC 和 clang 命令 链接需要的 Framework 编译 xib 拷贝 xib ，资源文件 编译 ImageAssets 处理 info.plist 执行 CocoaPod 脚本 拷贝标准库 创建 .app 文件和签名 基础概念在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。 targettarget指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。 target会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。 若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。 projectxcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。project包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。project定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。 build settings一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。 workspaceworkspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。 xcode schemexcodescheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。 一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学numpy]]></title>
    <url>%2F2018%2F01%2F02%2F2018%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6numpy%2F</url>
    <content type="text"><![CDATA[数组的创建 有关数组的属性和函数 数组元素的获取–普通索引、切片、布尔索引和花式索引 统计函数与线性代数运算 随机数的生成 矩阵对象 列表，数组，元组 数组的创建numpy中使用array()函数创建数组，array的首个参数一定是一个序列，可以是元组也可以是列表。 arange()函数创建一维有序数组1234567891011&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; ls1 = range(10)&gt;&gt;&gt; list(ls1)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; type(ls1)&lt;type &apos;list&apos;&gt;&gt;&gt;&gt; ls2 = np.arange(10)&gt;&gt;&gt; list(ls2)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; type(ls2)&lt;type &apos;numpy.ndarray&apos;&gt; 从[2,20)间隔为3的等差数列 12a = np.arange(2,20,3)[ 2 5 8 11 14 17] array()函数如果一维数组不是一个规律的有序元素，而是人为的输入，就需要array()函数创建了。 12345&gt;&gt;&gt; arr1 = np.array((1,20,13,28,22))&gt;&gt;&gt; arr1array([ 1, 20, 13, 28, 22])&gt;&gt;&gt; type(arr1)&lt;type &apos;numpy.ndarray&apos;&gt; 上面是由元组序列构成的一维数组。 12345&gt;&gt;&gt; arr2 = np.array([1,1,2,3,5,8,13,21])&gt;&gt;&gt; arr2array([ 1, 1, 2, 3, 5, 8, 13, 21])&gt;&gt;&gt; type(arr2)&lt;type &apos;numpy.ndarray&apos;&gt; 上面是由列表序列构成的一维数组。 二维数组的创建二维数组的创建，其实在就是列表套列表或元组套元组。 1234567&gt;&gt;&gt; arr3 = np.array(((1,1,2,3),(5,8,13,21),(34,55,89,144)))&gt;&gt;&gt; arr3array([[ 1, 1, 2, 3], [ 5, 8, 13, 21], [ 34, 55, 89, 144]])``` 上面使用元组套元组的方式。 arr4 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])arr4array([[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12]])1234567上面使用列表套列表的方式。对于高维数组在将来的数据分析中用的比较少，这里关于高维数组的创建就不赘述了。#### 特殊数组numpy中也提供了几种特殊的数组np.ones 返回一维元素全为1的数组 np.ones(5)array([ 1., 1., 1., 1., 1.])1返回元素全为1的3×4二维数组 np.ones([3,4])array([[ 1., 1., 1., 1.], [ 1., 1., 1., 1.], [ 1., 1., 1., 1.]])1np.zeros 返回一维元素全为0的数组 np.zeros(3)array([ 0., 0., 0.])1返回元素全为0的3×4二维数组 np.zeros([3,4])array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]])1np.empty 返回一维空数组 np.empty(3)array([ 0., 0., 0.])12返回3×4二维空数组 np.empty([3,4])array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]])1234567### 数组的属性arr3.shape 行列arr3.dtype 元素类型arr3.ndim 纬度arr3.size 元素总个数 arr3array([[ 1, 1, 2, 3], [ 5, 8, 13, 21], [ 34, 55, 89, 144]])1shape方法返回数组的行数和列数 arr3.shape(3L, 4L)1dtype方法返回数组的数据类型 arr3.dtypedtype(‘int32’)1通过ravel的方法将数组拉直（多维数组降为一维数组） arr3.ravel()array([ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144])1通过flatten的方法将数组拉直 b = arr3.flatten()barray([ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144])12两者的区别在于ravel方法生成的是原数组的视图，无需占有内存空间，但视图的改变会影响到原数组的变化。而flatten方法返回的是真实值，其值的改变并不会影响原数组的更改。通过下面的例子也许就能明白了： b[:3] = 0barray([ 0, 0, 0, 3, 5, 8, 13, 21, 34, 55, 89, 144])arr3array([[ 1, 1, 2, 3], [ 5, 8, 13, 21], [ 34, 55, 89, 144]])1通过更改b的值，原数组没有变化。 a[:3] = 0aarray([ 0, 0, 0, 3, 5, 8, 13, 21, 34, 55, 89, 144])arr3array([[ 0, 0, 0, 3], [ 5, 8, 13, 21], [ 34, 55, 89, 144]])1a的值变化后，会导致原数组跟着变化。 arr4array([[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12]])1ndim 返回数组的维数 arr4.ndim21size 返回数组元素的个数 arr4.size121T 返回数组的转置结果 arr4.Tarray([[ 1, 5, 9], [ 2, 6, 10], [ 3, 7, 11], [ 4, 8, 12]])12345注： 如果数组的数据类型为复数的话，real方法可以返回复数的实部，imag方法返回复数的虚部### 数组函数reshape()函数和resize()函数可以重新设置数组的行数和列数： arr5 = np.array(np.arange(24))arr5array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,17, 18, 19, 20, 21, 22, 23])a = arr5.reshape(4,6)aarray([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]])1通过reshape函数将一维数组设置为二维数组，且为4行6列的数组。 a.resize(6,4)aarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]])123456通过resize函数会直接改变原数组的形状。### 数组元素的获取#### 一维数组元素通过索引和切片的方式获取数组元素，一维数组元素的获取与列表、元组的获取方式一样： arr7 = np.array(np.arange(10))arr7array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])1获取第4个元素 arr7[3]31获取前3个元素 arr7[:3]array([0, 1, 2])1获取第4个元素即之后的所有元素 arr7[3:]array([3, 4, 5, 6, 7, 8, 9])1获取末尾的2个元素 arr7[-2:]array([8, 9])1从第1个元素开始，获取步长为2的所有元素 arr7[::2]array([0, 2, 4, 6, 8])12#### 二维数组元素 arr8 = np.array(np.arange(12)).reshape(3,4)arr8array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])1返回数组的第2行 arr8[1]array([4, 5, 6, 7])1返回数组的前2行 arr8[:2]array([[0, 1, 2, 3], [4, 5, 6, 7]])1返回指定的第1行和第3行 arr8[[0,2]]array([[ 0, 1, 2, 3], [ 8, 9, 10, 11]])1返回数组的第1列 arr8[:,0]array([0, 4, 8])1返回数组的后2列 arr8[:,2:]array([[ 2, 3], [ 6, 7], [10, 11]])1返回数组的第1列和第3列 arr8[:,[0,2]]array([[ 0, 2], [ 4, 6], [ 8, 10]])1返回数组中第2行第3列对应的元素 arr8[1,2]61234#### 布尔索引布尔索引，即索引值为True和False，需要注意的是布尔索引必须输数组对象。 log = np.array([True,False,False,True,True,False])arr9 = np.array(np.arange(24)).reshape(6,4)arr9array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]])1返回所有为True的对应行 arr9[log]array([[ 0, 1, 2, 3], [12, 13, 14, 15], [16, 17, 18, 19]])1通过负号筛选出所有为False的对应行 arr9[-log]array([[ 4, 5, 6, 7], [ 8, 9, 10, 11], [20, 21, 22, 23]]) 1举一个场景，一维数组表示区域，二维数组表示观测值，如何选取目标区域的观测？ area = np.array([‘A’,’B’,’A’,’C’,’A’,’B’,’D’])areaarray([‘A’, ‘B’, ‘A’, ‘C’, ‘A’, ‘B’, ‘D’], dtype=’|S1’)observes = np.array(np.arange(21)).reshape(7,3)observesarray([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11], [12, 13, 14], [15, 16, 17], [18, 19, 20]])1返回所有A区域的观测。 observes[area == ‘A’]array([[ 0, 1, 2], [ 6, 7, 8], [12, 13, 14]])1返回所有A区域和D区域的观测。#条件值需要在&amp;(and),|(or)两端用圆括号括起来 observes[(area == ‘A’)|(area == ‘D’)]array([[ 0, 1, 2], [ 6, 7, 8], [12, 13, 14], [18, 19, 20]])12布尔索引也可以与普通索引或切片混合使用：返回A区域的所有行，且只获取第1列与第3列数据。 observes[area == ‘A’][:,[0,2]]array([[ 0, 2], [ 6, 8], [12, 14]])123#### 花式索引花式索引：实际上就是将数组作为索引将原数组的元素提取出来 arr10 = np.arange(1,29).reshape(7,4)arr10array([[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16], [17, 18, 19, 20], [21, 22, 23, 24], [25, 26, 27, 28]])1按照指定顺序返回指定行 arr10[[4,1,3,5]]array([[17, 18, 19, 20], [ 5, 6, 7, 8], [13, 14, 15, 16], [21, 22, 23, 24]])1返回指定的行与列 arr10[[4,1,5]][:,[0,2,3]]array([[17, 19, 20], [ 5, 7, 8], [21, 23, 24]])arr10[[4,1,5],[0,2,3]]array([17, 7, 24])1234### 数组运算#### 四则 a = np.array([1,2])b= np.array([3,4])print a+b12#### 根号和指数 import numpy as npa = np.array([1,2])print np.sqrt(a)print np.exp(a)print np.square(a)print np.power(a,5)print a 5 #可以用Power也可以直接 ,当然这么写比较爽Output:[ 1. 1.41421356][ 2.71828183 7.3890561 ][1 4][ 1 32][ 1 32] 12#### 数组最大最小值 import numpy as npa = np.arange(20).reshape(4,5)print aprint a.min()print a.max()print a.sum()print a.min(axis=0) #minimun element in each columnprint a.min(axis=1) #minimun element in each row12#### 数组的均值/中位数 import numpya =range(5) +[1000]print aprint numpy.mean(a),numpy.median(a)12345678### 矩阵对象&gt;矩阵对象和数组的主要有两点差别：矩阵是二维的，而数组的可以是任意正整数维矩阵的*操作符进行的是矩阵乘法，乘号左侧的矩阵列和乘号右侧的矩阵行要相等，而在数组中*操作符进行的是每一元素的对应相乘，乘号两侧的数组每一维大小需要一致#### 数组转矩阵 a = np.ones(4)np.asmatrix(a)np.mat(np.ones((2,4)))np.mat(np.random.rand(2,2))12#### 逆矩阵 arr_mat_i = arr_mat.I12#### 矩阵乘法 arr_mat * arr_mat_i12#### eye函数 np.eye(4) array([[ 1., 0., 0., 0.], [ 0., 1., 0., 0.], [ 0., 0., 1., 0.], [ 0., 0., 0., 1.]])12#### 矩阵最大值索引 import numpy as np a = np.array([[1,4,6,9,10],[3,6,2,8,12]]) a = a.flatten()#多维变1维度print type(a)print np.argmax(a) print aprint a.reshape(2,5)#再变回来12#### 矩阵行相加 X.toarray().sum(axis=0) #行X.toarray().sum() #所有元素 ```]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git库使用进阶]]></title>
    <url>%2F2017%2F12%2F20%2F2017%2Fgit%E5%BA%93%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Git在存储数据的时候，存储的都是完整的对象，并不是差异，叫做松散对象Loose Object，有时候你只改变了一点，但是同时会拥有近乎两倍大小的blob对象。这样子做岂不是很不节省磁盘？所以Git会在每次push到远程的时候进行garbage collect操作，当然我们也可以自己手动改进行gc，如：git gcCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (6/6), done.Total 6 (delta 0), reused 0 (delta 0) 然后查看一下.git/objects下有哪些文件：find .git/objects -type f发现多了一些pack文件：.git/objects/info/packs.git/objects/pack/pack-abcde.idx.git/objects/pack/pack-abcde.pack当然也还有可能还有一些dangling的对象，这些对象是没有被其它引用的对象，git不会对其进行pack。.pack文件存储了所有删除的对象， .idx文件是索引文件，存储相应的偏移信息。 我们可以使用verify-pack命令显示pack的信息：git verify-pack -v .git/objects/pack/pack-abcde.idxa35a7ea3f7b55be91743c708d150b573116515ec commit 239 160 12fb1c75a143de21f30004dab829b39f99d225d292 commit 187 128 172ca2b7d42454d33b31cfc810592e8bd47f811decd tree 70 76 300fd5d73ef7deb282cbf47826c58448597f24453ba blob 18 28 37656166dc42a6a2f694e088694a2a2c90606e28f2d blob 16 23 4044e1ba2916b4b903d2e5a2209cdcca7129a891c2f tree 36 46 427non delta: 6 objectsobjects/pack/pack-83c7f603b25c063accec33ee8869a6afb1e9fd0a.pack: ok 第一列显示对象的指针，即Hash值，第二列展示是什么类型的对象，第三列展示占用了多少字节。 1/usr/bin/git filter-branch --force --index-filter &quot;/usr/bin/git rm --cached --ignore-unmatch JDMobile_2.0/Classes/Sections/BrickPlatForm/ViewController/BrickPFItemViewController.m&quot; --prune-empty --tag-name-filter cat -- --all git提交压缩git gc --prune=now 删除taggit tag | xargs git tag -d 一键瘦身代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#!/usr/bin/env python#coding:utf-8import os,sys,shutil,timedef checksize(): systemPath = os.environ[&apos;HOME&apos;] if os.path.exists(systemPath + &apos;/.gitthin&apos;): pass else: tagetPath = systemPath + &apos;/.gitthin&apos; os.system(&apos;mkdir &apos; + tagetPath) if os.path.exists(&apos;.git&apos;) == False: print &apos;do not have .git&apos; sys.exit(1) fileLogPath = systemPath + &apos;/.gitthin/file_log&apos; if os.path.exists(fileLogPath): os.system(&apos;rm -rf fileLogPath&apos;) os.system(&apos;git rev-list --objects --all &gt;&gt; &apos; + fileLogPath) # print &apos;createNew &apos; + fileLogPath packLogPath = systemPath + &apos;/.gitthin/pack_log&apos; if os.path.exists(packLogPath): print packLogPath + &apos; exits&apos; else: os.system(&apos;git verify-pack -v .git/objects/pack/*.idx &gt;&gt; &apos; + packLogPath) print &apos;createNew &apos; + packLogPath outputlist = os.popen(&apos;sort -k 3 -n %s | tail -10&apos; % packLogPath).read().split(&apos;\n&apos;) outputlist = list(reversed(outputlist)) for item in outputlist: if len(item) &gt; 0: items = item.split(&apos; &apos;) hashstring = items[0] filesize = items[4] filename = os.popen(&apos;grep %s %s&apos; % (hashstring, fileLogPath)).read() print filename.split(&apos;\n&apos;)[0],&apos; &apos;,filesizecommand = &apos;&apos;filename = &apos;&apos;if (len(sys.argv)) &gt; 1: command = sys.argv[1] else: print &apos;请输入参数&apos; sys.exit(1)if command == &apos;checksize&apos;: checksize()elif command == &apos;reset&apos;: systemPath = os.environ[&apos;HOME&apos;] thinpath = systemPath + &apos;/.gitthin&apos; if os.path.exists: os.system(&apos;rm -rf %s&apos; % thinpath)elif command == &apos;rewrite&apos;: if len(sys.argv) &gt; 2: filename = sys.argv[2] print &apos;\033[1;31m&apos; + &apos;请确认当前为最新分支&apos; + &apos;\033[0m&apos; else: print &apos;请输入文件名&apos; sys.exit(1) systemPath = os.environ[&apos;HOME&apos;] copyfilePath = systemPath + &apos;/.gitthin/&apos; + filename.split(&apos;/&apos;)[-1] copyfilePath = copyfilePath.replace(&apos;\n&apos;,&apos;&apos;) if os.path.exists(copyfilePath): os.system(&apos;rm -rf &apos; + copyfilePath) filenamePath = os.popen(&apos;find . -name &apos; + filename.split(&apos;/&apos;)[-1]).read().replace(&apos;\n&apos;,&apos;&apos;) copyString = &apos;cp -R %s %s&apos; % (filenamePath,copyfilePath) os.system(copyString) os.system(&apos;/usr/bin/git filter-branch --force --index-filter &quot;/usr/bin/git rm --cached --ignore-unmatch %s&quot; --prune-empty --tag-name-filter cat -- --all&apos; % filename) os.system(&apos;cp -R %s %s&apos; % (copyfilePath,filenamePath)) text = os.popen(&apos;git diff&apos;).read() print &apos;text&apos; + text if len(text) &gt; 0: os.system(&apos;git add .&apos;) os.system(&apos;git commit -m &quot;git库瘦身，还原文件&quot;&apos;) elif command == &apos;--h&apos;: print &apos;\033[1;31m&apos; + &apos;thingit checksize&apos; + &apos;\033[0m&apos; print &apos;\033[1;34m&apos; + &apos;检查排名前十的大文件&apos; + &apos;\033[0m&apos; print &apos;\033[1;31m&apos; + &apos;thingit rewrite filename&apos; + &apos;\033[0m&apos; print &apos;\033[1;34m&apos; + &apos;删除大文件提交&apos; + &apos;\033[0m&apos; print &apos;\033[1;31m&apos; + &apos;thingit reset&apos; + &apos;\033[0m&apos; print &apos;\033[1;34m&apos; + &apos;初始化环境&apos; + &apos;\033[0m&apos;]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongo日常命令记录]]></title>
    <url>%2F2017%2F12%2F18%2F2018%2Fpymongo%2F</url>
    <content type="text"><![CDATA[mongo常用mongo命令行12345mongo jrappcomment:jrappcomment@xxxxxx:27017/jrappcomment?authSource=jrappcomment //连接远程数据库mongoexport -h xxxxxx --port 27017 -d jrappcomment -u jrappcomment -p jrappcomment -c jrcommentcategory -o goods2.json //导出mongoimport -h xxxxxx --port 27017 -d jrappcomment -u jrappcomment -p jrappcomment -c cachecomment --file goods2.json//导入 db.stats() show dbs show tables show collections db.collection.totalIndexSize() db.collection.totalSize() db.jrcomment.ensureIndex({id:1}) //mongo建立索引 pymongo远程连接数据库12dbs = comment.find(&#123;&#125;).sort([(&apos;datetime&apos;,1),(&apos;created_time&apos;,1)]).limit(10000)print type(list(dbs)) 12345678910111213141516171819202122232425import os, time, json ,sysfrom pymongo import MongoClientimport urllibusername = urllib.quote_plus(&apos;jrappcomment&apos;)password = urllib.quote_plus(&apos;jrappcomment&apos;)client = MongoClient(&apos;mongodb://%s:%s@xxxxxx:27017/jrappcomment?authSource=jrappcomment&apos; % (username, password))# client = MongoClient(&quot;mongodb://172.25.60.48:27017&quot;)# client.adb.authenticate(username, password, mechanism=&apos;SCRAM-SHA-1&apos;)# client = MongoClient(&apos;mongodb://jrappcomment:jrappcomment@172.25.60.48:27017/&apos;)db = client.jrappcommentcomment = db.Commentcomment.insert(&#123;&apos;name&apos;:&apos;ceshi&apos;&#125;)dbs = comment.find(&#123;&#125;)print dbsfor item in dbs: print &apos;ceshi&apos; print item pymongo常用命令1comment.update(&#123;&apos;name&apos;:&apos;hanshenghui&apos;&#125;,&#123;&apos;$set&apos;:&#123;&apos;age&apos;:30&#125;&#125;) 不等于1&#123; x : &#123; $ne : 3 &#125; &#125;]]></content>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos6配置]]></title>
    <url>%2F2017%2F12%2F15%2F2017%2Fcentos6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[首先需要python环境为2.7以上版本 需要yum版本为3.4.3及以上，因为这样才能安装httpd为2.4版本及以上 安装Djangosudo pip install --upgrade django==1.11 安装numpysudo pip install numpy 安装pymongsudo pip install pymongo lunix 安装apxs扩展yum install httpd-devel安装mod-wsgi需要 安装mod_wsgisudo pip install mod_wsgiDjango需要 安装mod_wsgisudo yum install mod_wsgi这个模块会出现在./usr/lib64/httpd/modules/mod_wsgi.so这里 使用rz/sz来上传或者下载文件yum install lrzsz 手动安装apache下载文件 Apache HTTP Server 截止目前为止，Apache HTTP Server 目前最新的版本是 Apache httpd 2.4.6 Released， 下载地址：http://httpd.apache.org/download.cgi#apache24 APR and APR-Util包 截止目前为止，APR and APR-Util的最新版本如下，下载地址：http://apr.apache.org/download.cgi APR 1.4.8, released June 21, 2013APR-util 1.5.2, released April 4, 2013APR-iconv 1.2.1, released November 26, 2007 PCRE包 截止目前为止，PCRE最新的包为8.33，下载地址如下 https://sourceforge.net/projects/pcre/files/pcre/ 安装方法 1：安装包gcc或gcc-c++yum install gcc-c++ 2:安装develyum install expat-devel 3:安装apr mkdir /usr/local/apr ./configure --prefix=/usr/local/apr make &amp;&amp; sudo make install 4:安装apr-util mkdir /usr/local/apr-util ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr/bin/apr-1-config make &amp;&amp; sudo make install 5:安装pcre mkdir /usr/local/pcre ./configure --prefix=/usr/local/pcre --with-apr=/usr/local/apr/bin/apr-1-config make &amp;&amp; sudo make install 6:安装apache ./configure --prefix=/usr/local/apache --with-pcre=/usr/local/pcre --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util make &amp;&amp; sudo make install 6:将apachectl软链接到/usr/sbin/apachectl这个路径下 7:httpd也要软链到/usr/sbin/下 8:安装mod_wsgi https://github.com/GrahamDumpleton/mod_wsgi/releases这个地址下载 tar –zxvf mod_wsgi-3.4.tar.gz ./configure --with-apxs=/usr/local/apache/bin/apxs --with-python=/usr/bin/python make &amp;&amp; make install chmod 755 /usr/local/apache/modules/mod_wsgi.so apache配置 apache路径/etc/httpd/conf 重启 Apache：1service httpd restart pip配置123[global]trusted-host = 10.13.8.31index-url = http://10.13.8.31/simple/ 错误error while loading shared libraries: libpython2.7.so.1.0: cannot open shared object file: No such file or directorysudo find . -name libpython2.7.so.1.0找到路径，然后加入下边的文件 vi /etc/ld.so.conf加入新行1/export/python/lib 运行sudo ldconfig]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-set的用法]]></title>
    <url>%2F2017%2F11%2F22%2F2018%2Fpython-set%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[python的set和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算. sets 支持 x in set, len(set),和 for x in set。作为一个无序的集合，sets不记录元素位置或者插入点。因此，sets不支持 indexing, slicing, 或其它类序列（sequence-like）的操作。 下面来点简单的小例子说明把。1234x = set(&apos;spam&apos;) y = set([&apos;h&apos;,&apos;a&apos;,&apos;m&apos;]) x, y (set([&apos;a&apos;, &apos;p&apos;, &apos;s&apos;, &apos;m&apos;]), set([&apos;a&apos;, &apos;h&apos;, &apos;m&apos;])) 再来些小应用。 x &amp; y # 交集 set([&apos;a&apos;, &apos;m&apos;]) x | y # 并集 set([&apos;a&apos;, &apos;p&apos;, &apos;s&apos;, &apos;h&apos;, &apos;m&apos;]) x - y # 差集 set([&apos;p&apos;, &apos;s&apos;]) 记得以前个网友提问怎么去除海量列表里重复元素，用hash来解决也行，只不过感觉在性能上不是很高，用set解决还是很不错的，示例如下： a = [11,22,33,44,11,22] b = set(a) set([33, 11, 44, 22]) c = [i for i in b] c [33, 11, 44, 22] 很酷把，几行就可以搞定。 1.8 集合 集合用于包含一组无序的对象。要创建集合，可使用set()函数并像下面这样提供一系列的项： s = set([3,5,9,10]) #创建一个数值集合 t = set(“Hello”) #创建一个唯一字符的集合 与列表和元组不同，集合是无序的，也无法通过数字进行索引。此外，集合中的元素不能重复。例如，如果检查前面代码中t集合的值，结果会是：tset([‘H’, ‘e’, ‘l’, ‘o’]) 注意只出现了一个’l’。 集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如： a = t | s # t 和 s的并集 b = t &amp; s # t 和 s的交集 c = t – s # 求差集（项在t中，但不在s中） d = t ^ s # 对称差集（项在t或s中，但不会同时出现在二者中） 基本操作： t.add(‘x’) # 添加一项 s.update([10,37,42]) # 在s中添加多项 使用remove()可以删除一项： t.remove(‘H’) len(s)set 的长度 x in s测试 x 是否是 s 的成员 x not in s测试 x 是否不是 s 的成员 s.issubset(t)s &lt;= t测试是否 s 中的每一个元素都在 t 中 s.issuperset(t)s &gt;= t测试是否 t 中的每一个元素都在 s 中 s.union(t)s | t返回一个新的 set 包含 s 和 t 中的每一个元素 s.intersection(t)s &amp; t返回一个新的 set 包含 s 和 t 中的公共元素 s.difference(t)s - t返回一个新的 set 包含 s 中有但是 t 中没有的元素 s.symmetric_difference(t)s ^ t返回一个新的 set 包含 s 和 t 中不重复的元素 s.copy()返回 set “s”的一个浅复制 请注意：union(), intersection(), difference() 和 symmetric_difference() 的非运算符（non-operator，就是形如 s.union()这样的）版本将会接受任何 iterable 作为参数。相反，它们的运算符版本（operator based counterparts）要求参数必须是 sets。这样可以避免潜在的错误，如：为了更可读而使用 set(‘abc’) &amp; ‘cbs’ 来替代 set(‘abc’).intersection(‘cbs’)。从 2.3.1 版本中做的更改：以前所有参数都必须是 sets。 另外，Set 和 ImmutableSet 两者都支持 set 与 set 之间的比较。两个 sets 在也只有在这种情况下是相等的：每一个 set 中的元素都是另一个中的元素（二者互为subset）。一个 set 比另一个 set 小，只有在第一个 set 是第二个 set 的 subset 时（是一个 subset，但是并不相等）。一个 set 比另一个 set 打，只有在第一个 set 是第二个 set 的 superset 时（是一个 superset，但是并不相等）。 子 set 和相等比较并不产生完整的排序功能。例如：任意两个 sets 都不相等也不互为子 set，因此以下的运算都会返回 False：ab。因此，sets 不提供 cmp 方法。 因为 sets 只定义了部分排序功能（subset 关系），list.sort() 方法的输出对于 sets 的列表没有定义。 运算符 运算结果 hash(s) 返回 s 的 hash 值 下面这个表列出了对于 Set 可用二对于 ImmutableSet 不可用的运算： 运算符（voperator）等价于运算结果 s.update(t)s |= t返回增加了 set “t”中元素后的 set “s” s.intersection_update(t)s &amp;= t返回只保留含有 set “t”中元素的 set “s” s.difference_update(t)s -= t返回删除了 set “t”中含有的元素后的 set “s” s.symmetric_difference_update(t)s ^= t返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s” s.add(x) 向 set “s”中增加元素 x s.remove(x) 从 set “s”中删除元素 x, 如果不存在则引发 KeyError s.discard(x) 如果在 set “s”中存在元素 x, 则删除 s.pop() 删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError s.clear() 删除 set “s”中的所有元素 请注意：非运算符版本的 update(), intersection_update(), difference_update()和symmetric_difference_update()将会接受任意 iterable 作为参数。从 2.3.1 版本做的更改：以前所有参数都必须是 sets。 还请注意：这个模块还包含一个 union_update() 方法，它是 update() 方法的一个别名。包含这个方法是为了向后兼容。程序员们应该多使用 update() 方法，因为这个方法也被内置的 set() 和 frozenset() 类型支持。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac-Vim使用教程]]></title>
    <url>%2F2017%2F11%2F11%2F2018%2FMac-Vim%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[各种光标移动w 跳到下一个字首，按标点或单词分割W 跳到下一个字首，长跳，如end-of-line被认为是一个字e 跳到下一个字尾E 跳到下一个字尾，长跳b 跳到上一个字B 跳到上一个字，长跳0 跳至行首，不管有无缩进，就是跳到第0个字符 n+ 移n行行首n- 移n行行首n$ 移n行(1表示本行)行尾0 所行行首$ 所行行尾^ 所行首字母h,j,k,l 左移移移右移H 前屏幕首行行首M 屏幕显示文件间行行首L 前屏幕底行行首 各种删除dG 删除至文章结尾部d1G 删除至文章开头部2dd 删除两行dd 删除光标所在行dw 删除一个字(word)不适合中文x 删除当前字符10x 删除十个连续字符X 删除前一个字符D 删除到行末 复制粘贴yy 复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行yw 复制一个字y$ 复制到行末p 粘贴粘贴板的内容到当前行的下面P 粘贴粘贴板的内容到当前行的上面]p 有缩进的粘贴，vim会自动调节代码的缩进“a 将内容放入/存入a寄存器，可以支持多粘贴板附：比如常用的一个寄存器就是系统寄存器，名称为+，所以从系统粘贴板粘贴到vim中的命令为”+p,注意此处的+不表示操作符，二十一个寄存器。移动光标在vim中移动光标跟其他的编辑器中有很大的区别，不过一旦学会了，就会飞速的在文本中移动了。 光标快速移动gg快速移动到头部G快速移动到尾部10G移动到第十行 显示行号:set number 永久显示行号: $vi ~/.vimrc往文件里面添加内容： set number , 保存退出。 行内光标跳转 w当前单词开头 e当前单词末尾 b前一个单词开头 ge前一个单词末尾 o/^行开始 $行末尾 f&lt;name&gt;向后搜索并且跳转到该字母 F&lt;name&gt;向前搜索并且跳转到该字母 查找/name开始进行查找name，然后输入n继续向下查找，输入N继续向上查找]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux入门]]></title>
    <url>%2F2017%2F11%2F09%2F2018%2Flunix%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[查看linux版本 lsb_release -a Ctrl+a 移动到行初Ctrl+e 移动到行末Ctrl+k 删除从光标位置到行末Alts+backspace 向前删除一个单词ls *.txt显示所有的.txt结尾的文件touch love{1..10}.txt创建了十个文件touch today{name,hahm,ceshi}.txt创建了三个文件 用户相关who -a打印全部who -d打印死掉的进程who -m或者who am i当前登录用户who -q打印当前登录用户数以及用户名who -u打印当前登录用户登录信息who -r打印运行等级 sudo adduser username添加用户su -l username切换用户exit退出当前用户回到上一个用户 查看所有用户123cat /etc/passwd 可以查看所有用户的列表w 可以查看当前活跃的用户列表cat /etc/group 查看用户组 用户组groups han查看当前用户属于啥组1han : han //前边是用户，后边是组 chgrp -R 新建的用户会自动创建一个同名的组，注意这个新建的用户不在root用户组下边，那就意味着当你切换到han这个用户下边的时候，其实你是不能使用sudo的，那怎么将han添加到sudo下呢？sudo usermod -G root han添加han到用户组下边sudo deluser han --remove-home删除用户 权限ls -l -rw-r–r– 1 jrmacpro staff 0 11 9 09:12 love1.txt文件类型和权限 链接数 所有者 所有者用户组 文件大小 最后修改日期 文件名 我们来看看用户权限drwxr-xr-xdrwxr拥有者权限第一个-xr用户组权限第二个-x其他用户权限 r允许读w允许写x允许执行 文件类型：lunix中一切皆文件 文件权限： cat filename你可以使用这个命令来读 写表示你可以编辑和修改 执行权限通常指可以运行二进制程序文本或者脚本文件，一个目录同时具有读和执行权限你才可以打开并且查看内部文件，而一个目录要有写权限才能在其中创建其他文件 ls -lh直观查看文件大小 修改文件所有者 sudo chown hanshenghui filename改变文件所有者sudo chgrp apache project改变文件组 修改文件权限利用+和-chmod go-r filenameg/o/u分别代表group，others，user，上边那句的意思是说真对这个文件group和other去掉读权限 查看进程和杀进程1、先查看进程pid ps -ef | grep 进程名 2、通过pid查看占用端口 netstat -nap | grep 进程pid 123456789101112131415161718例：通过nginx进程查看对应的端口号查看nginx进程pid：命令：ps -ef | grep nginx结果：root 9836 1 0 Jul11 ? 00:00:00 nginx: master process /usr/local/nginx/sbin/nginxnobody 9841 9836 0 Jul11 ? 00:00:09 nginx: worker process 通过nginx进程pid查看占用端口（进程pid为9836）命令：netstat -nap | grep 9836结果：tcp 0 0 0.0.0.0:8081 0.0.0.0:* LISTEN 9836/nginx tcp 0 0 0.0.0.0:81 0.0.0.0:* LISTEN 9836/nginx tcp 0 0 0.0.0.0:8082 0.0.0.0:* LISTEN 9836/nginx tcp 0 0 0.0.0.0:8083 0.0.0.0:* LISTEN 9836/nginx 复制代码 3.杀进程sudo kill -9 pid 文件和目录 tree使用这个命令查看目录结构 ls -a查看隐藏文件 cd ~home cd ..上一级 pwd当前路径 cd ..上一层目录 cp test /opt/test把test复制到opt下边的test cp -r test /opt/test把test这个文件夹复制到opt下，递归复制 rm filename rm -f filename忽略权限，强制删除 rm -r direction递归删除 mv file1 file2把file1移动到file2，或者说是重命名 rename file1 file2将file1重命名为file2 查看文件 cat正序 tac倒序 nl带着编号 more/less head查看头十行 tail查看末尾几行 tail -f可以实现实时查看日志 file查看文件类型 环境变量和文件查找~.profile对当前用户生效/etc/profile所有用户生效 环境变量PATH介绍当我们在shell中输入一个命令的时候，它怎么知道去哪里寻找该执行哪个命令呢，这些路径就存在PATH中。 echo $PATH来查看1/usr/local/opt/swig@3.04/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin 添加自定义的PATHPATH=$PATH:/home/han/mybin注意这里一定要用绝对路径 文件压缩zip123zip -r -9 -q -o shiyanlou.zip /home/shiyanlou -x ~/*.zipdu -h shiyanlou.zipfile shiyanlou.zip -r递归压缩 -9/-1压缩级别-9压缩最厉害，-1最不厉害 -q静默，不输出到命令行 -o输出文件名字 du查看文件大小 unzipunzip -q ceshi.zip -d ceshiname解压然后解压后叫啥名字 tar压缩 tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux 解压 tar -xvf file.tar //解压 tar包 tar -xzvf file.tar.gz //解压tar.gz tar -xjvf file.tar.bz2 //解压 tar.bz2 tar -xZvf file.tar.Z //解压tar.Z unrar e file.rar //解压rar unzip file.zip //解压zip 磁盘相关df查看磁盘容量du 查看该目录du -h更简单的方式来查看 Linux任务计划crontabcrontab -e然后进入到了一个文件在这个文件中添加任务1*/1 * * * * * python /Users/jrmacpro/Desktop/ceshi.py &gt;&gt; /Users/jrmacpro/Desktop/log.txt 一共有五个*分别代表：分，小时，几号，月份，星期几 &gt;在以上各个字段中，还可以使用以下特殊字符：&gt; 星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 sudo cron -f &amp; 启动守护进程，我们的设置才能生效 使用实例： 实例1：每1分钟执行一次command命令： command 实例2：每小时的第3和第15分钟执行命令：3,15 * * * * command 实例3：在上午8点到11点的第3和第15分钟执行命令：3,15 8-11 * * * command 实例4：每隔两天的上午8点到11点的第3和第15分钟执行命令：3,15 8-11 */2 * * command 实例5：每个星期一的上午8点到11点的第3和第15分钟执行命令：3,15 8-11 * * 1 command 实例6：每晚的21:30重启smb命令：30 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb命令：45 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb命令：10 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb命令：0,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb命令：0 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb命令：* */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb命令：* 23-7/1 * * * /etc/init.d/smb restart 实例13：每月的4号与每周一到周三的11点重启smb命令：0 11 4 * mon-wed /etc/init.d/smb restart 实例14：一月一号的4点重启smb命令：0 4 1 jan * /etc/init.d/smb restart 实例15：每小时执行/etc/cron.hourly目录内的脚本命令：01 * * * * root run-parts /etc/cron.hourly说明：run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了 实例16：以时间命名01 * * * * touch $(date +%Y-%m-%d) crontab设置123456789101112131415161718191. 确认crontab是否安装：执行 crontab 命令如果报 command not found，就表明没有安装2. 安装 crontab执行 yum install -y vixie-cron3. 确认是否安装成功:执行 crontab -l4. 看是否设置了开机自动启动chkconfig --list crond5. 启动crontabservice crond start 看日志 /var/log/cron.log这个文件就可以，可以用tail -f /var/log/cron.log观察 命令执行顺序和管道多命令一起输入选择性执行which git &amp;&amp; echo &#39;YES&#39; || echo &#39;NO&#39;这段话的意思是如果git存在就输出YES，否则输出NOecho $?查看程序执行结果 管道将前一个命令的输出作为后一个命令的输入，以|作为表示符。ls -la /etc | less这个时候前一个命令输出了好多，无所谓我可以用less来一行一行的看 grep在文本中查找匹配关键字 wc计数工具wc -l filename文件行数wc -w filename单词数wc -c filename字节数wc -m filename字符数wc -L filename最长行字节数 sortcat /etc/passwd | sort -r反序 cutcut -f 1-3 text.txtcut -f -3 text.txtcut -f 3- text.txt 文本处理join file1 file2将行相同的合并在一起paste file1 file2直接合并 重定向echo &#39;hi&#39; &gt;&gt; text.txtecho &#39;hi&#39; | tee text.txt多向重定向 下载wget http://xxxx]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习学习路径]]></title>
    <url>%2F2017%2F11%2F07%2F2018%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[机器学习解决的问题并非所有的问题都适合用机器学习解决(很多逻辑清晰的问题用规则能很高效和准确地处理)，也没有一个机器学习算法可以通用于所有问题。咱们先来了解了解，机器学习，到底关心和解决什么样的问题。从功能的角度分类，机器学习在一定量级的数据上，可以解决下列问题： 分类问题 根据数据样本上抽取出的特征，判定其属于有限个类别中的哪一个。比如： - 垃圾邮件识别(结果类别：1、垃圾邮件 2、正常邮件) - 文本情感褒贬分析(结果类别：1、褒 2、贬) - 图像内容识别识别(结果类别：1、喵星人 2、汪星人 3、人类 4、草泥马 5、都不是)。 回归问题 根据数据样本上抽取出的特征，预测一个连续值的结果。比如： - 星爷《美人鱼》票房 - 大帝都2个月后的房价 - 隔壁熊孩子一天来你家几次，宠幸你多少玩具 聚类等问题 根据数据样本上抽取出的特征，让样本抱抱团(相近/相关的样本在一团内)。比如： - google的新闻分类 - 用户群体划分 我们再把上述常见问题划到机器学习最典型的2个分类上。 分类与回归问题需要用已知结果的数据做训练，属于“监督学习” 聚类的问题不需要已知标签，属于“非监督学习”。 如果在IT行业(尤其是互联网)里溜达一圈，你会发现机器学习在以下热点问题中有广泛应用： 1.计算机视觉 典型的应用包括：人脸识别、车牌识别、扫描文字识别、图片内容识别、图片搜索等等。 2.自然语言处理 典型的应用包括：搜索引擎智能匹配、文本内容理解、文本情绪判断，语音识别、输入法、机器翻译等等。 3.社会网络分析 典型的应用包括：用户画像、网络关联分析、欺诈作弊发现、热点发现等等。 4.推荐 典型的应用包括：虾米音乐的“歌曲推荐”，某宝的“猜你喜欢”等等。 基础知识阶段1：入门知识 Lunix基础入门 Vim入门 阶段2: 机器学习理论这部分主要是要掌握一些典型的机器学习算法，如分类、聚类、推荐、概率图、神经网络。（可以分为初级、中级和高级三个阶段，每个阶段的侧重点不同。） 初级阶段初级阶段推荐可以看《机器学习算法原理与编程实践 》和《机器学习实战》这两本书。 这两本书更偏向于算法的应用方面，学习起来相对轻松一些。如果一上来直接就啃那些纯算法理论，估计很多人是坚持不下去的。 再者，一个东西，当你还不知道它是什么，有什么用，以及怎么用时，让你去硬着头皮啃，你一定会感觉很郁闷，并且根本不可能能够深入理解那些理论。 所以，个人强烈建议不要一上来就贪图那些算法理论的推导，先大胆的去了解各个算法的应用场合并尝试着应用，这对你入门机器学习是一个非常好的选择。 中级阶段中级阶段就要开始啃那些算法背后的理论了，前面应用是知其然，现在要开始知其所以然。 这个阶段重点推荐看林轩田的《机器学习基石》和《机器学习技法》视频，总共三十二课，每一课都相当精彩，细致学下来需要三个月，我指的是细致的看，每一课都应该写笔记，梳理脉络，强烈建议做笔记。 踏踏实实看完，面试中让你推个svm讲讲adboost，gbdt原理基本就是手到擒来，再辅以李航的《统计学习方法》和周志华的《机器学习》（俗称“西瓜书”）查漏补缺，基础就算比较扎实了。 高级阶段高级阶段就是要自己开始去灵活运用并组合各个算法了。这个阶段可以在网上找一些比较典型的项目来进行实战演练。 推荐学习资源：Kaggle、CCF、Datacastle、阿里云天池等。 kaggle是国外一个专门做数据挖掘比赛的地方，里面很多比赛比较适合新人，而且里面的氛围也比较好，每个比赛都有对应的论坛，时不时有人会发布自己的代码，大家集思广益一起讨论，可以学到很多。 如果你觉得上面的内容对你有帮助，或者你想要进一步了解和学习数据挖掘和机器学习等知识，欢迎关注我们的微信公众号“DT新纪元”。 【另外说明一下，我个人平时有广泛阅读和摘录经典的习惯，但有时可能由于时间久远不知道原文出处了，造成自己的文章中部分内容跟某些作者有重合和相似的，请您给我留言，我会及时做出改正，谢谢！目前确认的是此篇文章中的数据分析部分应该是在@秦路 某篇文章的基础上更改的，在此特别表示说明与感谢！】 阶段3:基础项目 人机对战初体验:Python基于Pygame实现四子棋游戏 Python 实现英文新闻摘要自动提取 使用 Python 实现深度神经网络 使用卷积神经网络进行图片分类 基于卷积神经网络实现图片风格的迁移 阶段4: 进阶项目 Python应用马尔可夫链算法实现随机文本生成 神经网络实现人脸识别任务 基于无监督学习的自编码器实现 NBA常规赛结果预测——利用Python进行比赛数据分析 Python 气象数据分析 – 《Python 数据分析实战》 Twitter数据情感分析 ebay在线拍卖数据分析 大数据带你挖掘打车的秘籍 使用 Spark 和 D3.js 分析航班大数据 基本工作流程以上我们基本具备了机器学习的必要条件，剩下的就是怎么运用它们去做一个完整的机器学习项目。其工作流程如下: 抽象成数学问题 明确问题是进行机器学习的第一步。机器学习的训练过程通常都是一件非常耗时的事情，胡乱尝试时间成本是非常高的。这里的抽象成数学问题，指的我们明确我们可以获得什么样的数据，目标是一个分类还是回归或者是聚类的问题，如果都不是的话，如果划归为其中的某类问题。 获取数据 数据决定了机器学习结果的上限，而算法只是尽可能逼近这个上限。数据要有代表性，否则必然会过拟合。而且对于分类问题，数据偏斜不能过于严重，不同类别的数据数量不要有数个数量级的差距。而且还要对数据的量级有一个评估，多少个样本，多少个特征，可以估算出其对内存的消耗程度，判断训练过程中内存是否能够放得下。如果放不下就得考虑改进算法或者使用一些降维的技巧了。如果数据量实在太大，那就要考虑分布式了。 特征预处理与特征选择 良好的数据要能够提取出良好的特征才能真正发挥效力。特征预处理、数据清洗是很关键的步骤，往往能够使得算法的效果和性能得到显著提高。归一化、离散化、因子化、缺失值处理、去除共线性等，数据挖掘过程中很多时间就花在它们上面。这些工作简单可复制，收益稳定可预期，是机器学习的基础必备步骤。筛选出显著特征、摒弃非显著特征，需要机器学习工程师反复理解业务。这对很多结果有决定性的影响。特征选择好了，非常简单的算法也能得出良好、稳定的结果。这需要运用特征有效性分析的相关技术，如相关系数、卡方检验、平均互信息、条件熵、后验概率、逻辑回归权重等方法。 训练模型与调优 直到这一步才用到我们上面说的算法进行训练。现在很多算法都能够封装成黑盒供人使用。但是真正考验水平的是调整这些算法的（超）参数，使得结果变得更加优良。这需要我们对算法的原理有深入的理解。理解越深入，就越能发现问题的症结，提出良好的调优方案。 模型诊断 如何确定模型调优的方向与思路呢？这就需要对模型进行诊断的技术。 过拟合、欠拟合 判断是模型诊断中至关重要的一步。常见的方法如交叉验证，绘制学习曲线等。过拟合的基本调优思路是增加数据量，降低模型复杂度。欠拟合的基本调优思路是提高特征数量和质量，增加模型复杂度。误差分析 也是机器学习至关重要的步骤。通过观察误差样本，全面分析误差产生误差的原因:是参数的问题还是算法选择的问题，是特征的问题还是数据本身的问题……诊断后的模型需要进行调优，调优后的新模型需要重新进行诊断，这是一个反复迭代不断逼近的过程，需要不断地尝试， 进而达到最优状态。 模型融合 一般来说，模型融合后都能使得效果有一定提升。而且效果很好。工程上，主要提升算法准确度的方法是分别在模型的前端（特征清洗和预处理，不同的采样模式）与后端（模型融合）上下功夫。因为他们比较标准可复制，效果比较稳定。而直接调参的工作不会很多，毕竟大量数据训练起来太慢了，而且效果难以保证。 上线运行 这一部分内容主要跟工程实现的相关性比较大。工程上是结果导向，模型在线上运行的效果直接决定模型的成败。 不单纯包括其准确程度、误差等情况，还包括其运行的速度(时间复杂度)、资源消耗程度（空间复杂度）、稳定性是否可接受。这些工作流程主要是工程实践上总结出的一些经验。并不是每个项目都包含完整的一个流程。这里的部分只是一个指导性的说明，只有大家自己多实践，多积累项目经验，才会有自己更深刻的认识。 关于积累项目经验初学机器学习可能有一个误区，就是一上来就陷入到对各种高大上算法的追逐当中。动不动就我能不能用深度学习去解决这个问题啊？我是不是要用boosting算法做一些模型融合啊？我一直持有一个观点，『脱离业务和数据的算法讨论是毫无意义的』。 实际上按我们的学习经验，从一个数据源开始，即使是用最传统，已经应用多年的机器学习算法，先完整地走完机器学习的整个工作流程，不断尝试各种算法深挖这些数据的价值，在运用过程中把数据、特征和算法搞透，真正积累出项目经验 才是最快、最靠谱的学习路径。 那如何获取数据和项目呢？一个捷径就是积极参加国内外各种数据挖掘竞赛，数据直接下载下来，按照竞赛的要求去不断优化，积累经验。国外的Kaggle和国内的DataCastle 以及阿里天池比赛都是很好的平台，你可以在上面获取真实的数据和数据科学家们一起学习和进行竞赛，尝试使用已经学过的所有知识来完成这个比赛本身也是一件很有乐趣的事情。和其他数据科学家的讨论能开阔视野，对机器学习算法有更深层次的认识。 有意思的是，有些平台，比如阿里天池比赛，甚至给出了从数据处理到模型训练到模型评估、可视化到模型融合增强的全部组件，你要做的事情只是参与比赛，获取数据，然后使用这些组件去实现自己的idea即可。具体内容可以参见阿里云机器学习文档。 书籍推荐 Mitchell 的《机器学习》。Mitchell是机器学习的鼻祖，第一个提出机器学习概念的人。这本书很薄，很简单。内容很陈旧，但是都是机器学习的经典问题。而且，这本书概念清晰正确(很可贵啊，又简单又正确的书，说明作者功力很强)]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lunix切换防火墙]]></title>
    <url>%2F2017%2F11%2F06%2F2018%2Flunix%E5%88%87%E6%8D%A2%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[当然你可以还原传统的管理方式。 执行一下命令： 停止原来的防火墙模式 systemctl stop firewalld systemctl mask firewalld 并且安装iptables-services：yum install iptables-services 设置开机启动： systemctl enable iptables 12341. systemctl stop iptables 2. systemctl start iptables 3. systemctl restart iptables 4. systemctl reload iptables OK，再试一下应该就好使了 开放某个端口的两种方式直接编辑文件开放某个端口 在/etc/sysconfig/iptables里添加-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT vim /etc/sysconfig/iptables将上面的语句-A INPUT -p tcp -m state –state NEW -m tcp –dport 82 -j ACCEPT直接插入到上述文件中。 这时候规则是不生效的，需要重启服务service iptables restart。之后这条规则就永久生效了 用命令行添加添加input记录： iptables -A INPUT -p tcp –dport 22 -j ACCEPT添加output记录： iptables -A OUTPUT -p tcp –sport 22 -j ACCEPT 最后注意需要再执行一下 /etc/init.d/iptables save，这样这两条语句就保存到刚才那个/etc/sysconfig/iptables 文件中了 注意这两种方法二选一，不可同时使用]]></content>
      <tags>
        <tag>lunix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xcode自动创建结构化模版]]></title>
    <url>%2F2017%2F11%2F03%2F2018%2Fxcode%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E5%8C%96%E6%A8%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[下边这个路径下的文件，是可以被xcode加载，然后形成一个模版的，我们现在具体来看看&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/File Templates/JDJRCustom&quot;]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lunix-Centos7 scrapy实战]]></title>
    <url>%2F2017%2F11%2F02%2F2018%2FLunix-Centos7-scrapy%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[安装scrapy centos7上软件管理工具为yum而不是apt-get 安装scrapysudo pip install scrapy，这个时候可能报错，fatal error: Python.h: No such file or directory，这是因为缺少python-dev这个库，我们需要安装sudo yum install python-dev但是在centos7上会说找不到，是因为在该版本上不是python-dev而是python-devel 或者是使用另外一种方法 1234567891011root@localhost ~]# yum -y update安装gcc及扩展包[root@localhost ~]# yum install gcc libffi-devel python-devel openssl-devel安装开发工具包[root@localhost ~]# yum groupinstall -y development安装libxslt-devel支持lxml[root@localhost ~]# yum install libxslt-devel安装pip[root@localhost ~]# yum -y install python-pip安装Scrapy[root@localhost ~]# pip install scrapy 配置mongo安装环境及配置yum12345678910# more /etc/redhat-release CentOS Linux release 7.2.1511 (Core)# vi /etc/yum.repos.d/mongodb-org-3.2.repo [mongodb-org-3.2]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.2/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.2.asc 安装MongoDB1yum -y install mongodb-org 创建data文件和log文件并且启动 先在同级目录下创建数据文件和日志文件mkdir data和mkdir log 启动mongodb服务mongod –dbpath data –logpath log/mongod.log –logappend –fork 再次mongo如果显示connecting to test说明启动成功，输入exit;退出mongo Lunix长时间运行命令行方法使用screen 常用命令 screen -ls查看当前的screen screen -S screenname创建一个新的screen并且给命名，这个名字可以后期用以恢复screen control+a----&gt;d退出当前screen并且挂起 screen -r number/name进入某个screen 定时运行任务1234while True: print time.strftime(&apos;%Y-%m-%d %X&apos;,time.localtime()) yourTask() # 此处为要执行的任务 time.sleep(n) 输出到log直接用print来输出，正常在terminal运行就可以看到打印输出但是如果用下面这种方式来输出就会直接输出到log中python test.py &gt;&gt; test.log这样就print到logle Scrapy详解主要是三个文件 items.py pipelines.py xxx_spider.py(这个文件是自己创建的，在spiders这个文件夹下边) 下边分别说明文件以及其整体关系 xxx_spider.py1234567891011121314151617181920212223242526272829303132333435363738394041import scrapyimport jsonfrom tutorial.items import JdjrItem#这里倒入的是一个相当于ios中的model一样的东西，是定义于items.py这个文件class DmozSpider(scrapy.Spider): name = &quot;spider&quot;#这个名字相当重要，它是爬虫的唯一标示，你运行命令行的时候，它识别的也是这个名字，跟你外边文件叫啥没关系，跟你这个类叫啥也没有关系 allowed_domains = [&quot;itunes.apple.com&quot;] start_urls = [] start = 0 for i in range(0,2): end = start + 100 endString = &apos;%d&apos; % end startString = &apos;%d&apos; % start start = end + 1# url1 = &quot;https://itunes.apple.com/WebObjects/MZStore.woa/wa/userReviewsRow?id=895682747&amp;displayable-kind=11&amp;startIndex=%s&amp;endIndex=%s&amp;sort=1&amp;appVersion=all&quot; % (startString,endString) url2 = &quot;https://itunes.apple.com/WebObjects/MZStore.woa/wa/userReviewsRow?id=895682747&amp;displayable-kind=11&amp;startIndex=%s&amp;endIndex=%s&amp;sort=1&amp;appVersion=current&quot; % (startString,endString)# start_urls.append(url1) start_urls.append(url2)# start_urls = [# # &quot;https://itunes.apple.com/WebObjects/MZStore.woa/wa/userReviewsRow?id=895682747&amp;displayable-kind=11&amp;startIndex=0&amp;endIndex=50&amp;sort=1&amp;appVersion=cureent&quot;# # ,# &quot;https://itunes.apple.com/WebObjects/MZStore.woa/wa/userReviewsRow?id=895682747&amp;displayable-kind=11&amp;startIndex=0&amp;endIndex=50&amp;sort=1&amp;appVersion=all&quot;# ] def parse(self, response): sites = json.loads(response.body_as_unicode())#前边的url请求成功之后就是调用这个parse方法，这里的response的处理相当关键，但总结来看主要分为两种，一种是json，一种是html，这里举例的是json的处理方式 siteitems = sites[&apos;userReviewList&apos;] for item in siteitems: JrItem = JdjrItem() JrItem[&apos;userReviewId&apos;] = item[&apos;userReviewId&apos;].encode(&quot;utf-8&quot;) JrItem[&apos;body&apos;] = item[&apos;body&apos;].encode(&quot;utf-8&quot;) dateString = item[&apos;date&apos;].encode(&quot;utf-8&quot;) dateStringList = dateString.split(&apos;T&apos;) date = dateStringList[0] time = dateStringList[1] JrItem[&apos;date&apos;] = date JrItem[&apos;time&apos;] = time JrItem[&apos;name&apos;] = item[&apos;name&apos;].encode(&quot;utf-8&quot;) JrItem[&apos;rating&apos;] = item[&apos;rating&apos;] JrItem[&apos;title&apos;] = item[&apos;title&apos;].encode(&quot;utf-8&quot;) yield JrItem#我们把数据做一个解析，然后把数据装入我们的JrItem这个Model里边，进行返回，进行下一步的处理 pipelines.py这里是接收上一步yield JrItem的内容，然后进行进一步的处理，具体来讲就是我们初始化了mongo，然后把数据存入mongo 12345678910111213141516171819202122import pymongofrom scrapy.conf import settingsclass TutorialPipeline(object): def __init__(self):#在这里很重要的一步是我们初始化了mongo，然后把数据存入mongo # 链接数据库 self.client = pymongo.MongoClient(host=settings[&apos;MONGO_HOST&apos;], port=settings[&apos;MONGO_PORT&apos;]) # 数据库登录需要帐号密码的话 # self.client.admin.authenticate(settings[&apos;MINGO_USER&apos;], settings[&apos;MONGO_PSW&apos;]) self.db = self.client[settings[&apos;MONGO_DB&apos;]] # 获得数据库的句柄 self.coll = self.db[settings[&apos;MONGO_COLL&apos;]] # 获得collection的句柄 def process_item(self, item, spider): dbs = self.coll.find(&#123;&apos;userReviewId&apos;:item[&apos;userReviewId&apos;]&#125;) count = 0 for itemnew in dbs:#进行了一个去重 count = count + 1 if count == 0: postItem = dict(item) # 把item转化成字典形式 self.coll.insert(postItem) # 向数据库插入一条记录 return item item.py1234567891011import scrapyclass JdjrItem(scrapy.Item): # define the fields for your item here like: userReviewId = scrapy.Field() body = scrapy.Field() date = scrapy.Field() name = scrapy.Field() rating = scrapy.Field() title = scrapy.Field() time = scrapy.Field() 自定义header1234567891011121314151617181920212223242526272829303132333435363738394041class AppstoreSpider(scrapy.Spider): name = &quot;ios&quot; allowed_domains = [&quot;itunes.apple.com&quot;] start_urls = [] start = 0 for i in range(10,12): end = start + 100 endString = &apos;%d&apos; % end startString = &apos;%d&apos; % start start = end + 1 url1 = &quot;https://itunes.apple.com/WebObjects/MZStore.woa/wa/userReviewsRow?id=895682747&amp;displayable-kind=11&amp;startIndex=%s&amp;endIndex=%s&amp;sort=1&amp;appVersion=all&quot; % (startString,endString) url2 = &quot;https://itunes.apple.com/WebObjects/MZStore.woa/wa/userReviewsRow?id=895682747&amp;displayable-kind=11&amp;startIndex=%s&amp;endIndex=%s&amp;sort=1&amp;appVersion=current&quot; % (startString,endString) start_urls.append(url1) start_urls.append(url2) def start_requests(self): headers = &#123; &quot;Host&quot;: &quot;itunes.apple.com&quot;, &quot;X-Apple-Tz&quot;: &quot;28800&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Accept&quot;: &quot;*/*&quot;, &quot;X-Apple-Store-Front&quot;: &quot;143465-19,32&quot;, &quot;Proxy-Connection&quot;: &quot;keep-alive&quot;, &quot;If-Modified-Since&quot;: &quot;Mon, 30 Oct 2017 05:09:14 GMT&quot;, &quot;Accept-Language&quot;: &quot;zh-Hans;q=1.0, en;q=0.9&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;X-Apple-I-MD-RINFO&quot;: &quot;17106176&quot;, &quot;X-Apple-I-MD-M&quot;: &quot;4yta1gxLU2/1yorU7oVB982KDbxQfTgDNV0Kx6rMh83dcH6GSFvvMX4j2xTK1pydINZyrdPRmrAqnMrx&quot;, &quot;User-Agent&quot;: &quot;iTunes/12.5.5 (Macintosh; OS X 10.11.6) AppleWebKit/601.7.7&quot;, &quot;X-Apple-I-Client-Time&quot;: &quot;2017-10-30T06:38:41Z&quot;, &quot;Referer&quot;: &quot;https://itunes.apple.com/cn/app/%E4%BA%AC%E4%B8%9C%E9%87%91%E8%9E%8D-%E6%96%B0%E4%BA%BA%E9%A2%86666%E5%85%83%E5%A4%A7%E7%A4%BC%E5%8C%85/id895682747?mt=8&quot;, &quot;X-Apple-I-MD&quot;: &quot;AAAABQAAABB/8E70ajsA2bpSsQneRzRzAAAAAQ==&quot;, &quot;X-Dsid&quot;: &quot;1851386458&quot;, &quot;Cookie&quot;: &quot;groupingPillToken=1_iphone; mt-asn-1851386458=5; mt-asn-1952598692=5; mt-tkn-1851386458=AquPBN7pBVJrtDMwCG1MrwviP60xe4f/EE45hsAOovLfR/ovUuHxcsKrlj2pxor0U9F3HIkuroemH+0MuFQnpjqUFC4oYoymULT5CpIKnJ3VpDni/Y/moZel5PjbSHG4GD+Ijl5r7uyk/NbjAbcP2c6m643pr8/RJ8pEGPfTmpVhsZJWGga7Uku1jMcsYZwUcq4thww=; mt-tkn-1952598692=AmPsxyX+Zm3hcSBdOCr1LAg942a/+QI1OZsorJ+0WD2wkyUHZ6Dv3jDaRipaZfgo7xzHgpeVUdtG70RFfh0FA5pOHGZGJ/5b/MiFc4VGex0OtgQ9XasD8i89/gI1Ai21Fi7kJkngVal3DewE6NPKYC8difiYN7R7wY/nH/Z3bcgGM9wio22SK/ZdDyrs38XhS717EKw=; X-Dsid=1851386458; itspod=24; mz_at0-1851386458=AwQAAAEBAAHWuQAAAABZo5zH8UZyjuA18kRtUGbvu8lLlA89jpk=; mz_at0-1952598692=AwQAAAEBAAHWUwAAAABX91VVP4AXK30/tKDBEUr2V9fwfUERl9A=; mz_at_ssl-1851386458=AwUAAAEBAAHWUwAAAABYFwZni0EdGJhw1mXiPHOZnkeCs8m3DaU=; mz_at_ssl-1952598692=AwUAAAEBAAHWUQAAAABXfIMB4QjT3cNSHm+BuLBHSWqkz1Ndd0g=; s_vi=[CS]v1|2B45BA5205011739-600001038013C541[CE]; xp_ab=1#isj11bm+3579+17Eg4xa0; xp_abc=17Eg4xa0; xp_ci=3z34ZpILzCUZz4Vrz9pTzlq8yrxrJ&quot;, &quot;iCloud-DSID&quot;: &quot;1851386458&quot; &#125; for url in self.start_urls: yield scrapy.Request(url, headers=headers, callback=self.parse) 定时跑多个spider12class AppstoreSpider(scrapy.Spider): name = &quot;ios&quot; 重点是这里的name，我们可以通过命令行来驱动这个name的spider 其他命令查看/新建/删除用户 cat /etc/passwd 可以查看所有用户的列表 cat /etc/group 查看用户组 userdel peter 删除用户 useradd phpq 增加用户 passwd xxx 该用户密码]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python输出表格]]></title>
    <url>%2F2017%2F10%2F31%2F2018%2Fpython%E8%BE%93%E5%87%BA%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[123456789101112from prettytable import PrettyTable x = PrettyTable([&quot;City name&quot;, &quot;Area&quot;, &quot;Population&quot;, &quot;Annual Rainfall&quot;]) x.align[&quot;City name&quot;] = &quot;l&quot;# Left align city namesx.padding_width = 1# One space between column edges and contents (default)x.add_row([&quot;Adelaide&quot;,1295, 1158259, 600.5]) x.add_row([&quot;Brisbane&quot;,5905, 1857594, 1146.4]) x.add_row([&quot;Darwin&quot;, 112, 120900, 1714.7]) x.add_row([&quot;Hobart&quot;, 1357, 205556, 619.5]) x.add_row([&quot;Sydney&quot;, 2058, 4336374, 1214.8]) x.add_row([&quot;Melbourne&quot;, 1566, 3806092, 646.9]) x.add_row([&quot;Perth&quot;, 5386, 1554769, 869.4]) print x]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appstroe评论爬取]]></title>
    <url>%2F2017%2F10%2F30%2F2018%2Fappstroe%E8%AF%84%E8%AE%BA%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# coding:utf-8import requests# 禁用安全请求警告from requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)url = &apos;https://itunes.apple.com/WebObjects/MZStore.woa/wa/userReviewsRow?id=895682747&amp;displayable-kind=11&amp;startIndex=600&amp;endIndex=800&amp;sort=1&amp;appVersion=all&apos;headers = &#123;&quot;Host&quot;: &quot;itunes.apple.com&quot;,&quot;X-Apple-Tz&quot;: &quot;28800&quot;,&quot;Connection&quot;: &quot;keep-alive&quot;,&quot;Accept&quot;: &quot;*/*&quot;,&quot;X-Apple-Store-Front&quot;: &quot;143465-19,32&quot;,&quot;Proxy-Connection&quot;: &quot;keep-alive&quot;,&quot;If-Modified-Since&quot;: &quot;Mon, 30 Oct 2017 05:09:14 GMT&quot;,&quot;Accept-Language&quot;: &quot;zh-Hans;q=1.0, en;q=0.9&quot;,&quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,&quot;X-Apple-I-MD-RINFO&quot;: &quot;17106176&quot;,&quot;X-Apple-I-MD-M&quot;: &quot;4yta1gxLU2/1yorU7oVB982KDbxQfTgDNV0Kx6rMh83dcH6GSFvvMX4j2xTK1pydINZyrdPRmrAqnMrx&quot;,&quot;User-Agent&quot;: &quot;iTunes/12.5.5 (Macintosh; OS X 10.11.6) AppleWebKit/601.7.7&quot;,&quot;X-Apple-I-Client-Time&quot;: &quot;2017-10-30T06:38:41Z&quot;,&quot;Referer&quot;: &quot;https://itunes.apple.com/cn/app/%E4%BA%AC%E4%B8%9C%E9%87%91%E8%9E%8D-%E6%96%B0%E4%BA%BA%E9%A2%86666%E5%85%83%E5%A4%A7%E7%A4%BC%E5%8C%85/id895682747?mt=8&quot;,&quot;X-Apple-I-MD&quot;: &quot;AAAABQAAABB/8E70ajsA2bpSsQneRzRzAAAAAQ==&quot;,&quot;X-Dsid&quot;: &quot;1851386458&quot;,&quot;Cookie&quot;: &quot;groupingPillToken=1_iphone; mt-asn-1851386458=5; mt-asn-1952598692=5; mt-tkn-1851386458=AquPBN7pBVJrtDMwCG1MrwviP60xe4f/EE45hsAOovLfR/ovUuHxcsKrlj2pxor0U9F3HIkuroemH+0MuFQnpjqUFC4oYoymULT5CpIKnJ3VpDni/Y/moZel5PjbSHG4GD+Ijl5r7uyk/NbjAbcP2c6m643pr8/RJ8pEGPfTmpVhsZJWGga7Uku1jMcsYZwUcq4thww=; mt-tkn-1952598692=AmPsxyX+Zm3hcSBdOCr1LAg942a/+QI1OZsorJ+0WD2wkyUHZ6Dv3jDaRipaZfgo7xzHgpeVUdtG70RFfh0FA5pOHGZGJ/5b/MiFc4VGex0OtgQ9XasD8i89/gI1Ai21Fi7kJkngVal3DewE6NPKYC8difiYN7R7wY/nH/Z3bcgGM9wio22SK/ZdDyrs38XhS717EKw=; X-Dsid=1851386458; itspod=24; mz_at0-1851386458=AwQAAAEBAAHWuQAAAABZo5zH8UZyjuA18kRtUGbvu8lLlA89jpk=; mz_at0-1952598692=AwQAAAEBAAHWUwAAAABX91VVP4AXK30/tKDBEUr2V9fwfUERl9A=; mz_at_ssl-1851386458=AwUAAAEBAAHWUwAAAABYFwZni0EdGJhw1mXiPHOZnkeCs8m3DaU=; mz_at_ssl-1952598692=AwUAAAEBAAHWUQAAAABXfIMB4QjT3cNSHm+BuLBHSWqkz1Ndd0g=; s_vi=[CS]v1|2B45BA5205011739-600001038013C541[CE]; xp_ab=1#isj11bm+3579+17Eg4xa0; xp_abc=17Eg4xa0; xp_ci=3z34ZpILzCUZz4Vrz9pTzlq8yrxrJ&quot;,&quot;iCloud-DSID&quot;: &quot;1851386458&quot;&#125;r = requests.get(url, headers=headers, verify=True)# print(r.status_code)respose = r.textprint(type(respose))print respose 先说一下坑在哪里，那就是最新版本的ituns没有应用搜索这个功能，而appstroe的接口完全抓不到，这里要记住我们要使用10.11.6以前的系统版本，然后使用12.5.5.5以前的itunes版本]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS可执行文件分析记录系统构建]]></title>
    <url>%2F2017%2F10%2F25%2F2017%2FiOS%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[配置文件选项构建 设置文件路径和linkmap选项为YES 编写自动化解析脚本 编写自动打包脚本 将脚本进行编译，并且在服务器上进行安装 搭建可视化界面 将任务开始命令植入git 历史数据展示 配置文件选项构建重点：所有的工程都要添加一个Analyse这个项，否则你选择这个进行编译，就会报错 设置文件路径和linkmap选项为YES $(TARGET_TEMP_DIR)/$(PRODUCT_NAME)-LinkMap-$(CURRENT_VARIANT)-$(CURRENT_ARCH).txt $(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)我们可以设置路径为BUILD_DIR，这样就直接出现在Build这个目录下了 编写自动化解析脚本编写自动打包脚本1xcodebuild -workspace JDFinance.xcworkspace -scheme JDMobile -configuration Analyse build]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS安全点罗列]]></title>
    <url>%2F2017%2F10%2F23%2F2017%2FiOS%E5%AE%89%E5%85%A8%E7%82%B9%E7%BD%97%E5%88%97%2F</url>
    <content type="text"><![CDATA[针对可执行文件去除符号表 1strip JDMobile 这样就去除了符号表，防止他人查看我们使用的类和方法，但是需要重新签名我们的包才能发出去]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学入门]]></title>
    <url>%2F2017%2F10%2F23%2F2018%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[产品本质上承载的是数据，通过对数据的挖掘然后不断的优化产品，从而达到变现的目的 关于大数据： 数据来源 交易数据：业务开展必须记录的数据，比如基金交易数据，比如病例 行为数据：日志数据，这是最关键的点，比如操作习惯，什么时候喜欢使用，什么地点，一个没有病的人每天干什么，一个有病的人每天干什么 全量加工 无法通过采样的方式来达到目的，比如统计使用联通卡的用户比例，采某几个特征区域数据，然后加权后你发现放到全国大差不差，但是行为数据千差万别，并且对细分人群意义重大 分布式的必要性 自动化应用 相对于洞察应用而言，将数据总结为报表，然后决策人员根据数据进行决策，比如财务报表和运营报表，本质是数据到人再到人的决策，数据到机器然后到机器自动决策，这是自动化应用 比如广告系统和征信系统和自动补货系统，在人进行浏览的时候广告策略就会自动调整 具备了上边的特点才是一个典型的大数据问题 落地具体到落地的时候，需要以下步骤： 收集 数据转化为信息 挖掘 变现 总体思路目的：数据和流量或者IP变现 流量变现：正常内容夹带付费内容或者可转化的内容 数据变现：根据用户偏好或者叫画像提高付费内容或者渠道的投放或者说由于数据的存在，流量的单位变现能力变强 品牌变现：利用熟悉的形象提高关注度和接受度，增加转化率，延伸利用熟悉品牌进行再营销 举例1：广告位定价1万，这是流量变现，现在我们利用数据一个广告位一分为二，上边卖剃须刀下边卖护肤品，每个广告位卖6千，多卖2千，多的收入便是数据收入。大家双赢举例2:网红，自媒体 原则： 数据优于经验 自动先于人工 行为数据具体 屏幕拖动快慢 gg]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片压缩工具ImageOptim在git的集成]]></title>
    <url>%2F2017%2F10%2F23%2F2018%2F%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7ImageOptim%E5%9C%A8git%E7%9A%84%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[过程是看看有没有装这个软件，如果没有装就先下载再装上，然后开始进行检索所有的图片，然后把图片传入这个软件，打开进行压缩 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python#coding:utf-8import sys,os,time,shutilimport urllib import urllib2import zipfileimport tarfiledef un_tar(file_name): tar = tarfile.open(file_name) names = tar.getnames() if os.path.isdir(file_name + &quot;_files&quot;): pass else: os.mkdir(file_name + &quot;_files&quot;) #因为解压后是很多文件，预先建立同名目录 for name in names: tar.extract(name, file_name + &quot;_files/&quot;) tar.close()if os.path.exists(&apos;/Applications/ImageOptim.app&apos;) == False: print &apos;下载&apos; un_tar(&apos;ImageOptim.tar&apos;) shutil.copytree(&apos;ImageOptim.tar_files/ImageOptim.app&apos;,&apos;/Applications/ImageOptim.app&apos;)text = os.popen(&apos;find . -name *.png&apos;).read()images = text.split(&apos;\n&apos;)imagepaths = &apos;&apos;for x in xrange(1,200): image = images[x] if chr(32) in image: print &apos;该文件不可用，请去除文件名字的空格&apos; + image continue imagepaths = imagepaths + &apos; &apos; + imageos.system(&apos;open -a ImageOptim &apos; + imagepaths)]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS安全--符号表]]></title>
    <url>%2F2017%2F10%2F20%2F2017%2FiOS%E5%AE%89%E5%85%A8-%E7%AC%A6%E5%8F%B7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[符号表中有些符号是必须的，但是很多符号都是去掉的。 先来看一个正常的二进制文件的符号表： IOS安全–使用strip从符号表中去掉不需要的符号 从上面我们可以看到很多暴露的类名、函数名等，这让攻击者很容易看出你的程序中有哪些关键的逻辑。但是我们对该文件strip后，再来看它的符号表： strip JDMobile IOS安全–使用strip从符号表中去掉不需要的符号 这时我们看到程序中定义的函数在符号表中都没有了。 而且这样在反汇编的代码中也不会存在符号。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios编译过程]]></title>
    <url>%2F2017%2F10%2F20%2F2017%2Fios%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[看一下ios项目的归档构建流程: 准备构建环境，构建目录 编译主工程依赖的Pods工程的静态库或者Framework (=== BUILD TARGET Aspects OF PROJECT Pods WITH CONFIGURATION Debug ===) 编译主工程的源代码文件 (CompileC) 链接生成主工程对应的可执行文件 (Ld) 拷贝图片，localized字符串等资源文件 (CpResource) 编译storyboard文件 (CompileStoryboard) CompileAssetCatalog 处理pinfo.list文件 (ProcessInfoPlistFile) 生成符号表文件(GenerateDSYMFile) 链接StoryBoard(LinkStoryboards) 执行配置的脚本文件(PhaseScriptExecution) 打包生成app文件，不是ipa文件(ProcessProductPackaging) 签名 (CodeSign) 校验 (Validate)]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipa自动创建上传功能构建]]></title>
    <url>%2F2017%2F10%2F16%2F2017%2Fipa%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[我们其实是对Application Loader功能进行脚本化 做一个软链首先ln -s /Applications/Xcode.app/Contents/Applications/Application\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool /usr/local/bin/altool 增加关联项目ln -s /Applications/Xcode.app/Contents/Applications/Application\ Loader.app/Contents/itms /usr/local/itms 打包脚本xcodebuild -workspace JDFinance.xcworkspace -scheme JDMobile -configuration Beta build 打包脚本xcodebuild archive -workspace JDFinance.xcworkspace -scheme JDMobile -configuration Beta -archivePath JDMobile.xcarchive altool -v -f JDMobile.ipa -u xxxxxxxx@126.com -p xxxxxx -t ios检验是否可以进行上传 altool --upload-app -f JDMobile.ipa -u xxxxxxxx@126.com -p xxxxxxxx -t ios上传 ERROR ITMS-90535: &quot;Unexpected CFBundleExecutable Key. The bundle at &#39;Payload/JDMobile.app/CBPResource.bundle&#39; does not contain a bundle executable. If this bundle intentionally does not contain an executable, consider removing the CFBundleExecutable key出现这个错误的时候删除这个key就好 ERROR ITMS-90207: &quot;Invalid Bundle. The bundle at &#39;JDMobile.app&#39; does not contain a bundle executable.&quot;出现这个错误的时候看看里边是不是存在一个可执行文件，当然如果你编译一个bundle是完全可能的，这个时候你就要先手动编译，然后删除可执行文件，然后在手动加入进去就好了 签名失败，codesign那么看一看你的证书是不是在钥匙串里边，要做的就是把它弄到系统里边]]></content>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo多端同步错误解决方案]]></title>
    <url>%2F2017%2F10%2F11%2F2017%2Fhexo%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[hexo d这个命令是相当于直接git push，如果只有一台机器那么是没有问题，但是如果是两台机器，那么还少一步git pull，所以如果是两台机器同时维护一个库的时候需要 进入到.deploy_git这个目录下 然后执行git pull origin master --allow-unrelated-histories 然后再push 执行hexo d就好了]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F10%2F11%2F2016%2F%E8%BD%AC-block%E8%BF%9B%E9%98%B61-block%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[title: (转)block进阶1–block实现date: 2016-06-29 14:15:20tags: iOS基础categories: iOS 本系列博文总结自《Pro Multithreading and Memory Management for iOS and OS X with ARC》 block 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观，因而广受开发者欢迎。但同时 block 也是 iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，知其然，更知其所以然，才能从根本上避免挖坑和踩坑。 需要知道的是，block 只是 Objective-C 对闭包的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，名称不同而已。 以下研究所用的过程代码由 clang 编译前端生成，仅作理解之用。实际上 clang 根本不会将 block 转换成人类可读的代码，它对 block 到底做了什么，谁也不知道。 所以，切勿将过程代码当做block的实际实现，切记切记！！！ 将下面的 test.m 代码用 clang 工具翻译 test.cpp 代码 clang -rewrite-objc test.m test.m 代码1234567/************* Objective-C 源码 *************/int main()&#123; void (^blk)(void) = ^&#123; printf(&quot;Block\n&quot;); &#125;; blk(); return 0;&#125; test.cpp1234567891011121314151617181920212223242526272829303132333435/************* 使用 clang 翻译后如下 *************/struct __block_impl&#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; printf(&quot;Block\n&quot;);&#125;static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;int main()&#123; void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;&#125; 接着，我们逐一来看下这些函数和结构体 block 结构体信息详解struct __block_impl12345678// __block_impl 是 block 实现的结构体struct __block_impl&#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;; isa 123impl.isa = &amp;_NSConcreteStackBlock; impl.isa = &amp;_NSConcreteMallocBlock; impl.isa = &amp;_NSConcreteGlobalBlock; Flags按位承载 block 的附加信息； Reserved保留变量； FuncPtr函数指针，指向 Block 要执行的函数，即{ printf(“Block\n”) }; struct __main_block_impl_012345678910111213// __main_block_impl_0 是 block 实现的结构体，也是 block 实现的入口struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; implblock 实现的结构体变量，该结构体前面已说明； Desc描述 block 的结构体变量； __main_block_impl_0结构体的构造函数，初始化结构体变量 impl、Desc； static void __main_block_func_012345// __main_block_func_0 是 block 要最终要执行的函数代码static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; printf(&quot;Block\n&quot;);&#125; static struct __main_block_desc_0123456// __main_block_desc_0 是 block 的描述信息结构体static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;; reserved结构体信息保留字段 Block_size结构体大小 此处已定义了一个该结构体类型的变量 __main_block_desc_0_DATA 接着再看 block 获取外部变量 block 获取外部变量运行下面的代码1234567int main()&#123; int intValue = 1; void (^blk)(void) = ^&#123; printf(&quot;intValue = %d\n&quot;, intValue); &#125;; blk(); return 0;&#125; 打印结果 intValue = 1和第一段源码不同的是，这里多了个局部变量 intValue，而且还在 block 里面获取到了。 通过前一段对 block 源码的学习，我们已经了解到 block 的函数定义在 main() 函数之外，那它又是如何获取 main() 里面的局部变量呢？为了解开疑惑，我们再次用 clang 重写这段代码12345678910111213141516171819202122232425262728293031323334353637struct __block_impl&#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int intValue; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; int intValue = __cself-&gt;intValue; // bound by copy printf(&quot;intValue = %d\n&quot;, intValue);&#125;static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main()&#123; int intValue = 1; void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, intValue); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;&#125; 原来 block 通过参数值传递获取到 intValue 变量，通过函数1234__main_block_impl_0 (void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)保存到 __main_block_impl_0 结构体的同名变量 intValue，通过代码 int intValue = __cself-&gt;intValue; 取出 intValue，打印出来。构造函数 __main_block_impl_0 冒号后的表达式 intValue(_intValue) 的意思是，用 _intValue 初始化结构体成员变量 intValue。 有四种情况下应该使用初始化表达式来初始化成员：1：初始化const成员2：初始化引用成员3：当调用基类的构造函数，而它拥有一组参数时4：当调用成员类的构造函数，而它拥有一组参数时 至此，我们已经了解了block 的实现，以及获取外部变量的原理。但是，我们还不能在 block 内修改 intValue 变量。如果你有心试下，在 block 内部修改 intValue 的值，会报编译错误 Variable is not assignable(missing __block type specifier)]]></content>
  </entry>
  <entry>
    <title><![CDATA[python学习环境搭建-jupyter notebook]]></title>
    <url>%2F2017%2F10%2F11%2F2018%2Fpython%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-jupyter-notebook%2F</url>
    <content type="text"><![CDATA[先说一下好处：我们学习python可以在命令行输入python直接进入python环境进行练习，但是问题是多行运行比较繁琐，这里我们推荐使用jupyter来运行代码 再说一下环境 ：MAC台式机 python:mac下自带Python 2.7.10 1.先升级了pip安装工具：sudo python -m pip install –upgrade –force pip 2.安装setuptools 工具：sudo pip install setuptools==33.1.1 3.安装 Python-dateutil:sudo pip install python-dateutil==2.2 4.安装six:sudo pip install –ignore-installed six 5.安装jupyter：sudo install jupyter 启动命令：直接在终端输入jupyter notebook 折腾了半天，才搞好，以上命令是在安装的时候遇到各种问题时使用的，下面写记录一下遇到的问题 以及对应的解决办法 1.ImportError: cannot import name _thread 报这个错误 解决办法： sudo pip uninstall python-dateutilsudo pip install python-dateutil==2.22.File “/Library/Python/2.7/site-packages/dateutil/tz/_common.py”, line 2, in from six.moves import _threadImportError: cannot import name _thread 解决办法：安装six 命令再上方 解决了上面的问题 启动的时候 还是会报错这是个顽固的错误： File “/Library/Python/2.7/site-packages/packaging/requirements.py”, line 59, in MARKER_EXPR = originalTextFor(MARKER_EXPR())(&quot;marker&quot;) TypeError: call() takes exactly 2 arguments (1 given) 解决办法：根据错误信息直接找到路径中的文件，打开文件将 59 行中的函数修改 59：#MARKER_EXPR = originalTextFor(MARKER_EXPR())(“marker”)60：MARKER_EXPR = originalTextFor(MARKER_EXPR(“marker”)) 修改好之后直接保存文件 再次运行jupyter notebook 命令 即可启动jupyter 关于six那个问题，还有一点 需要删除我们默认路径下的six 否则 即使更新成功了 也不会使用最新的six 方法：先查看一下默认的six路径 import six 最后说一下怎么使用file–&gt;new–&gt;python2]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python发送邮件代码记录]]></title>
    <url>%2F2017%2F10%2F10%2F2018%2Fpython%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/env python#coding:utf-8from email import encodersfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.mime.application import MIMEApplicationfrom email.utils import parseaddr, formataddrimport smtplib,osdef _format_addr(s): name, addr = parseaddr(s) return formataddr(( \ Header(name, &apos;utf-8&apos;).encode(), \ addr.encode(&apos;utf-8&apos;) if isinstance(addr, unicode) else addr))def sendMail(): username = &apos;hanshenghui&apos; password = &apos;11111111111&apos; from_addr = &apos;hanshenghui@jd.com&apos; to_addr = &apos;hanshenghui@jd.com&apos; # to_addrList = [&apos;hanshenghui@jd.com&apos;,&apos;gaixutian@jd.com&apos;,&apos;wangzhenyang1@jd.com&apos;] to_addrList = [&apos;hanshenghui@jd.com&apos;,&apos;wangxiugang@jd.com&apos;,&apos;dingchao1@jd.com&apos;] smtp_server = &apos;smtp.jd.local&apos; msg = MIMEMultipart() part = MIMEText(&quot;这是一封测试邮件\n\n现在主要有以下几个待确定点:\n1.我们可以通过对数据进行提取，做一些分析和简介作为邮件的正文，或者是一些其他什么内容\n2.现在邮箱我添加了名字为JDJRMobile，实际上是我自己的邮箱，用哪个邮箱来发送比较合适\n3.检测哪个分支\n4.检测频率\n\n&quot;) msg.attach(part) basePath = os.environ[&apos;HOME&apos;] reportPath = basePath + &apos;/Documents/Build/JDJRAPPAndroid/infer-out/report.csv&apos; if os.path.exists(reportPath): part1 = MIMEApplication(open(reportPath,&apos;rb&apos;).read()) part1.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&quot;report.csv&quot;) msg.attach(part1) # part2 = MIMEApplication(open(&apos;cesh.png&apos;,&apos;rb&apos;).read()) # part2.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&quot;cesh.png&quot;) # msg.attach(part2) msg[&apos;From&apos;] = _format_addr(u&apos;JDJRMobile &lt;%s&gt;&apos; % from_addr) msg[&apos;To&apos;] = _format_addr(&apos;JDJR&apos;) msg[&apos;Subject&apos;] = Header(u&apos;JDJR安卓源码检测报告&apos;, &apos;utf-8&apos;).encode() server = smtplib.SMTP(smtp_server,25) server.set_debuglevel(1) server.sendmail(from_addr, to_addrList, msg.as_string()) server.quit()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xcode工程加密思路]]></title>
    <url>%2F2017%2F10%2F10%2F2018%2Fxcode%E5%B7%A5%E7%A8%8B%E5%8A%A0%E5%AF%86%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[现在有这么一个需求，如何做到如果不安装我们的开发环境，就无法查看iOS工程。首先我们如果对所有的代码进行加密这肯定是一个浩大的工程，所以我们选择是对project加密， 123456789101112131415161718192021222324252627282930313233343536373839404142434445/usr/bin/env python#coding:utf-8from Crypto.Cipher import AES from binascii import b2a_hex,a2b_hex class prpcrypt(): #定义一个类 def __init__(self,key): self.key=key self.mode=AES.MODE_CBC def encrypt(self,text): cryptor=AES.new(self.key,self.mode,self.key) x = len(text) % 16 if x != 0: text = text + &apos;0&apos; * (16 - x) #不满16，32，64位补0 self.ciphertext=cryptor.encrypt(text) return b2a_hex(self.ciphertext) def decrypt(self,text): cryptor=AES.new(self.key,self.mode,self.key) plain_text=cryptor.decrypt(a2b_hex(text)) return plain_text.rstrip(&apos;\0&apos;) pc=prpcrypt(&apos;tecentbluewhaleA&apos;) #自己设定的密钥f = open(&apos;project.pbxproj&apos;,&apos;r&apos;)text = f.read()liens = text.split(&apos;\n&apos;)if len(liens) &gt; 10: item = liens[10] print item # item = pc.decrypt(item) item = pc.encrypt(item) item = item.replace(&apos;000000000000000&apos;,&apos;&apos;) print item liens[10] = itemfor i in range(0,len(liens) - 1): liens[i] = liens[i] + &apos;\n&apos;strings = &apos;&apos;.join(liens)f = open(&apos;project.pbxproj&apos;,&apos;w&apos;)f.writelines(strings)f.close() 这里我们使用到了pycrypto库，安装的时候需要先卸载sudo pip uninstall cryptosudo pip uninstall pycrypto 然后sudo pip install pycrypto这样就安装好了需要的库 关于我们加密那哪些东西，其实主要是project文件里边的解析文件，将一些关键是被符号进行加密，其实如果查看git操作记录是可以发现该如何还原的，这个时候就需要靠多行替换来增大替换的工作量来人为设置门槛 另外需要配合改装的git，在commit的时候进行加密然后commit，在pull的时候也是解密然后commit一下，这样我们就做到了，在远端库里边是不能被直接有序查看的代码，在本地需要配合我们的git才能被顺畅的使用]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xcode多版本自动化打包设置]]></title>
    <url>%2F2017%2F10%2F10%2F2018%2Fxcode%E5%A4%9A%E7%89%88%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[如果你升级了xcode但是这个时候你又想降级回去，你发现appstore已经不要指望了，我们需要下载一个你需要版本的xcode。下载各个Xcode版本的地址https://developer.apple.com/download/more然后放置到我们的程序目录下，改个名字比如说叫Xcode2但是现在问题又来了，加入你是个打包服务器，你使用的是xcodebuild来打包的，这个时候两个版本的xcode同时存在，它如何选择sdk进行打包呢？ 首先查看sdk版本 xcodebuild -showsdks 然后切换默认的xcode sudo xcode-select -switch /Applications/Xcode2.app 然后在执行xcodebuild -showsdks 你会发现sdk已经变了，这个时候你使用xcodebuild来打包可以选择你需要的这个版本的sdk了]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac中的二进制文件]]></title>
    <url>%2F2017%2F10%2F09%2F2018%2FMach-O%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在Unix系统中，任何文件都可以通过chmod+x命令来标记为可执行文件，但是这并不能保证这个文件是能够被执行的，这个标志只是告诉系统这个文件可以读入内容，然后寻找一个头签名，据此可以确定精确的可执行文件格式，这个文件签名通常称为”magic”。例如: #!脚本 0xcafebabe/0xbebafeca包含多种架构支持的二进制，又被称为通用二进制或者胖二进制 0xfeedface(32位)，0xfeedfacf(64位)Mach-O格式或者叫OSX原生二进制格式 胖二进制通用二进制只不过是其支持的各种架构的二进制文件的打包文件，这种格式的文件包含一个文件头，然后文件头后面依次拷贝了每一种支持架构的二进制文件。 通用二进制文件的处理工具叫做lipo脂肪的意思，对应胖二进制的意思 这个工具可以提取，删除和替换通用二进制文件中制定架构的二进制代码，因此可以通过这个工具对二进制文件进行瘦身 Mach-O首先看mach_headerotool -hV JDMobile12345Mach headermagic cputype cpusubtype caps filetype ncmds sizeofcmds flagsMH_MAGIC_64 ARM64 ALL 0x00 EXECUTE 68 7464 NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE magic魔数代表32或者64位 cputype和subcuptype代表cup类型 filetype代表文件类型(可执行文件，库文件，核心转储文件，内核扩展) ncmds和sizeofcmds用于加载的家在命令的条数和大小 flags代表动态连接器(dyld)的标志 分析方法stingsotoolnm otool12345678910111213141516171819202122232425262728293031-f print the fat headers-a print the archive header-h print the mach header-l print the load commands-L print shared libraries used #使用到的库-D print shared library id name #支持的架构arm64 armv7-t print the text section (disassemble with -v)#查看数据段，基本无用-p &lt;routine name&gt; start dissassemble from routine name#无用-s &lt;segname&gt; &lt;sectname&gt; print contents of section-d print the data section-o print the Objective-C segment-r print the relocation entries-S print the table of contents of a library-T print the table of contents of a dynamic shared library-M print the module table of a dynamic shared library-R print the reference table of a dynamic shared library-I print the indirect symbol table-H print the two-level hints table-G print the data in code table-v print verbosely (symbolically) when possible-V print disassembled operands symbolically-c print argument strings of a core file-X print no leading addresses or headers-m don&apos;t use archive(member) syntax-B force Thumb disassembly (ARM objects only)-q use llvm&apos;s disassembler (the default)-Q use otool(1)&apos;s disassembler-mcpu=arg use `arg&apos; as the cpu for disassembly-j print opcode bytes-P print the info plist section as strings-C print linker optimization hints 瘦身实战12345678910111213141516171819202122232425262728293031323334# Address Size Segment Section0x1000070C0 0x02C814F0 __TEXT __text0x102C885B0 0x00005C58 __TEXT __stubs0x102C8E208 0x0000420C __TEXT __stub_helper0x102C92420 0x002C8B1F __TEXT __const0x102F5AF3F 0x0012A102 __TEXT __objc_methname0x103085050 0x0017170F __TEXT __cstring0x1031F6760 0x000120F8 __TEXT __ustring0x103208858 0x0002402D __TEXT __objc_classname0x10322C885 0x00028B82 __TEXT __objc_methtype0x103255408 0x000C4E54 __TEXT __gcc_except_tab0x10331A25C 0x00055918 __TEXT __unwind_info0x10336FB78 0x00000464 __TEXT __eh_frame0x103370000 0x00001910 __DATA __got0x103371910 0x00003D90 __DATA __la_symbol_ptr0x1033756A0 0x00000438 __DATA __mod_init_func0x103375AE0 0x000DF810 __DATA __const0x1034552F0 0x000BA100 __DATA __cfstring0x10350F3F0 0x0000BAB0 __DATA __objc_classlist0x10351AEA0 0x00000428 __DATA __objc_nlclslist0x10351B2C8 0x00001120 __DATA __objc_catlist0x10351C3E8 0x000000C0 __DATA __objc_nlcatlist0x10351C4A8 0x000015E0 __DATA __objc_protolist0x10351DA88 0x00000008 __DATA __objc_imageinfo0x10351DA90 0x004ECB80 __DATA __objc_const0x103A0A610 0x00047820 __DATA __objc_selrefs0x103A51E30 0x00000148 __DATA __objc_protorefs0x103A51F78 0x0000AA08 __DATA __objc_classrefs0x103A5C980 0x00007DC8 __DATA __objc_superrefs0x103A64748 0x0001E8A0 __DATA __objc_ivar0x103A82FE8 0x00074B30 __DATA __objc_data0x103AF7B20 0x002FCC08 __DATA __data0x103DF4740 0x00489580 __DATA __bss0x10427E000 0x000AD71C __DATA __common 查看所有编译进去的方法nm JDMobile 12 查看所有被使用的方法otool -v -s __DATA __objc_selrefs JDMobile-build-beta-s 是说我要看这个seg下的这个section-v 是说尽可能展示可识别内容 GetFileInfo filename| grep modified查看文件信息，包括 directory: “/Users/jrmacpro/Library/Developer/Xcode/DerivedData/JDFinance-eqeqtaeyecxhiqgogjuodubajlyt/Build/Products/Beta-iphoneos/JDMobile.app” attributes: avbstclinmedz created: 10/18/2017 12:55:09 modified: 10/18/2017 12:59:11 nm的使用nm [option(s)] [file(s)]有用的options: -A 在每个符号信息的前面打印所在对象文件名称； -C 输出demangle过了的符号名称； -D 打印动态符号； -l 使用对象文件中的调试信息打印出所在源文件及行号； -n 按照地址/符号值来排序； -u 打印出那些未定义的符号； 常见的符号类型: 1234567A 该符号的值在今后的链接中将不再改变；B 该符号放在BSS段中，通常是那些未初始化的全局变量；D 该符号放在普通的数据段中，通常是那些已经初始化的全局变量；T 该符号放在代码段中，通常是那些全局非静态函数；U 该符号未定义过，需要自其他对象文件中链接进来；W 未明确指定的弱链接符号；同链接的其他对象文件中有它的定义就用上，否则就用一个系统特别指定的默认值。 注意几点：-C 总是适用于c++编译出来的对象文件。还记得c++中有重载么？为了区分重载函数，c++编译器会将函数返回值/参数等信息附加到函数名称中去形成一个mangle过的符号，那用这个选项列出符号的时候，做一个逆操作，输出那些原始的、我们可理解的符号名称。使用 -l 时，必须保证你的对象文件中带有符号调式信息，这一般要求你在编译的时候指定一个 -g 选项，见 Linux:Gcc。使用nm前，最好先用Linux:File查看对象文件所属处理器架构，然后再用相应交叉版本的nm工具。]]></content>
      <tags>
        <tag>iOS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[otool作用以及使用]]></title>
    <url>%2F2017%2F09%2F28%2F2018%2Fotool%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[首先来看看那些命令 -h print the mach header打印头部]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[find与grep命令]]></title>
    <url>%2F2017%2F09%2F22%2F2017%2Ffind%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[区别 find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。 find基本格式：find path expression 按照文件名查找 find / -name httpd.conf #在根目录下查找文件httpd.conf，表示在整个硬盘查找 find /etc -name httpd.conf #在/etc目录下文件httpd.conf find /etc -name &#39;*srm*&#39; #使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件 find . -name &#39;srm*&#39; #表示当前目录下查找文件名开头是字符串‘srm’的文件 按照文件特征查找 find / -amin -10 # 查找在系统中最后10分钟访问的文件(access time) find / -atime -2 # 查找在系统中最后48小时访问的文件 find / -empty # 查找在系统中为空的文件或者文件夹 find / -group cat # 查找在系统中属于 group为cat的文件 find / -mmin -5 # 查找在系统中最后5分钟里修改过的文件(modify time) find / -mtime -1 #查找在系统中最后24小时里修改过的文件 find / -user fred #查找在系统中属于fred这个用户的文件 find / -size +10000c #查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB) find / -size -1000k #查找出小于1000KB的文件 使用混合查找方式查找文件参数有： ！，-and(-a)，-or(-o)。 find /tmp -size +10000c -and -mtime +2 #在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件 find / -user fred -or -user george #在/目录下查找用户是fred或者george的文件文件 find /tmp ! -user panda #在/tmp目录中查找所有不属于panda用户的文件 grepgrep &#39;^[0-9]&#39; text.txt返回以数字开头的行grep &#39;@&#39; text.txt返回包含@的行]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ string用法]]></title>
    <url>%2F2017%2F09%2F06%2F2017%2Fc-string%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[C++ string的用法和例子(转)Mark一下使用场合：string是C++标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时C++的算法库对string也有着很好的支持，而且string还和c语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。其中使用的代码多数都是来自cpp官网，因为例子非常全。 声明和初始化方法：想使用string首先要在头文件当中加入&lt; string &gt;声明方式也很简单 声明：12string s;//声明一个string 对象string ss[10];//声明一个string对象的数组 初始化：使用等号的初始化叫做拷贝初始化，不使用等号的初始化叫做直接初始化。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); string s;//默认初始化，一个空字符串 string s1(&quot;ssss&quot;);//s1是字面值“ssss”的副本 string s2(s1);//s2是s1的副本 string s3=s2;//s3是s2的副本 string s4(10,&apos;c&apos;);//把s4初始化 string s5=&quot;hiya&quot;;//拷贝初始化 string s6=string(10,&apos;c&apos;);//拷贝初始化，生成一个初始化好的对象，拷贝给s6 //string s(cp,n) char cs[]=&quot;12345&quot;; string s7(cs,3);//复制字符串cs的前3个字符到s当中 //string s(s2,pos2) string s8=&quot;asac&quot;; string s9(s8,2);//从s2的第二个字符开始拷贝，不能超过s2的size //string s(s2,pos2,len2) string s10=&quot;qweqweqweq&quot;; string s11(s10,3,4);//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义 return 0;&#125; 字符串处理：substr操作：注意substr没有迭代器作为参数的操作 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); string s=&quot;abcdefg&quot;; //s.substr(pos1,n)返回字符串位置为pos1后面的n个字符组成的串 string s2=s.substr(1,5);//abcde //s.substr(pos)//得到一个pos到结尾的串 string s3=s.substr(4);//efg return 0;&#125; 如果输入的位置超过字符的长度，会抛出一个out_of_range的异常 insert操作:代码来自cpp官网，经过自己的整理注意用迭代器当参数和无符号数当参数的区别 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); string str=&quot;to be question&quot;; string str2=&quot;the &quot;; string str3=&quot;or not to be&quot;; string::iterator it; //s.insert(pos,str)//在s的pos位置插入str str.insert(6,str2); // to be the question //s.insert(pos,str,a,n)在s的pos位置插入str中插入位置a到后面的n个字符 str.insert(6,str3,3,4); // to be not the question //s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符 str.insert(10,&quot;that is cool&quot;,8); // to be not that is the question //s.insert(pos,cstr)在s的pos位置插入cstr str.insert(10,&quot;to be &quot;); // to be not to be that is the question //s.insert(pos,n,ch)在s.pos位置上面插入n个ch str.insert(15,1,&apos;:&apos;); // to be not to be: that is the question //s.insert(s.it,ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器 it = str.insert(str.begin()+5,&apos;,&apos;); // to be, not to be: that is the question //s.insert(s.it,n,ch)//在s的it所指向位置的前面插入n个ch str.insert (str.end(),3,&apos;.&apos;); // to be, not to be: that is the question... //s.insert(it,str.ita,str.itb)在it所指向的位置的前面插入[ita,itb)的字符串 str.insert (it+2,str3.begin(),str3.begin()+3); // to be, or not to be: that is the question... return 0;&#125; erase操作：用来执行删除操作删除操作有三种 指定pos和len，其中pos为为起始位置，pos以及后面len-1个字符串都删除迭代器，删除迭代器指向的字符迭代器范围，删除这一范围的字符串，范围左闭右开代码来自cpp官网 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;int main ()&#123; std::string str (&quot;This is an example sentence.&quot;); std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; // &quot;This is an example sentence.&quot; str.erase (10,8); // ^^^^^^^^ //直接指定删除的字符串位置第十个后面的8个字符 std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; // &quot;This is an sentence.&quot; str.erase (str.begin()+9);// ^ //删除迭代器指向的字符 std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; // &quot;This is a sentence.&quot; // ^^^^^ str.erase (str.begin()+5, str.end()-9); //删除迭代器范围的字符 std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; // &quot;This sentence.&quot; return 0;&#125; append和replace操作:append函数可以用来在字符串的末尾追加字符和字符串。由于string重载了运算符，也可以用+=操作实现repalce顾名思义，就是替换的意思，先删除，后增加。代码来自cpp官网，附上自己的解释 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;int main ()&#123; std::string str; std::string str2=&quot;Writing &quot;; std::string str3=&quot;print 10 and then 5 more&quot;; //直接追加一个str2的字符串 str.append(str2); // &quot;Writing &quot; //后面追加str3第6个字符开始的3个字符串 str.append(str3,6,3); // &quot;10 &quot; //追加字符串形参的前5个字符 str.append(&quot;dots are cool&quot;,5); // &quot;dots &quot; //直接添加 str.append(&quot;here: &quot;); // &quot;here: &quot; //添加10个&apos;.&apos; str.append(10u,&apos;.&apos;); // &quot;..........&quot; //添加str3迭代器范围的字符串 str.append(str3.begin()+8,str3.end()); // &quot; and then 5 more&quot; //最后这个比较特殊，意思是添加5个&apos;A&apos;，实际上参数里面的65对应的asc码就是65 str.append&lt;int&gt;(5,65); // &quot;.....&quot; //字符串追加也可以用重载运算符实现 str+=&quot;lalala&quot;; std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; return 0;&#125; replace的使用方法，replace支持使用无符号整数寻找位置，也支持用迭代器寻找位置 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;int main ()&#123; std::string base=&quot;this is a test string.&quot;; std::string str2=&quot;n example&quot;; std::string str3=&quot;sample phrase&quot;; std::string str4=&quot;useful.&quot;; // replace signatures used in the same order as described above: // Using positions: 0123456789*123456789*12345 std::string str=base; // &quot;this is a test string.&quot; //第9个字符以及后面的4个字符被str2代替 str.replace(9,5,str2); // &quot;this is an example string.&quot; (1) //第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替 str.replace(19,6,str3,7,6); // &quot;this is an example phrase.&quot; (2) //第8个字符以及后面的9个字符用字符串参数代替 str.replace(8,10,&quot;just a&quot;); // &quot;this is just a phrase.&quot; (3) //第8个字符以及后面的5个字符用字符串参数的前7个字符替换 str.replace(8,6,&quot;a shorty&quot;,7); // &quot;this is a short phrase.&quot; (4) //第22以及后面的0个字符用3个叹号替换 str.replace(22,1,3,&apos;!&apos;); // &quot;this is a short phrase!!!&quot; (5) //迭代器的原理同上 // Using iterators: 0123456789*123456789* str.replace(str.begin(),str.end()-3,str3); // &quot;sample phrase!!!&quot; (1) str.replace(str.begin(),str.begin()+6,&quot;replace&quot;); // &quot;replace phrase!!!&quot; (3) str.replace(str.begin()+8,str.begin()+14,&quot;is coolness&quot;,7); // &quot;replace is cool!!!&quot; (4) str.replace(str.begin()+12,str.end()-4,4,&apos;o&apos;); // &quot;replace is cooool!!!&quot; (5) str.replace(str.begin()+11,str.end(),str4.begin(),str4.end());// &quot;replace is useful.&quot; (6) std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; return 0;&#125; 以上的replace操作可以用insert和erase的操作组合替换，但是replace操作更加方便。 assign操作：assign操作在一起列容器当中都存在，比如vector等等。是一个很基本的操作函数，string使用assign可以灵活的对其进行赋值。代码来自cpp官网 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;int main ()&#123; std::string str; std::string base=&quot;The quick brown fox jumps over a lazy dog.&quot;; // used in the same order as described above: //直接把base赋值给str str.assign(base); std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; //把base第10个字符以及后面的8个字符赋给str str.assign(base,10,9); std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; // &quot;brown fox&quot; //把参数中的0到6个字符串赋给str str.assign(&quot;pangrams are cool&quot;,7); std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; // &quot;pangram&quot; //直接使用参数赋值 str.assign(&quot;c-string&quot;); std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; // &quot;c-string&quot; //给str赋值10个&apos;*&apos;字符 str.assign(10,&apos;*&apos;); std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; // &quot;**********&quot; //赋值是10个&apos;-&apos; str.assign&lt;int&gt;(10,0x2D); std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; // &quot;----------&quot; //指定base迭代器范围的字符串 str.assign(base.begin()+16,base.end()-12); std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; // &quot;fox jumps over&quot; return 0;&#125; string的搜索操作:string类中提供了很多性能优秀，使用方便的成员方法。而且在泛型算法当中也有很多实用的技巧。 find和rfind函数: find函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。代码来自cpp官网 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); std::string str (&quot;There are two needles in this haystack with needles.&quot;); std::string str2 (&quot;needle&quot;); // different member versions of find in the same order as above: //在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾 std::size_t found = str.find(str2); if (found!=std::string::npos) std::cout &lt;&lt; &quot;first &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;; //在str当中，从第found+1的位置开始查找参数字符串的前6个字符 found=str.find(&quot;needles are small&quot;,found+1,6); if (found!=std::string::npos) std::cout &lt;&lt; &quot;second &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;; //在str当中查找参数中的字符串 found=str.find(&quot;haystack&quot;); if (found!=std::string::npos) std::cout &lt;&lt; &quot;&apos;haystack&apos; also found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;; //查找一个字符 found=str.find(&apos;.&apos;); if (found!=std::string::npos) std::cout &lt;&lt; &quot;Period found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;; //组合使用，把str2用参数表中的字符串代替 // let&apos;s replace the first needle: str.replace(str.find(str2),str2.length(),&quot;preposition&quot;); std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; return 0;&#125; rfind函数就是找最后一个出现的匹配字符串，返回的位置仍然是从前往后数的。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); std::string str (&quot;The sixth sick sheik&apos;s sixth sheep&apos;s sick.&quot;); std::string key (&quot;sixth&quot;);// ^ //rfind是找最后一个出现的匹配字符串 std::size_t found = str.rfind(key); if (found!=std::string::npos) &#123; cout&lt;&lt;found&lt;&lt;endl;//输出23 str.replace (found,key.length(),&quot;seventh&quot;);//找到的sixth替换成seventh &#125; std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;; return 0;&#125; 查找的效率非常高，我没看过stl源码剖析，但是感觉是用kmp实现的。呵呵，可以自己写一个。 find_….of函数: find_first_of(args) 查找args中任何一个字符第一次出现的位置find_last_of(args) 最后一个出现的位置find_fist_not_of(args) 查找第一个不在args中的字符find_last_not_of 查找最后一个不在args中出现的字符 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); std::string str1 (&quot;Please, replace the vowels in this sentence by asterisks.&quot;); std::size_t found1 = str1.find_first_of(&quot;aeiou&quot;); //把所有元音找出来用*代替 while (found1!=std::string::npos) &#123; str1[found1]=&apos;*&apos;; found1=str1.find_first_of(&quot;aeiou&quot;,found1+1); &#125; std::cout &lt;&lt; str1 &lt;&lt; &apos;\n&apos;; //在str2中找到第一个不是消协英文字母和空格的字符 std::string str2 (&quot;look for non-alphabetic characters...&quot;); std::size_t found2 = str2.find_first_not_of(&quot;abcdefghijklmnopqrstuvwxyz &quot;); if (found2!=std::string::npos) &#123; std::cout &lt;&lt; &quot;The first non-alphabetic character is &quot; &lt;&lt; str2[found2]; std::cout &lt;&lt; &quot; at position &quot; &lt;&lt; found2 &lt;&lt; &apos;\n&apos;; &#125; return 0;&#125; find_last_of和find_last_not_of与first基本相同，就不写例子代码了。 比较与转换: 类似c语言的字符串比较函数strcmp函数一样，支持字符串比较操作，同时也类似python、C#语言中的函数一样，支持把数字和字符串转换。有些特性是C++11当中才有。注意编译器bug：在MinGW编译器当中如果版本低于3.8，虽然支持c++11但是里面有一个bug，就是不支持字符串和数组的转换！要更新MinGW的版本才可以，或者直接使用g++。 compare函数:和strcmp函数一样，如果两个字符串相等，那么返回0，调用对象大于参数返回1，小于返回-1。在compare当中还支持部分比较，里面有6个参数可以设置。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); string s1=&quot;123&quot;,s2=&quot;123&quot;; cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//0 s1=&quot;123&quot;,s2=&quot;1234&quot;; cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//-1 s1=&quot;1234&quot;,s2=&quot;123&quot;; cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//1 std::string str1 (&quot;green apple&quot;); std::string str2 (&quot;red apple&quot;); if (str1.compare(str2) != 0) std::cout &lt;&lt; str1 &lt;&lt; &quot; is not &quot; &lt;&lt; str2 &lt;&lt; &apos;\n&apos;; //str1的第6个字符以及后面的4个字符和参数比较 if (str1.compare(6,5,&quot;apple&quot;) == 0) std::cout &lt;&lt; &quot;still, &quot; &lt;&lt; str1 &lt;&lt; &quot; is an apple\n&quot;; if (str2.compare(str2.size()-5,5,&quot;apple&quot;) == 0) std::cout &lt;&lt; &quot;and &quot; &lt;&lt; str2 &lt;&lt; &quot; is also an apple\n&quot;; //str1的第6个字符以及后面的4个字符和str2的第4个字符以及后面的4个字符比较 if (str1.compare(6,5,str2,4,5) == 0) std::cout &lt;&lt; &quot;therefore, both are apples\n&quot;; return 0;&#125; 由于string重载了运算符，可以直接用&gt;,&lt;，==来进行比较，也很方便。 数值转换：在io的部分有过数值和字符串相互转换的例子，使用的是stringstream函数，在c++11当中有定义好的现成的函数取调用，非常方便。 string和数值转换to_string(val) 把val转换成stringstoi(s,p,b) 把字符串s从p开始转换成b进制的intstol(s,p,b) longstoul(s,p,b) unsigned longstoll(s,p,b) long longstoull(s,p,b) unsigned long longstof(s,p) floatstod(s,p) doublestold(s,p) long double//注意，下段代码在MinGw中会报错！即使使用c++11编译也一样，无法识别to_string！ 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); string s1; s1=to_string(100); cout&lt;&lt;s1&lt;&lt;endl; int a=stoi(s1,0,10)+1; cout&lt;&lt;a&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clang插件开发]]></title>
    <url>%2F2017%2F09%2F05%2F2017%2Fclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[资源准备&amp;&amp;编译源文件我们需要llvm和clang的源文件，而且这些文件都存在于github上，我们如果直接从github下载会很慢，所以第一步是制作国内源。 制作国内源http://jingyan.baidu.com/article/f79b7cb367e72e9145023e40.html 还有就是不要把这些源文件放到一些需要权限执行的文件里，这样在编译过程中你会发现各种问题。 下载源码的时候注意点就是要对照你的xcode的版本:https://trac.macports.org/wiki/XcodeVersionInfo 然后找到对应的clang版本https://opensource.apple.com/source/clang/clang-800.0.42.1/src/configure.auto.html 经过对比我们发现我们需要的是39版本 比如现在我们在一个叫做GitHub的文件夹下遍建立了一个叫做llvm的文件按照顺序执行以后代码： 1234567891011121314cd GitHubsudo mkdir llvmsudo chown `whoami` llvmcd llvmexport LLVM_HOME=`pwd`git clone -b release_39 https://git.coding.net/hanshenghui/llvm.git llvmgit clone -b release_39 https://git.coding.net/hanshenghui/clangnew.git llvm/tools/clanggit clone -b release_39 https://git.coding.net/hanshenghui/clang-tools-extra.git llvm/tools/clang/tools/extragit clone -b release_39 https://git.coding.net/hanshenghui/compiler-rt.git llvm/projects/compiler-rtmkdir llvm_buildcd llvm_buildcmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel 最后一句cmake -G Xcode是关键，用这种方式cmake的话，我们就可以用Xcode来编译后边的工程执行完毕之后你会发现，在llvm_build这个文件夹下边你会发现有一个LLVM.xcodeproj的文件，有了这个我们可以像iOS开发样去编译任何一个库了 编写插件代码 进入文件/llvm/tools/clang/examples在里面新建一个目录如MyPlugin 然后修改example目录的CMakeLists.txt文件，添加一项： 1add_subdirectory(MyPlugin) 然后进入创建的MyPlugin目录，生成三个文件，分别是： 123CodingStyleUtil.hppMyPlugin.cppCMakeLists.txt CMakeLists.txt中的内容：12345678910add_llvm_loadable_module(MyPlugin MyPlugin.cpp PLUGIN_TOOL clang)if(LLVM_ENABLE_PLUGINS AND (WIN32 OR CYGWIN)) target_link_libraries(MyPlugin $&#123;cmake_2_8_12_PRIVATE&#125; clangAST clangBasic clangFrontend LLVMSupport )endif() CodingStyleUtil.hpp主要是一些处理字符串的函数 MyPlugin.cpp这个文件是关键所在，当我们编译插件的时候，主要就是这里的代码在起作用，先来个简化版的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;#include &quot;clang/AST/AST.h&quot;#include &quot;clang/AST/ASTConsumer.h&quot;#include &quot;clang/Frontend/CompilerInstance.h&quot;#include &quot;clang/AST/RecursiveASTVisitor.h&quot;#include &quot;CodingStyleUtil.hpp&quot;#include &lt;fstream&gt;using namespace clang;using namespace std;using namespace llvm;string gSrcRootPath;static string kClassInterfPrefix = &quot;JR&quot;;static int kMethodParamMaxLen = 15;//static int kMethodParamMaxParamsSingleLine = 3;static int kMethodBodyMaxLines = 500;namespace MyPlugin &#123;class MyPluginVisitor : public RecursiveASTVisitor&lt;MyPluginVisitor&gt;//这里我们要声明一个class，这个class是继承自RecursiveASTVisitor的，可以随便取名字，尖括号里边就是这个visitor的名字 &#123; private: CompilerInstance &amp;Instance; ASTContext *Context; string objcClsImpl; bool objcIsInstanceMethod; string objcSelector; string objcMethodSrcCode; public: void setASTContext (ASTContext &amp;context)//这里定义了一个能方法，用来便捷的对context进行赋值操作 &#123; this -&gt; Context = &amp;context; &#125; MyPluginVisitor (CompilerInstance &amp;Instance) :Instance(Instance) &#123; &#125; bool VisitDecl(Decl *decl) &#123;//所有的声明分析都需要重载这个方法 &#125; &#125;; class MyPluginConsumer : public ASTConsumer &#123; CompilerInstance &amp;Instance; std::set&lt;std::string&gt; ParsedTemplates; public: MyPluginConsumer(CompilerInstance &amp;Instance, std::set&lt;std::string&gt; ParsedTemplates) : Instance(Instance), ParsedTemplates(ParsedTemplates), visitor(Instance) &#123;&#125; bool HandleTopLevelDecl(DeclGroupRef DG) override &#123; return true; &#125; void HandleTranslationUnit(ASTContext&amp; context) override &#123; visitor.setASTContext(context); visitor.TraverseDecl(context.getTranslationUnitDecl()); &#125; private: MyPluginVisitor visitor; &#125;; //这里是所有处理逻辑的入口，在这里调用了consumer class MyPluginASTAction : public PluginASTAction &#123; std::set&lt;std::string&gt; ParsedTemplates; protected: std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI, llvm::StringRef) override &#123; return llvm::make_unique&lt;MyPluginConsumer&gt;(CI, ParsedTemplates); &#125; bool ParseArgs(const CompilerInstance &amp;CI, const std::vector&lt;std::string&gt; &amp;args) override &#123; return true; &#125; &#125;; 现在先回到源码根目录，使用同样的cmake语句来更新Xcode项目，更新完成后原来的项目会多出一个叫MyPlugin的插件项目，然后对这个插件项目进行编译。编译成功后会在Debug/lib目录中多出一个名字叫做MyPlugin.dylib文件 只有这个plugin文件是不够的，我们还需要一个对应的clang和clang++，那么这个文件是哪里来的呢，答案就是我们自己编译的，这个插件和clang版本必须是对应的，否则在运行工程的时候就会说symbol不存在等错误 安装调试插件打开要使用插件的Xcode项目，在build settings一栏中对Other C Flags一项进行编辑，调整为：1-Xclang -load -Xclang /Users/han/GitHub/llvm/llvm_build/Debug/lib/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin 注：最后一项-Xclang MyPlugin中的MyPlugin为插件名字，一定要是自己设置的插件名称，否则无法调用插件 这个时候运行你会发现报错，error:unable to load plugin 为了解决这个问题需要调整Xcode中使用的Clang编译器，将默认的编译器改为我们自己编译出来的编译器。具体的方法是在build settings中再添加两项自定义项：12CC = /Users/han/GitHub/llvm/llvm_build/Debug/bin/clangCXX = &quot;/Users/han/GitHub/llvm/llvm_build/Debug/bin/clang+ clang插件作用范围]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime源码系列-retain/release/retainCount实现]]></title>
    <url>%2F2017%2F07%2F20%2Fruntime%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-retain-release-retainCount%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[黑箱中的 retain 和 release]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构算法-概论]]></title>
    <url>%2F2017%2F07%2F17%2F2018%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95-%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[绪论 算法不一定是程序，算法需要有穷性 算法组重要的是效率，速度尽可能快，存储空间尽可能少 DSA 方法论 如果问题实例有很多，那么很明显我们无法一一解决，那么我们的思路就是对问题进行分类，然后去解决这一类问题 如果你想改进和优化一个东西，你首先需要能够准确的测量它，你需要一把尺子 复杂的问题只有简化之后我们才能抓住主要的矛盾，而简化的方法就是忽略那些不重要的东西 去粗存精 迭代乃人工，递归乃神通 凡治众如治寡，分而治之 复杂问题分解为两个，一个是规模减小的问题，另一个是平凡问题 算法分析时间成本和空间成本，我们更关注时间成本 渐进分析大O记号n足够大的时候成立就好 常数项可忽略 低次项可忽略 具体的刻度 O(1)，再大的常数都是这个复杂度2023x239238 O(logn) O(n^c)多项式复杂度 复杂度分析主要方法 迭代：级数求和 递归：递归跟踪和递归方程 猜测+验证 级数(迭代) 估算： 一天是10^5s 一世纪是3 x 10^9 普通的pc一秒是10^9次运算 最厉害的机器是10^15次运算 递归(更高级的做法，但是效率不应最好)]]></content>
      <tags>
        <tag>数据结构算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自然语言处理概念基础]]></title>
    <url>%2F2017%2F06%2F27%2F2018%2F%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[markAllAsReadSuccess分词，词频，词性 https://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000103&amp;source=jrm&amp;sid= http://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000901&amp;source=jrm]]></content>
  </entry>
  <entry>
    <title><![CDATA[itchat使用总结]]></title>
    <url>%2F2017%2F06%2F14%2F2017%2Fitchat%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[登录1itchat.auto_login() 查找好友 获取任何一项等于name键值的用户itchat.search_friends(name=’littlecodersh’)这里的name是RemarkName’, ‘NickName’, ‘Alias 发送中文要进行一个转换123f = open(path,&apos;r&apos;)text = f.read()text = text.decode(&apos;utf-8&apos;)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo搭建团队博客系统]]></title>
    <url>%2F2017%2F06%2F12%2F2018%2F%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%9B%A2%E9%98%9F%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[hexo搭建个人博客的原理 将md渲染为html 将html以及资源文件上传到github，利用githubpages功能进行展示 解析的过程是将目录下source/_post文件中的东西，渲染为publick中的html文件，然后将该文件夹下的文件复制到.deploy_git文件下，然后利用git操作将该文件夹下的文件push到对应的git库 使用hexo制作团队博客的困难 内网不能直接依赖于github 团队开发的权限管理问题 团队开发的作者识别问题 团队开发的文件冲突问题 问题的解决方案]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多进程通信和调用]]></title>
    <url>%2F2017%2F06%2F12%2F2018%2FPython%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%92%8C%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[python多进程通信 这里解决的主要是，如果是启动一个命令行，然后执行一个python脚本，如果有多个python脚本就需要多个命令行程序，这不是很明智的选择，最好的做法是，一个命令行搞定所有的python脚本，这里就涉及到两个问题 如何做到并发 如何在一个文件中添加一个python的执行入口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#coding:utf-8import os,re,timeimport multiprocessing,commands,shutil,subprocessfrom pymongo import MongoClientlock = multiprocessing.Lock()def func(name, processName, pipe): p_info = &apos;Process[%s] hello %s&apos; % (processName, name) print &apos;pipe send: &apos;, p_info pipe.send(p_info) print &apos;sub pid: %d, ppid: %d&apos; % (os.getpid(), os.getppid()) time.sleep(0.1)def serverForPull(name,pipe): path = &apos;/Users/jdjr/Desktop/branches.txt&apos; while True: time.sleep(3) newpath = &apos;/Users/jdjr/Desktop/gradleDir&apos; if os.path.exists(newpath) == True: os.chdir(&apos;/Users/jdjr/Documents/Build/JDJRAPPAndroid&apos;) currentbranch = &apos;&apos; branch = os.popen(&apos;git branch&apos;).read() lines = branch.split(&apos;\n&apos;) for item in lines: if &apos;*&apos; in item: currentbranch = item[2:] p = subprocess.Popen(&quot;gradle assembleDebug&quot;,shell=True,stdout=subprocess.PIPE) indexcount = 0 returncode = p.poll() while returncode is None: text = p.stdout.readline().strip() f = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;a&apos;) f.write(text) f.close() mc = MongoClient(&quot;localhost&quot;,27017) db = mc.package post_info = db.index dbs = post_info.find(&#123;&apos;branchname&apos;:currentbranch&#125;) count = 0 itemc = &#123;&#125; for itemn in dbs: itemc = itemn count = count + 1 if count == 0: post_info.save(&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:0,&apos;lastcount&apos;:0&#125;) else: ctime = itemc[&apos;time&apos;] lastcount = itemc[&apos;lastcount&apos;] if &apos;Total time:&apos; in text: indexnew = text.find(&apos;:&apos;) newtime = text[indexnew + 1:] post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:newtime,&apos;lastcount&apos;:lastcount&#125;) else: post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:ctime,&apos;lastcount&apos;:lastcount&#125;) if &apos;BUILD SUCCESSFUL&apos; in text: post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:0,&apos;time&apos;:ctime,&apos;lastcount&apos;:indexcount&#125;) else: post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:ctime,&apos;lastcount&apos;:lastcount&#125;) indexcount = indexcount + 1 returncode = p.poll() f1 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;r&apos;) texts = f1.read() f1.close() if &apos;BUILD FAILED&apos; in texts: (status, output) = commands.getstatusoutput(&apos;gradle assembleDebug&apos;) f2 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;w&apos;) texts = f2.write(output) f2.close() shutil.rmtree(newpath) time.sleep(2) mc = MongoClient(&quot;localhost&quot;,27017) db = mc.package post_info = db.index post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:20,&apos;time&apos;:0,&apos;lastcount&apos;:indexcount&#125;) if os.path.exists(path): f1 = open(path,&apos;r&apos;) lists = f1.readlines() if len(lists) == 2: dir = lists[0] branch = lists[1] if &apos;JDJRAPPAndroid&apos; in dir: dir = &apos;/Users/jdjr/Documents/Build/JDJRAPPAndroid&apos; if &apos;JDMobileNew&apos; in dir: dir = &apos;/Users/wxg/Documents/JDMobileNew&apos; if len(dir) &gt; 0: print dir os.chdir(dir) (status, output) = commands.getstatusoutput(&apos;git pull origin %s&apos; % branch) f1 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;r&apos;) text = f1.read() f1.close() f1 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;w&apos;) text1 = text + &apos;\n&apos; + output + &apos;%i&apos; % status f1.write(text1) f1.close() f2 = open(path,&apos;w&apos;) f2.write(&apos;&apos;) f2.close() f1.close()def monitorForBlog(name,pipe): lastTimeStr = &apos;&apos; while True: time.sleep(3) os.chdir(&apos;/Users/jdjr/Documents/Blog/blogsource&apos;) # os.chdir(&apos;/usr/local/var/www&apos;) (status, output) = commands.getstatusoutput(&apos;git pull origin blog&apos;) (status, output) = commands.getstatusoutput(&apos;git log&apos;) f = open(&apos;/Users/jdjr/Documents/Blog/logcommit.txt&apos;,&apos;w&apos;) f.write(output) f.close() f1 = open(&apos;/Users/jdjr/Documents/Blog/logcommit.txt&apos;,&apos;r&apos;) lines = f1.readlines() firstline = lines[0] f1.close() if lastTimeStr != firstline: print &apos;推送一次博客&apos; sourcepath = &apos;/Users/jdjr/Documents/Blog/blog/source&apos; if os.path.exists(sourcepath): shutil.rmtree(sourcepath) shutil.copytree(&apos;/Users/jdjr/Documents/Blog/blogsource/source&apos;,&apos;/Users/jdjr/Documents/Blog/blog/source&apos;) os.chdir(&apos;/Users/jdjr/Documents/Blog/blog&apos;)# os.popen(&apos;hexo clean&apos;) os.system(&apos;hexo clean&apos;) os.system(&apos;hexo g&apos;) filepath = &apos;/usr/local/var/www&apos; if os.path.exists(filepath): shutil.rmtree(filepath) publicfile = &apos;/Users/jdjr/Documents/Blog/blog/public&apos; while not os.path.exists(publicfile): time.sleep(1)# print &apos;not exist&apos; shutil.move(publicfile,filepath) lastTimeStr = firstline print lastTimeStrdef main(): print &apos;main pid: %d, ppid: %d&apos; % (os.getpid(), os.getppid()) # 注意： 此处是Pipe来自multiprocessing.Pipe(), 其来源于 multiprocessing.connection import Pipe pipe_parent, pipe_child = multiprocessing.Pipe(duplex=False) processList = []# for i in xrange(4):# pro = multiprocessing.Process(target=func, args=(&apos;ceshi&apos;, &apos;Process-&apos; + str(10), pipe_child))# pro.start()# processList.append(pro)# # pro1 = multiprocessing.Process(target=func1, args=(&apos;waha&apos;,pipe_child))# pro1.start()# processList.append(pro1)# # pro2 = multiprocessing.Process(target=func2, args=(&apos;heihei&apos;,pipe_child))# pro2.start()# processList.append(pro2) pro3 = multiprocessing.Process(target=serverForPull, args=(&apos;heihei&apos;,pipe_child)) pro3.start() processList.append(pro3) pro4 = multiprocessing.Process(target=monitorForBlog, args=(&apos;heihei&apos;,pipe_child)) pro4.start() processList.append(pro4) for pro in processList: pro.join() # 在此处阻塞子进程，可实现异步执行效果，直至子进程全部完成后再继续执行父进程 pipe_child.send(None) # 此处等全部子进程执行完成后，输入&apos;None&apos;标记，表示Pipe结束接收任务，可以退出 while pipe_parent: p_info = pipe_parent.recv() print &apos;pipe get: &apos;, p_info if not p_info: # 如果接收到了&apos;None&apos;标记，退出Pipe print &apos;pipe get: None, then exit out.&apos; break# 测试if __name__ == &apos;__main__&apos;: main() print(&apos;end.&apos;)]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下使用virtualbox安装win7以及设置共享文件]]></title>
    <url>%2F2017%2F05%2F25%2F2017%2Fmac%E4%B8%8B%E4%BD%BF%E7%94%A8virtualbox%E5%AE%89%E8%A3%85win7%E4%BB%A5%E5%8F%8A%E8%AE%BE%E7%BD%AE%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[安装首先进入win7-pe环境，然后进行分区，这里的关键在于c盘要大于10G 设置共享文件夹要实现mac与windows的文件共享，信息互通，需要有一个都可以访问的文件夹，这里的关键是，要首先安装virtualbox的device下的insert Guest Additions CD image]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Django的平台构建笔记(2)]]></title>
    <url>%2F2017%2F05%2F18%2F2017%2F%E5%9F%BA%E4%BA%8EDjango%E7%9A%84%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0(2)%2F</url>
    <content type="text"><![CDATA[python中Json字符串的创建与javascript中json字符串的转换 1234567891011121314import jsondef getindex(indexname): datas = [] for item in namelist: pes.append(dic) pes = json.dumps(pes) datas.append(pes) datas = json.dumps(datas) return datas 仔细看上边这段python我们能得出来一个结论，我们可以使用json这个功能，将一个python中的列表，转换为一段字符串，然后返回出去，这个字符串就是一段json字符串，我们可以将这段json字符串反过来转换成一个数组 下面我们来瞅瞅，如何将一个json字符串转换为一个json数组 首先说明基本功能： dumps是将dict转化成str格式，loads是将str转化成dict格式。 dump和load也是类似的功能，只是与文件操作结合起来了。 看代码实例： 1234567891011121314In [1]: import jsonIn [2]: a = &#123;&apos;name&apos;: &apos;wang&apos;, &apos;age&apos;: 29&#125;In [3]: b = json.dumps(a)In [4]: print b, type(b)&#123;&quot;age&quot;: 29, &quot;name&quot;: &quot;wang&quot;&#125; &lt;type &apos;str&apos;&gt;In [11]: json.loads(b)Out[11]: &#123;u&apos;age&apos;: 29, u&apos;name&apos;: u&apos;wang&apos;&#125;In [12]: print type(json.loads(b))&lt;type &apos;dict&apos;&gt; 然后再看dump和dumps的区别，见代码： 12345678910111213141516In [1]: import jsonIn [2]: a = &#123;&apos;name&apos;: &apos;wang&apos;, &apos;age&apos;: 29&#125;In [3]: b = json.dumps(a)In [4]: print b, type(b)&#123;&quot;age&quot;: 29, &quot;name&quot;: &quot;wang&quot;&#125; &lt;type &apos;str&apos;&gt;In [5]: c = json.dump(a)---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-5-92dc0d929363&gt; in &lt;module&gt;()----&gt; 1 c = json.dump(a)TypeError: dump() takes at least 2 arguments (1 given) 这里提示我们少一个参数，我们看一下帮助文件（iPyhton中可以直接使用help(json.dumps)来查看帮助文件）： dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=’utf-8’, default=None, sort_keys=False, **kw)Serialize obj to a JSON formatted str. dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=’utf-8’, default=None, sort_keys=False, **kw)Serialize obj as a JSON formatted stream to fp (a.write()-supporting file-like object). 简单说就是dump需要一个类似于文件指针的参数（并不是真的指针，可称之为类文件对象），可以与文件操作结合，也就是说可以将dict转成str然后存入文件中；而dumps直接给的是str，也就是将字典转成str。 例子见代码（注意文件操作的一些小细节）： 12345678910111213141516171819202122232425262728293031323334353637In [1]: import jsonIn [2]: a = &#123;&apos;name&apos;: &apos;wang&apos;&#125;In [3]: fp = file(&apos;test.txt&apos;, &apos;w&apos;)In [4]: type(fp)Out[4]: fileIn [5]: json.dump(a, fp)In [6]: cat test.txtIn [7]: fp.close()In [8]: cat test.txt&#123;&quot;name&quot;: &quot;wang&quot;&#125;In [9]: json.load(fp)---------------------------------------------------------------------------ValueError Traceback (most recent call last)&lt;ipython-input-9-0064dabedb17&gt; in &lt;module&gt;()----&gt; 1 json.load(fp)/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/__init__.pyc in load(fp, encoding, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)285286 &quot;&quot;&quot;--&gt; 287 return loads(fp.read(),288 encoding=encoding, cls=cls, object_hook=object_hook,289 parse_float=parse_float, parse_int=parse_int,ValueError: I/O operation on closed fileIn [10]: fp = file(&apos;test.txt&apos;, &apos;r&apos;)In [11]: json.load(fp)Out[11]: &#123;u&apos;name&apos;: u&apos;wang&apos;&#125;注：实际中dump用的较少。 javascript中如何将一段json字符串转换为json对象var obj = JSON.parse(data); web中上传文件，带进度条的做法1234567891011121314&lt;div id=&quot;upload&quot;&gt; &lt;form&gt; &#123;% csrf_token %&#125; &lt;input type=&quot;file&quot; id=&apos;file&apos; class=&apos;file&apos; style=&quot;margin-top: 5px;margin-left: 10px&quot; name=&quot;file&quot;&gt;&lt;br&gt; &lt;div id=&apos;1&apos; style=&quot;margin-top: 40px;margin-left: 10px;height:10px;width:200px;border-color: rgba(110,3,120,1);border:1px solid gray;float:left;margin-right:10px;&quot;&gt; &lt;div id=&apos;2&apos; style=&quot;height:100%;width:0px;background:rgba(220,220,220,1);&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;a style=&quot;position: absolute;top: 72px;;margin-right:25px&quot; id=&apos;3&apos;&gt;0%&lt;/a&gt; &lt;button type=&quot;button&quot; style=&quot;margin-top: 32px;margin-left: 50px;&quot; onclick=&quot;upload();&quot;&gt;上传&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; 是要定义一个file,下边是js的代码，我们来实现上传功能 12345678910111213141516171819function upload() &#123; var apktextinput = document.getElementById(&apos;apkname&apos;) var apkname = apktextinput.value if (apkname.length == 0) &#123; alert(&apos;请输入证书名称&apos;) return &#125; var xhr = new XMLHttpRequest(); var file = document.getElementById(&apos;file&apos;).files[0]; //取得文件数据，而.file对象只是文件信息 var form = new FormData(); //FormData是HTML5为实现序列化表单而提供的类，更多细节可自行查询 form.append(&apos;file&apos;,file); //这里为序列化表单对象form添加一个元素，即file xhr.upload.addEventListener(&apos;progress&apos;,on_progress,false); //xhr对象含有一个upload对象，它有一个progress事件，在文件上传过程中会被不断触发，我们为这个事件对应一个处理函数，每当事件触发就会调用这个函数，于是便可利用这个函数来修改当前进度，更多细节可自行查询 xhr.open(&apos;POST&apos;,&apos;http://10.13.8.12:89/uploadAPK/&apos;,true); //请将url改成上传url xhr.setRequestHeader(&apos;X-CSRFTOKEN&apos;,&apos;&#123;&#123; request.COOKIES.csrftoken &#125;&#125;&apos;); //此处为Django要求，可无视，或者换成相应后台所要求的CSRF防护，不是django用户请去掉 xhr.send(form); //发送表单 &#125; 重点是xhr.upload.addEventListener(&#39;progress&#39;,on_progress,false);这个方法会保证上传过程中不断的回调我们来实现on_progress 123456789101112131415161718192021222324252627282930313233343536function on_progress(evt) &#123; //看这个函数之前先看upload函数。这个函数可以接收一个evt(event)对象(细节自行查询progress)，他有3个属性lengthComputable，loaded，total，第一个属性是个bool类型的，代表是否支持，第二个代表当前上传的大小，第三个为总的大小，由此便可以计算出实时上传的百分比 if(evt.lengthComputable) &#123; var ele = document.getElementById(&apos;2&apos;); var percent = Math.round((evt.loaded) * 100 / evt.total); if (percent == 100 &amp;&amp; strongapk == 1) &#123; strongapk = 0 var textcontent = document.getElementById(&quot;wating&quot;) textcontent.style.display = &apos;block&apos; var apktextinput = document.getElementById(&apos;apkname&apos;) var apkname = apktextinput.value $.ajax(&#123; url: &quot;/startstrongapk/&quot;, //后台webservice里的方法名称 data:&#123;&quot;apkname&quot;:apkname&#125;, type: &quot;post&quot;, traditional: true, success: function (data) &#123; downloadurl = data alert(data) $(&quot;#wating&quot;).css(&apos;display&apos;,&apos;none&apos;); if (confirm(&quot;你确定要下载文件吗？&quot;)) &#123; self.location=(&apos;downloadsdk?url=&apos; + data) &#125; &#125;, error: function (msg) &#123; alert(msg) $(&quot;#wating&quot;).css(&apos;display&apos;,&apos;none&apos;); &#125; &#125;); &#125; ele.style.width = percent + &apos;%&apos;; document.getElementById(&apos;3&apos;).innerHTML = percent + &apos;%&apos;; &#125; &#125; 这里我们在percent达到100之后，调用ajax做一些事情 django中接口调用的方式总结网络方法调用大致有这么几种 点击按钮跳转新页面这种直接用标签，然后用href就好 1&lt;a class=&quot;button&quot; id=&quot;ios&quot; style=&quot;position: absolute;top: 50px;&quot; href=&quot;jinkensios&quot; onmouseover=&quot;showDetailText(this)&quot; onmouseout=&quot;clearTest()&quot;&gt;● 打包(iOS)&lt;/a&gt; 点击按钮刷新局部数据这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用12345678$(document).ready(function()&#123; $(&quot;#btn&quot;).click(function()&#123; string = $(&quot;#textarea1&quot;).val() $.get(&quot;/ajaxcreateui/&quot;, &#123;&apos;text&apos;: string&#125;,function(ret)&#123; $(&apos;#textarea2&apos;).html(ret) &#125;) &#125;); &#125;); $(document).ready(function(){}预先埋伏的写法要写在这句代码里边 $(&quot;#btn&quot;).click(function(){}这个是预先埋伏 $.get(&quot;/ajaxcreateui/&quot;, {&#39;text&#39;: string},function(ret){}ajax的get调用 直接使用XMLHttpRequest123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var progresshttp;function getprogress() &#123; progresshttp=null; if (window.XMLHttpRequest) &#123;// code for all new browsers progresshttp=new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123;// code for IE5 and IE6 progresshttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; if (progresshttp!=null) &#123; progresshttp.onreadystatechange=progressstate_Change; progresshttp.open(&quot;POST&quot;,&apos;getpackprogress&apos;,false); var formData = new FormData(); formData.append(&apos;branchname&apos;, branchname); progresshttp.send(formData); &#125; else &#123; alert(&quot;Your browser does not support XMLHTTP.&quot;); &#125;&#125;function progressstate_Change()&#123;if (progresshttp.readyState==4) &#123;// 4 = &quot;loaded&quot; if (progresshttp.status==200) &#123;// 200 = OK num = this.responseText var ele = document.getElementById(&apos;12&apos;); var percent = num * 100; percent = percent.toFixed(2) if (percent &gt;= 100.00) &#123; percent = 100.00 &#125; ele.style.width = percent + &apos;%&apos;; document.getElementById(&apos;13&apos;).innerHTML = percent + &apos;%&apos;; if (percent &gt;= 100) &#123; window.clearInterval(waitinterval) ele.style.width = 100 + &apos;%&apos;; var text = document.getElementById(&apos;building&apos;) text.innerHTML = &quot;&quot; &#125; &#125; else &#123; alert(&quot;Problem retrieving XML data&quot;); &#125; &#125;&#125; 添加回调的方式 xhr.upload.addEventListener(&#39;progress&#39;,on_progress,false);进度条 progresshttp.onreadystatechange=progressstate_Change事件回调 某个事件调用结束刷新局部数据直接使用ajax或者XMLHttpRequest就好 python中调用命令行随时输出的做法12345678910111213p = subprocess.Popen(&quot;gradle assembleDebug&quot;,shell=True,stdout=subprocess.PIPE)indexcount = 0returncode = p.poll()while returncode is None: text = p.stdout.readline().strip() f = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;a&apos;)#追加打开方式 f.write(text) f.close() returncode = p.poll()]]></content>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb使用小结]]></title>
    <url>%2F2017%2F05%2F17%2F2017%2Fmongodb%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[创建一个mongo数据库 123456from pymongo import MongoClientimport json,timeconnection = MongoClient(&quot;localhost&quot;,27017)mydb = connection.mydb # new a databasemyser = mydb.allindex # new a table 查12345678910111213dicn = &#123;&#125;dicn[&apos;indexname&apos;] = itemdicn[&apos;date&apos;] = dateStringdbs = myser.find(dicn)for item in dbs: dic = &#123;&#125; datestring = item[&apos;date&apos;] datestring = datestring.encode(&apos;utf-8&apos;) dic[&apos;date&apos;] = datestring dic[&apos;earyeild&apos;] = item[&apos;earyeild&apos;] dic[&apos;indexname&apos;] = item[&apos;indexname&apos;] MongoDB提供了一组比较操作符：$lt/$lte/$gt/$gte/$ne，依次等价于&lt;/&lt;=/&gt;/&gt;=/!=。 下面的示例返回符合条件age &gt;= 18 &amp;&amp; age &lt;= 40的文档。 12&gt; db.test.find(&#123;&quot;age&quot;:&#123;&quot;$gte&quot;:18, &quot;$lte&quot;:40&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125; 下面的示例返回条件符合name != “stephen1” 12&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$ne&quot;:&quot;stephen1&quot;&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125; $in等同于SQL中的in，下面的示例等同于SQL中的in (“stephen”,”stephen1”) 12&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$in&quot;:[&quot;stephen&quot;,&quot;stephen1&quot;]&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125; 和SQL不同的是，MongoDB的in list中的数据可以是不同类型。这种情况可用于不同类型的别名场景。 12&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$in&quot;:[&quot;stephen&quot;,123]&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125; $nin等同于SQL中的not in，同时也是$in的取反。如： 12&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$nin&quot;:[&quot;stephen2&quot;,&quot;stephen1&quot;]&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125; $or等同于SQL中的or，$or所针对的条件被放到一个数组中，每个数组元素表示or的一个条件。下面的示例等同于name = “stephen1” or age = 35 12&gt; db.test.find(&#123;&quot;$or&quot;: [&#123;&quot;name&quot;:&quot;stephen1&quot;&#125;, &#123;&quot;age&quot;:35&#125;]&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125; 下面的示例演示了如何混合使用$or和$in。 12&gt; db.test.find(&#123;&quot;$or&quot;: [&#123;&quot;name&quot;:&#123;&quot;$in&quot;:[&quot;stephen&quot;,&quot;stephen1&quot;]&#125;&#125;, &#123;&quot;age&quot;:36&#125;]&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125; $not表示取反，等同于SQL中的not。 12&gt; db.test.find(&#123;&quot;name&quot;: &#123;&quot;$not&quot;: &#123;&quot;$in&quot;:[&quot;stephen2&quot;,&quot;stephen1&quot;]&#125;&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125; 增1myser.save(&#123;&apos;指数名称&apos;:item,&apos;市盈率&apos;:pe,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;市净率&apos;:pb,&apos;股息率&apos;:rate&#125;) 时间的用法1234567891011121314current = time.localtime(time.time())year = current.tm_yearmonth = current.tm_monday = current.tm_mdayyearStr = &apos;%i&apos; % yearyearList = list(yearStr)yearStr1 = yearList[-1]yearStr2 = yearList[-2]yearStr = yearStr2 + yearStr1monthStr = months[month - 1]targetStr = &apos;idx_%i%s%s&apos; % (day,monthStr,yearStr)]]></content>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS工程小知识]]></title>
    <url>%2F2017%2F02%2F26%2F2017%2FiOS%E5%B7%A5%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1:出现（ linker command failed with exit code 1）如果具体的错误是这个与第三方.a库重复，那么要更改的是，类名和全局变量的名字 2.SEGV_ACCERR错误说明对象被过度释放，查看是否有在=nil之后又使用了该对象，比如说这段代码case MessageComposeResultSent: { //信息传送成功// [JRMsgShow showMsg:@”发送成功”]; if (self.closeBlock) { self.closeBlock(); } if (self.messageSuccessBlock) { self.messageSuccessBlock(); } [[UIApplication sharedApplication].keyWindow.rootViewController dismissViewControllerAnimated:YES completion:nil]; } 很明显前边我们使用了closeblock，这个block之行之后，很快self会死掉，而这个之后我们又使用了self.messageSuccessBlock这样再次使用self，必然导致崩溃，不过这是在iOS8上面，在iOS9和10上就没有这个问题，说明苹果做了系统级的优化 3.参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时检查网页更新并发送微信消息]]></title>
    <url>%2F2017%2F02%2F16%2F2017%2F%E5%AE%9A%E6%97%B6%E6%A3%80%E6%9F%A5%E7%BD%91%E9%A1%B5%E6%9B%B4%E6%96%B0%E5%B9%B6%E5%8F%91%E9%80%81%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding: utf-8 -*-import urllib2,time,urllib while True: current = time.localtime(time.time()) year = current.tm_year month = current.tm_mon day = current.tm_mday hour = current.tm_hour minite = current.tm_min sec = current.tm_sec if sec == 0: downLoadStr = &apos;http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml&apos; print downLoadStr try: i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\ &quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125; req = urllib2.Request(downLoadStr, headers=i_headers) f = urllib2.urlopen(req) data = f.read() date = &apos;&apos; if month &lt; 10 and day &lt; 10: date = &apos;%i-0%i-0%i&apos; % (year, month, day) elif month &gt; 10 and day &lt; 10: date = &apos;%i-%i-0%i&apos; % (year, month, day) elif month &lt; 10 and day &gt; 10: date = &apos;%i-0%i-%i&apos; % (year, month, day) else: date = &apos;%i-%i-%i&apos; % (year, month, day) string = &apos;the web has update http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml&apos; print date if date in data: f = open(&apos;update.txt&apos;,&apos;w&apos;) f.write(date + string) f.close() print &apos;yes&apos; else: print &apos;no&apos; except Exception,ex: print ex#import itchat##itchat.auto_login()##itchat.send(&apos;Hello, filehelper&apos;, toUserName=&apos;filehelper&apos;)#while True:# f = open(&apos;update.txt&apos;,&apos;r&apos;)# text = f.read()# f.close()# if len(text) != 0:# f = open(&apos;update.txt&apos;,&apos;w&apos;)# f.write(&apos;&apos;)# f.close()# itchat.send(&apos;the web has update http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml&apos;, toUserName=&apos;Liu647ziqi&apos;)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指数自动获取]]></title>
    <url>%2F2017%2F02%2F16%2F2017%2F%E6%8C%87%E6%95%B0%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215# -*- coding: utf-8 -*-import urllib2,time,urllibimport ast,os,sys,stringfrom pymongo import MongoClientmonths = [&apos;Jan&apos;,&apos;Feb&apos;,&apos;Mar&apos;,&apos;Apr&apos;,&apos;May&apos;,&apos;Jun&apos;,&apos;Jul&apos;,&apos;Aug&apos;,&apos;Sep&apos;,&apos;Oct&apos;,&apos;Nov&apos;,&apos;Dec&apos;]dicts = &#123;&apos;zsgz00&apos;:&apos;no&apos;,&apos;zsgz10&apos;:&apos;上证指数&apos;,&apos;zsgz20&apos;:&apos;上证180&apos;,&apos;zsgz30&apos;:&apos;上证50&apos;,&apos;zsgz40&apos;:&apos;沪深300&apos;,&apos;zsgz50&apos;:&apos;深证成指&apos;,&apos;zsgz60&apos;:&apos;深证100R&apos;,&apos;zsgz70&apos;:&apos;中小板指&apos;,&apos;zsgz80&apos;:&apos;上证380&apos;,&apos;zsgz90&apos;:&apos;红利指数&apos;,&apos;zsgz100&apos;:&apos;中证红利&apos;,&apos;zsgz110&apos;:&apos;中证500&apos;&#125;connection = MongoClient(&quot;localhost&quot;,27017)mydb = connection.mydb # new a databasemyser = mydb.hengsengindex # new a tabledef getindexs(): downLoadStr = &apos;http://www.csindex.com.cn/sseportal/ps/zhs/hqjt/csi/show_zsgz.js&apos; print downLoadStr try: i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\ &quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125; req = urllib2.Request(downLoadStr, headers=i_headers) f = urllib2.urlopen(req) data = f.read() str = data.decode(&apos;gbk&apos;) data = str.encode(&apos;utf-8&apos;) print data listString = data.split(&apos;\n&apos;) date = &apos;&apos; index = 0 for item in listString: if &apos;zsgz00&apos; in item: date = item[12:-2] datelist = list(date) for s in datelist: if s == &apos;-&apos;: datelist.remove(s) date = &apos;&apos;.join(datelist) print date if &apos;0=&apos; in item: pe = listString[index + 1] pb = listString[index + 3] rate = listString[index + 4] indexitem = item.index(&apos;=&apos;) indexpe = pe.index(&apos;=&apos;) indexpb = pb.index(&apos;=&apos;) indexrate = rate.index(&apos;=&apos;) pe = pe[indexpe+2:-2] pb = pb[indexpe+2:-2] rate = rate[indexpe+2:-2] item = item[indexitem+2:-2] print item pe = filter(lambda ch: ch in &apos;.0123456789&apos;, pe) pb = filter(lambda ch: ch in &apos;.0123456789&apos;, pb) rate = filter(lambda ch: ch in &apos;.0123456789&apos;, rate) if len(pe) and len(pb) and len(rate): roaf = float(pe) roe = 1/roaf * 100 dbs = myser.find(&#123;&apos;指数名称&apos;:item,&apos;日期&apos;:date&#125;) count = 0 for item in dbs: count = count + 1 if count == 0: myser.save(&#123;&apos;指数名称&apos;:item,&apos;市盈率&apos;:pe,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;市净率&apos;:pb,&apos;股息率&apos;:rate&#125;) index = index + 1 except Exception,ex: print exdef gethenghseng(day,month,year):yearStr = &apos;%i&apos; % yearyearList = list(yearStr)yearStr1 = yearList[-1]yearStr2 = yearList[-2]yearStr = yearStr2 + yearStr1monthStr = months[month - 1]targetStr = &apos;idx_%i%s%s&apos; % (day,monthStr,yearStr)fileName = &apos;/Users/han/Desktop/index/hengsheng/%i%s%s.txt&apos; % (day,monthStr,yearStr)downLoadStr = &apos;http://sc.hangseng.com/gb/www.hsi.com.hk/HSI-Net/static/revamp/contents/en/indexes/report/hsi/&apos; + targetStr + &apos;.csv&apos;print downLoadStrtry:i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\&quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125;req = urllib2.Request(downLoadStr, headers=i_headers)f = urllib2.urlopen(req)data = f.read()f = open(fileName,&apos;wb&apos;)f.write(data)f.close()f1 = open(fileName,&apos;rb&apos;)dataList = f1.readlines()item = dataList[2]list2 = item.split(&apos; &apos;)date = list2[0]index = list2[5]roa = list2[9]date = filter(lambda ch: ch in &apos;0123456789&apos;, date)index = filter(lambda ch: ch in &apos;.0123456789&apos;, index)string = filter(lambda ch: ch in &apos;.0123456789&apos;, roa)roaf = float(string)roe = 1/roaf * 100print dateprint indexdbs = myser.find(&#123;&apos;指数名称&apos;:&apos;恒生指数&apos;,&apos;日期&apos;:date&#125;)count = 0for item in dbs:count = count + 1if count == 0:myser.save(&#123;&apos;指数名称&apos;:&apos;恒生指数&apos;,&apos;市盈率&apos;:roaf,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;指数&apos;:index&#125;) # add a recordsaveStr = &apos;%s %f&apos; % (date, roe)f = open(&apos;hengseng.txt&apos;,&apos;r&apos;)data = f.read()f.close()dataStr = data + &apos;\n&apos; + saveStrf = open(&apos;hengseng.txt&apos;,&apos;w&apos;)f.write(dataStr)f.close()except Exception,ex:print exdef gethenghsengchina(day,month,year):yearStr = &apos;%i&apos; % yearyearList = list(yearStr)yearStr1 = yearList[-1]yearStr2 = yearList[-2]yearStr = yearStr2 + yearStr1monthStr = months[month - 1]targetStr = &apos;idx_%i%s%s&apos; % (day,monthStr,yearStr)fileName = &apos;/Users/han/Desktop/index/hengsheng/china%i%s%s.txt&apos; % (day,monthStr,yearStr)downLoadStr = &apos;http://sc.hangseng.com/gb/www.hsi.com.hk/HSI-Net/static/revamp/contents/en/indexes/report/hscei/&apos; + targetStr + &apos;.csv&apos;print downLoadStrtry:i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\&quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125;req = urllib2.Request(downLoadStr, headers=i_headers)f = urllib2.urlopen(req)data = f.read()f = open(fileName,&apos;wb&apos;)f.write(data)f.close()f1 = open(fileName,&apos;rb&apos;)dataList = f1.readlines()item = dataList[2]list2 = item.split(&apos; &apos;)date = list2[0]index = list2[5]roa = list2[9]date = filter(lambda ch: ch in &apos;0123456789&apos;, date)index = filter(lambda ch: ch in &apos;.0123456789&apos;, index)string = filter(lambda ch: ch in &apos;.0123456789&apos;, roa)roaf = float(string)roe = 1/roaf * 100print indexdbs = myser.find(&#123;&apos;指数名称&apos;:&apos;恒生指H&apos;,&apos;日期&apos;:date&#125;)count = 0for item in dbs:count = count + 1if count == 0:myser.save(&#123;&apos;指数名称&apos;:&apos;恒生指数H&apos;, &apos;市盈率&apos;:roaf,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;指数&apos;:index&#125;)saveStr = &apos;%s %f&apos; % (date, roe)f = open(&apos;hengsengchina.txt&apos;,&apos;r&apos;)data = f.read()f.close()dataStr = data + &apos;\n&apos; + saveStrf = open(&apos;hengsengchina.txt&apos;,&apos;w&apos;)f.write(dataStr)f.close()except Exception,ex:print exgetindexs()current = time.localtime(time.time())year = current.tm_yearmonth = current.tm_monday = current.tm_mdayindex = 0if month == 12:index = 1index = month - 1day = day - 1# gethenghseng(day,month,year)for month in xrange(1,3):for day in xrange(1,31):gethenghsengchina(day,month,year)gethenghseng(day,month,year)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫系列]]></title>
    <url>%2F2017%2F02%2F10%2F2017%2F%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[这里主要实现的是利用爬虫来实现对关注指数基金的估值数据的抓取，然后进行估值分析，配合云服务器并且每天进行推送。 爬虫的基本步骤很简单，将该网页的js和html全部下载下来，然后从其中寻找有用的信息，进而将有用的信息进行结构化的存储，其中将网页爬取下来使用的scrapy，而寻找信息我们使用的是xpath，存储我们使用mongo 使用scrapy框架 安装sudo pip install scrapy或者直接下载源码，自己编译*下载0.24版本的scrapyhttp://scrapy.org/download/然后cd 进入解压后的文件，然后执行sudo python setup.py install安装scrapy 如果在使用命令行过程中发现sudo之后仍然无法获取权限，删除文件时会提示Operation not permitted，那就关机重启，然后按住comman+R，启动之后启动命令行，输入，csrutil disable关闭rootless就可以了 scrapy startproject tutorial创建爬虫工程 scrapy.cfg: 项目的配置文件 tutorial/: 该项目的python模块。之后您将在此加入代码。 tutorial/items.py: 项目中的item文件. tutorial/pipelines.py: 项目中的pipelines文件. tutorial/settings.py: 项目的设置文件. tutorial/spiders/: 放置spider代码的目录. 文件作用说明 items.py：定义后期处理的数据，是一个容器，像一个字典 settings.py：配置scrapy，从而修改user-agent,设置爬取时间，设置代理，设置中间件 pipelines.py:用于存放执行后去数据处理的功能，从而把爬取与处理分开item成功获取数据之后，它会送到pipeline，让pipeline对数据进行处理 运行工程：scrapy目前只能使用命令行来运行scrapy crawl demo这里要注意的是后边的这个demo这个名字不是随便来的，spider这个文件命名要是demo_spider才可以 xpath的使用用到的工具： 火狐浏览器 FirePath插件 Firebug插件 XPath Checker插件 1.右键选择－Inspect in FirePath2.复制xpath3.在该页面上右键－&gt;View XPath4.把xpath的路径复制进入该页面，查看是否能够找到自己想要的元素 mongodb的安装以及使用 一行代码安装mongodbbrew install mongoDB前提是已经安装了brew工具，一次失败就执行第二次*如果上边的方法还是不行，那就只能手动下载了 https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.2.3.tgz 命令行解压该包tar xzvf mongodb-osx-x86_64-3.2.3.tgz 将解压后的文件放到一个可以长期放置的地方，然后进入该文件夹 pwd记录当前文件路径，copy一下，一会儿有用 vim ~/.zshrc进入配置目录#mongod configMONGODB_HOME=/Users/shenghuihan/Desktop/mongodb-osx-x86_64-3.2.3PATH=$PATH:$MONGODB_HOME/bin添加bin目录文件到系统搜索目录下 source ~/.zshrc使设置生效 查看mongo是否生效mongo，如果显示版本号说明生效，但是没有启动下面我们来启动服务 先在同级目录下创建数据文件和日志文件mkdir data和mkdir log 启动mongodb服务mongod –dbpath data –logpath log/mongod.log –logappend –fork 再次mongo如果显示connecting to test说明启动成功，输入exit;退出mongo 将启动命令写入一个启动脚本中echo “mongod –dbpath data –logpath log/mongod.log –logappend –fork” &gt;&gt; start.sh 可视化工具安装https://mongohub.s3.amazonaws.com/MongoHub.zip直接去这里下载 安装python操作mongodb的驱动sudo pip install pymongo前提是要安装pip啊，这是一个专门用来安装python各种库的软件 默认端口27017 查看ip的方式，db.getMongo() 使用mongodb命令行12345678910bogon:mongo shenghuihan$ mongoMongoDB shell version: 3.2.3connecting to: testServer has startup warnings: 2016-09-08T17:51:01.057+0800 I CONTROL [initandlisten] 2016-09-08T17:51:01.057+0800 I CONTROL [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000&gt; use mydb//创建一个新的库switched to db mydb&gt; show collections&gt; show dbs 使用以及查看数据我们可以使用mongohub查看数据，当然还可以使用我们最喜欢的python1234567891011121314import pymongoconnection = pymongo.MongoClient()tdb = connection.jikexueyuanpost_info = tdb.ceshijike = &#123;&apos;name&apos;:u&apos;哈哈哈&apos;&#125;#插入数据goog = &#123;&apos;name&apos;:u&apos;校长&apos;&#125;# post_info.insert(jike)# post_info.insert(goog)post_info.remove(&#123;&apos;name&apos;:u&apos;校长&apos;&#125;)print u&apos;操作完成&apos; 1234567891011121314from pymongo import MongoClientmc = MongoClient(&quot;localhost&quot;,27017)db = mc.usersc = db.users.find()db.users.save(&#123;&quot;age&quot;:8&#125;)for objc in c: print(objc)mc.close()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lunix云服务器折腾小记]]></title>
    <url>%2F2017%2F01%2F17%2F2017%2FLunix%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Mac登录云服务器1ssh root@127.987.883.888 这样再输入密码我们就进入了我们的服务器的命令行界面，这里执行的命令行与本机是一致的，不过你看到的是你服务器的一些情况 文件的上传和下载 上传1scp ceshi.txt root@127.987.883.888:~ 这样文件会被传输到你的用户名下的文件夹下 下载1scp root@127.987.883.888:~／ceshi.txt ceshi.txt apache安装-1. 运行 Terminal，输入命令：1ssh username@ip，然后输入密码。 安装 Apache 软件： 1yum install httpd 设置 Apache 在服务器启动时运行： 1chkconfig --levels 235 httpd on 在 Apache 配置文件中配置域名： 1vi /etc/httpd/conf/httpd.conf，找到 ServerName ，添加“域名:80”，保存并退出。 重启 Apache： 1service httpd restart 浏览器中访问第4步配置的域名，如果出现“Apache 2 Test Page powered by CentOS”的页面，说明配置成功。 django安装 安装pipsudo yum install python-pip pip安装 1sudo pip install --upgrade django==1.11 重新格式化云服务器之后登录不上怎么办将本地的./ssh文件夹中的know_hosts里边对应的ip的记录删除掉，重新生成 lunix中的复制文件以及文件夹1cp -r xxx xxx -r代表我们复制其中的所有文件以及文件夹 lunix删除文件1rm -rf xxx 在python 的django服务不可用查看 lunix升级python123456789101112131415161718192021222324252627282930313233343536373839首先下载源tar包 可利用linux自带下载工具wget下载，如下所示：1# wget http://www.python.org/ftp/python/2.7.3/Python-2.7.3.tgz 下载完成后到下载目录下，解压1 tar -zxvf Python-2.7.3.tgz2 进入解压缩后的文件夹1 cd Python-2.7.3 在编译前先在/usr/local建一个文件夹python27（作为python的安装路径，以免覆盖老的版本）1 mkdir /usr/local/python27 在解压缩后的目录下编译安装1 ./configure --prefix=/usr/local/python272 make3 make install 此时没有覆盖老版本，再将原来/usr/bin/python链接改为别的名字1 mv /usr/bin/python /usr/bin/python_old 再建立新版本python的链接1ln -s /usr/local/python27/bin/python2.7 这个时候输入1 python 就会显示出python的新版本信息1 Python 2.7.3 (default, Sep 29 2013, 11:05:02)2 [GCC 4.1.2 20080704 (Red Hat 4.1.2-54)] on linux23 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.4 &gt;&gt;&gt;修改YUM /usr/bin/yum文件让yum能正常的工作：改成上面我们修改的PYTHON 2.6.6的名字 lunix解压命令12345678910111213141516171、*.tar 用 tar -xvf 解压2、*.gz 用 gzip -d或者gunzip 解压3、*.tar.gz和*.tgz 用 tar -xzf 解压4、*.bz2 用 bzip2 -d或者用bunzip2 解压5、*.tar.bz2用tar -xjf 解压6、*.Z 用 uncompress 解压7、*.tar.Z 用tar -xZf 解压8、*.rar 用 unrar e解压9、*.zip 用 unzip 解压 安装apex12345678910111213141516171819lunix 安装apxs扩展好像命令行安装的，自带了这个模块，手动编译的apache，同样需要手动编译这个模块，编译的时候可能会遇到这个错误：mod_wsgi.c Python.h：没有那个文件或目录,，解决方法：yum install python-devel，安装apache的apxs扩展。python 2.7 No module named ‘zlib&apos;yum -y install zlib-devel openssl-develcd /wls/softwares/Python-2.7.10./configure --prefix=/usr/local/python27 make make installpip是python的包管理工具，我们通过pip来安装python所需要的一些模块，当然如果你有多版本存在，可能需要将pip这个模块copy到对应的python版本下边在安装 Linux 系统是顺便把apache 服务装好了 ，这时这是装了一个服务不能进行二次开发，所以很多的开发工具和文件在apache下找不到，比如模块编译工具apxs ，这时就要求安装 开发包，命令 rpm -ql httpd-devel ，然后会在 usr/local/下面多出个 apache2文件夹，里面有不少开发需要的文件。如果提示没有apxs，那就先yum install httpd-devel lunix 安装git123456789101112131415161718192021222324252627282930313233343536373839404142431.2 CentOS6.6下在CentOS5的时代，由于yum源中没有git，所以需要预先安装一系列的依赖包。但在CentOS6的yum源中已经有git的版本了，可以直接使用yum源进行安装。$ sudo yum install git但是yum源中安装的git版本是1.7.1，太老了，Github等需要的Git版本最低都不能低于1.7.2 。所以我们一般不用上面的方法。而是下载git源码，编译安装。编译安装的步骤是【4】：（1）首先先更新系统sudo yum update（2）安装依赖的包sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker（3）下载git源码并解压缩$ wget https://github.com/git/git/archive/v2.3.0.zip$ unzip v2.3.0.zip$ cd git-2.3.0（4）编译安装将其安装在“/usr/local/git”目录下。make prefix=/usr/local/git allsudo make prefix=/usr/local/git install（5）此时你如果使用git --version 查看git版本的话，发现git仍然是1.7.1版本。这是因为它默认使用了&quot;/usr/bin&quot;下的git。你可以用下面的命令查看git所在的路径：$ whereis gitgit: /usr/bin/git /usr/local/git /usr/share/man/man1/git.1.gz（6）我们要把编译安装的git路径放到环境变量里，让它替换&quot;/usr/bin&quot;下的git。为此我们可以修改“/etc/profile”文件（或者/etc/bashrc文件）。sudo vim /etc/profile然后在文件的最后一行，添加下面的内容，然后保存退出。export PATH=/usr/local/git/bin:$PATH（7）使用source命令应用修改。source /etc/profile（8）然后再次使用git --version 查看git版本，发现输出2.3.0，表明安装成功。 django错误123456789101112131415161718192021222324252627DisallowedHost at /Invalid HTTP_HOST header: &apos;10.211.55.6:8000&apos;. You may need to add u&apos;10.211.55.6&apos; to ALLOWED_HOSTS.Request Method: GETRequest URL: http://10.211.55.6:8000/Django Version: 1.10.4Exception Type: DisallowedHostException Value: Invalid HTTP_HOST header: &apos;10.211.55.6:8000&apos;. You may need to add u&apos;10.211.55.6&apos; to ALLOWED_HOSTS.Exception Location: /usr/lib/python2.7/site-packages/django/http/request.py in get_host, line 113Python Executable: /usr/bin/pythonPython Version:1，以上时我访问请求的时候出现的，原因在于Django框架中的创建的一个项目的时候，2，跑下这个命令：Python manage.py runserver 10.211.55.5:80003，然后在我本机的浏览器中写入上述IP和端口请求过去：http://10.211.55.6:80004，于是就出现了最上面的那个问题；5，于是就去django-admin.py startproject project-name创建的项目中去修改 setting.py 文件：ALLOWED_HOSTS = [&apos;*&apos;] ＃在这里请求的host添加了＊6，于是就成功的访问到了Django的项目了； 配置django/etc/httpd/conf/httpd.confconf地址/etc/httpd/modules/mod_wsgi.soso文件地址/etc/httpd/extra/vhosts/dev.mysite.com.conf httpd.conf配置 记得修改user和group为www，这个www是你自己创建的用户，记得这个www要加到root下，然后将根文件更改所有者 记得添加你的端口到iptables中去 wsgi.py文件内容12345678910111213import osfrom os.path import join,dirname,abspathPROJECT_DIR = dirname(dirname(abspath(__file__)))#3import sys # 4sys.path.insert(0,PROJECT_DIR) # 5from django.core.wsgi import get_wsgi_applicationos.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;jdjrweb.settings&quot;)application = get_wsgi_application() /etc/httpd/extra/vhosts/dev.mysite.com.conf配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546Listen 80&lt;VirtualHost *:80&gt; LogLevel info ServerName 104.238.153.13 ServerAdmin my@mysite.com ErrorLog &quot;/root/jdjr/datalog/error_log&quot; CustomLog &quot;/root/jdjr/datalog/access_log&quot; common WSGIScriptAlias / /root/jdjr/jdjrweb/jdjrweb/wsgi.py #WSGIScriptAlias / /root/jdjr/jdjrweb &lt;Directory &quot;/root/jdjr/jdjrweb&quot;&gt; Require all granted &lt;/Directory&gt; Alias /static/ /root/jdjr/jdjrweb/jdjrweb/static/ &lt;Directory &quot;/root/jdjr/jdjrweb/jdjrweb/static/&quot;&gt; Require all granted &lt;/Directory&gt; &lt;Directory &quot;/root/jdjr/jdjrweb&quot;&gt; #Options Indexes FollowSymLinks #AllowOverride All #Order allow,deny Require all granted &lt;/Directory&gt; &lt;Directory &quot;/root/jdjr/datalog&quot;&gt; Require all granted &lt;/Directory&gt; &lt;Directory &quot;/root/jdjr/jdjrweb/jdjrweb&quot;&gt; &lt;Files wsgi.py&gt; Require all granted &lt;/Files&gt; &lt;/Directory&gt; #&lt;Files &quot;/root/jdjr/jdjrweb/jdjrweb/wsgi.py&quot;&gt; # Require all granted # &lt;/Files&gt;&lt;/VirtualHost&gt; 文件权限配置看/etc/httpd/conf/httpd.conf这个文件里边的user和group，这里配置的是apache，那么我们就要给我们用到的文件的用户切换到apache，然后给这个用户最高权限 sudo chmod -R u+wrx jdjr其中jdjr是我所用到的文件夹，-R代表递归所有子文件 ah01797: client denied by server configuration /wsgi.py假如报这个错误说明文件夹的权限配置不对，应该把下边我注释掉的那些东西去了就好了，只留下Require all granted 123456&lt;Directory &quot;/root/jdjr/jdjrweb&quot;&gt; #Options Indexes FollowSymLinks #AllowOverride All #Order allow,deny Require all granted&lt;/Directory&gt;]]></content>
      <tags>
        <tag>Lunix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Andorid自动打包gradle安装笔记]]></title>
    <url>%2F2016%2F12%2F16%2F2017%2FAndorid%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85gradle%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[安装andorid studio copy一份sdk过来 设置andorid studio的sdk路径 安装sdkman 在控制台或者item2中输入 12curl -s https://get.sdkman.io | bashsource &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot; 检验sdkman是否安装成功 1sdk version 安装andorid studio中认可的gradle版本 1sdk install gradle 2.8 升级jdk到andorid studio认可的版本比如说1.7 到工程根目录，执行gradle build就可以了’gradle assembleDebug’ 打包出来的文件在outputs中]]></content>
      <tags>
        <tag>andorid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Django的自动化平台构建笔记(1)]]></title>
    <url>%2F2016%2F12%2F15%2F2017%2F%E5%9F%BA%E4%BA%8EDjango%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0(1)%2F</url>
    <content type="text"><![CDATA[现在提供的服务主要有： 根据property创建UI代码 JSON自动转模型 自动打包服务 其他效率工具的链接 其中最重要的，也是最复杂的应该是自动打包的服务，这套服务用python语言来实现，基于python的django框架，其中django框架主要用来提供web服务，用来给用户访问，而服务的执行者，比如说UI的代码创建，需要用到字符串解析等功能，完全由python在服务器端来完成，我们通过网络将需要解析的数据发送给服务器，然后服务器做完处理之后，再通过网络将数据返回，然后通过django来完成展示。再到打包服务也是这种逻辑，通过web服务来发送指令给服务器，然后服务器调用命令行来完成打包的具体的动作 Django使用简解Django是一个python的项目，我们可以使用WebStorm来编辑该项目。当运行的时候会生成一个本地的web服务，我们可以通过该地址，在浏览器访问这个服务，当然我们也可以在命令行来达到同样的效果，进入到项目根目录，manager.py的所在目录，执行python manager.py runserver，然后点击给出的地址，我们仍然可以查看服务。 对于这个新建的django工程我们主要关注的是两个文件，一个是ProjectName/urls.py，另一个是appName/views.py。 urls.py这个文件时整个工程的路由，将url与具体的服务或者要展示的页面相对应。 123456789101112131415161718192021222324252627282930313233from django.conf.urls import urlfrom django.contrib import adminfrom learn import views as learn_views # newfrom django.contrib.staticfiles.urls import staticfiles_urlpatternsurlpatterns = [url(r&apos;next&apos;, learn_views.nextPage), # newurl(r&apos;^$&apos;, learn_views.home,name=&apos;home&apos;), # newurl(r&apos;^admin/&apos;, admin.site.urls),url(r&apos;callPython&apos;, learn_views.compute), # newurl(r&apos;ajaxpack&apos;, learn_views.ajaxpack),url(r&apos;ajaxgetbranches&apos;, learn_views.ajaxgetbranchesfunc),url(r&apos;add&apos;, learn_views.compute), # newurl(r&apos;uicreate&apos;, learn_views.uicreate),url(r&apos;ajaxcreateui&apos;, learn_views.createui),url(r&apos;package&apos;, learn_views.package),url(r&apos;buildlist&apos;, learn_views.buildlist),url(r&apos;ajaxsendMail&apos;, learn_views.sendMails),url(r&apos;jsonFormatClick1&apos;, learn_views.jsonFormat1),url(r&apos;jsonFormatClick2&apos;, learn_views.jsonFormat2),url(r&apos;interfaceTestClick&apos;, learn_views.interfaceTest),url(r&apos;url1&apos;, learn_views.getUrl1),url(r&apos;url2&apos;, learn_views.getUrl2), # newurl(r&apos;url3&apos;, learn_views.getUrl3),url(r&apos;url4&apos;, learn_views.getUrl4),url(r&apos;url5&apos;, learn_views.getUrl5), # newurl(r&apos;url6&apos;, learn_views.getUrl6),url(r&apos;url7&apos;, learn_views.getUrl7)]# ... the rest of your URLconf goes here ...urlpatterns += staticfiles_urlpatterns() 看上边这段代码，新加入的有from learn import views as learn_views # new这个是引入了learn这个app中的views这个文件，然后在这个文件中我们就可以使用这个文件了，我们可以在列表中添加很多的url与服务的对应，url的写法的讲究在于，next意味着包含next就跳这个，^next意味着以next开头，next$意味着以next结尾，^next$意味着直邮next才跳这个，完全对应的意思，这个文件的作用主要就这些 views.py具体的服务我们是由这个文件来提供的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103from django.http import HttpResponsefrom django.shortcuts import renderfrom DIY.compute import getModelFromJsonfrom DIY.createui import getCreatedStringWithPropertiesfrom DIY.packServer import packaged,getbranchesfrom django.http import HttpResponseRedirectfrom DIY.mail import sendMaildef home(request):string = &apos;这是&apos;return render(request,&apos;home.html&apos;,&#123;&apos;string&apos;:string&#125;)def nextPage(request):return render(request,&apos;next.html&apos;)def compute(request):string = request.POST[&apos;text&apos;]string = getModelFromJson(string)return HttpResponse(string)def uicreate(request):return render(request,&apos;UICreate.html&apos;)def createui(request):string = request.GET[&apos;text&apos;]string = getCreatedStringWithProperties(string)return HttpResponse(string)def package(request):return render(request,&apos;package.html&apos;)def ajaxpack(request):f = open(&apos;/Users/wxg/Documents/Build/building.txt&apos;,&apos;r&apos;)text = f.read()if text == &apos;&apos;:string = request.GET[&apos;text&apos;]resurtString = packaged(string)return HttpResponse(&apos;done&apos;)else:return HttpResponse(&apos;wait&apos;) def ajaxgetbranchesfunc(request):return HttpResponse(getbranches(&apos;string&apos;))def buildlist(requets):return HttpResponseRedirect(&apos;http://10.13.80.19:8000/Documents/Build&apos;)def sendMails(request):sendMail(&apos;&apos;)return HttpResponse(&apos;hi&apos;) def jsonFormat1(request):return HttpResponseRedirect(&apos;http://www.jsonparseronline.com&apos;)def jsonFormat2(request):return HttpResponseRedirect(&apos;http://www.sojson.com&apos;) def interfaceTest(request):return HttpResponseRedirect(&apos;http://www.atool.org/httptest.php&apos;)def getUrl1(request):f = open(&apos;/Users/han/Desktop/text1.txt&apos;, &apos;r&apos;)text = f.read()f.close()return HttpResponse(text)def getUrl2(request):f = open(&apos;/Users/han/Desktop/text2.txt&apos;, &apos;r&apos;)text = f.read()f.close()return HttpResponse(text)def getUrl3(request):f = open(&apos;/Users/han/Desktop/text3.txt&apos;, &apos;r&apos;)text = f.read()f.close()return HttpResponse(text)def getUrl4(request):f = open(&apos;/Users/han/Desktop/text4.txt&apos;, &apos;r&apos;)text = f.read()f.close()return HttpResponse(text)def getUrl5(request):f = open(&apos;/Users/han/Desktop/text5.txt&apos;, &apos;r&apos;)text = f.read()f.close()return HttpResponse(text)def getUrl6(request):f = open(&apos;/Users/han/Desktop/text6.txt&apos;, &apos;r&apos;)text = f.read()f.close()return HttpResponse(text)def getUrl7(request):f = open(&apos;/Users/han/Desktop/text7.txt&apos;, &apos;r&apos;)text = f.read()f.close()return HttpResponse(text) 我们拿具体的例子来说，上边的这些代码，就是我们能够提供的具体的服务，具体说来我们主要提供三种服务 返回json1234def compute(request):string = request.POST[&apos;text&apos;]string = getModelFromJson(string)return HttpResponse(string) 比如这个，需要引入from django.http import HttpResponse 返回一个html文件123def home(request):string = &apos;这是&apos;return render(request,&apos;home.html&apos;,&#123;&apos;string&apos;:string&#125;) 中间的参数home.html就是一个html的文件，那么问题来了，这个文件是从哪里来的，与views.py同级有个templates文件夹，里边是我们要存放的html文件，这个需要html和css的一些知识来编写 返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的12def jsonFormat1(request):return HttpResponseRedirect(&apos;http://www.jsonparseronline.com&apos;) 12def buildlist(requets):return HttpResponseRedirect(&apos;http://10.13.80.19:8000/Documents/Build&apos;) 还有个问题需要说明就是，我们这里需要很多python的服务，如何引入呢，直接引入函数的名称就可以了，就像是from DIY.packServer import packaged,getbranches Django安装和配置具体可以参考Django部署+apache+mod_wsgi 自动打包服务的构建过程这里说两点，第一个是我们实现的一些比较不常见的功能，一个是踩到的坑。先来说一下功能点： 线上和预发的切换 清除本分支做的操作 .app转换为.ipa xcode XCBuildConfiguration配置文件自动设置 .app转换为.ipa当我们执行了xcodebuild build的命令之后，形成的是一个.app文件，这个时候我们需要做的压缩这个文件，这个是ipa文件生成的原理具体步骤： Step1: 新建“Payload”文件夹，注意名字要一字不差； Step2: 将你的.app包放到Payload中，注意app的名字不做任何更改，就用xcode生成的app名称； Step3: 在Payload文件夹上右键压缩成zip，然后将生成的.zip文件后缀改成.ipa即可具体代码: 123456789101112131415161718import os,shutilos.mkdir(&apos;Payload&apos;)shutil.copytree(&apos;JDMobile.app&apos;,&apos;Payload/JDMobile.app&apos;)os.system(&apos;zip -r Payload.zip Payload&apos;)files=os.listdir(&quot;.&quot;)for filename in files: li=os.path.splitext(filename) if li[1]==&quot;.zip&quot;: newname=li[0]+&quot;.ipa&quot; os.rename(filename,newname)shutil.rmtree(&apos;JDMobile.app&apos;)shutil.rmtree(&apos;Payload&apos;) xcode XCBuildConfiguration配置文件自动设置这里使用mod-pbxproj，这个是一个python解析库，用法如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445from mod_pbxproj import XcodeProjectimport commandsdef configProject(): project = XcodeProject.Load(&apos;/Users/wxg/Documents/JDMobileNew/JDMobile_2.0/JDMobile.xcodeproj/project.pbxproj&apos;) for item in project.objects.values(): nameIsa = item.get(&apos;isa&apos;) if (nameIsa == &apos;XCBuildConfiguration&apos;): setting = item.get(&apos;buildSettings&apos;) nameReference = item.get(&apos;baseConfigurationReference&apos;) if (nameReference): idStr = setting.get(&apos;PRODUCT_BUNDLE_IDENTIFIER&apos;) print &apos;----&gt;&apos; + idStr setting.__setitem__(&apos;PRODUCT_BUNDLE_IDENTIFIER&apos;,&apos;com.jd.jinrong2016&apos;) setting.__setitem__(&apos;PROVISIONING_PROFILE&apos;,&apos;&apos;) setting.__setitem__(&apos;PROVISIONING_PROFILE_SPECIFIER&apos;,&apos;&apos;) setting.__setitem__(&apos;DEVELOPMENT_TEAM&apos;,&apos;5TKVHWTT79&apos;) setting.__setitem__(&apos;CODE_SIGN_IDENTITY[sdk=iphoneos*]&apos;,&apos;iPhone Developer&apos;) item.__setitem__(&apos;buildSettings&apos;,setting) else: codeSign = setting.get(&apos;CODE_SIGN_IDENTITY&apos;) profile = setting.get(&apos;PROVISIONING_PROFILE&apos;) print codeSign print profile setting.__setitem__(&apos;CODE_SIGN_IDENTITY&apos;,&apos;iPhone Distribution: Beijing Jingdong Century Trading Co., Ltd. (TQZTTUQ9ZE)&apos;) setting.__setitem__(&apos;PROVISIONING_PROFILE&apos;,&apos;0d8cd55a-c922-4f27-b1aa-df6a2f277ea5&apos;) item.__setitem__(&apos;buildSettings&apos;,setting) elif (nameIsa == &apos;PBXProject&apos;): attributes = item.get(&apos;attributes&apos;) targetAttributes = attributes.get(&apos;TargetAttributes&apos;) targets = item.get(&apos;targets&apos;) tar = targets[0] attr = targetAttributes.get(&apos;%s&apos; % tar) developmentTeamName = attr.get(&apos;DevelopmentTeamName&apos;) developmentTeamName = attr.get(&apos;ProvisioningStyle&apos;) print developmentTeamName attr.__setitem__(&apos;DevelopmentTeamName&apos;,&apos;Beijing Jingdong Century Information Technology Co., Ltd.&apos;) attr.__setitem__(&apos;ProvisioningStyle&apos;, &apos;Automatic&apos;) attr.__setitem__(&apos;DevelopmentTeam&apos;, &apos;5TKVHWTT79&apos;) project.save() 这里的坑主要是由权限引起的，因为我们从web服务去调用一个命令行的指令的时候，这个时候的并不是登录状态的权限，而是一个非登录状态的权限，这个时候有两个问题，一个是很多服务是没有被加载的，第二个是一些文件没有权限去调用，下面分别来说 gradle无法调用 苹果的开发者证书不能读取 git pull命令需要用户名和密码 gradle无法调用这里涉及到一个问题是mac的环境变量，通过在终端输入$PATH来查看当前用户下加载的路径有哪些，如果返回的路径中包含我们的服务的路径，那么肯定这个服务当前用户是可以调用的，我们在web服务中调用这个命令发现返回的只有usr/bin等着几个路径，那么思路就来了，如果gradle想要被使用，那么就需要加到这路径下，解决的办法就是加一个软连接到/usr/bin文件下，sudo ln -s xxxxx xxxxx就可以了，那么如果找到这个服务的安装路径呢？以gradle为例which gradle，如果是git的话就是which git这里还有个问题是mac升级系统后，这个文件是不允许更改的，解决办法: 对于Mac OS X 10.11 El Capitan用户，由于系统启用了SIP(System Integrity Protection), 导致root用户也没有权限修改/usr/bin目录。按如下方式可恢复权限。屏蔽方法：重启Mac，按住command+R,进入recovery模式。选择打开Utilities下的终端，输入：csrutil disable并回车，然后正常重启Mac即可 苹果的开发者证书不能读取User interaction is not allowed这个问题是因为证书不能被读取，这是因为证书在登录下，我们将证书移动到系统下就可以了 git pull命令需要用户名和密码这个不能被执行也是因为权限的问题，最后的解决方案，是在登录状态下(命令行)直接开一个新的线程，死循环不断的检测一个文件下是否有对应的文件夹，如果有这个文件夹就执行git pull命令，执行完毕之后写入日志，然后删除文件内容，继续进入到下一个循环，这个与iOS的runloop是一个道理 django中使用ajax的post方法123456$(&quot;#insert&quot;).click(function()&#123; text = $(&apos;#textarea1&apos;).val() $.post(&quot;/writecontent/&quot;, &#123;&apos;content&apos;: text,&apos;foldername&apos;:foldername,&apos;filename&apos;:filename&#125;,function(ret)&#123; alert(ret) &#125;) &#125;); 之所以使用post这里是因为无法突破apache对于get方法的整体参数长度限制，而使用post方法有个问题就是会强制CSRF校验，解决方法就是关闭django的验证，具体来说是到setting文件中注释一行代码 django.middleware.csrf.CsrfViewMiddleware 安装pymongo首先要安装pip，然后用pip安装pymongo1sudo easy_install pip 然后使用pip安装pymongo1sudo pip install pymongo 这个时候进入python环境使用命令行去访问pymongo应该是没有问题的，但是你使用web调用的方式去调用不一定能够访问到mongo，这可能是因为你使用的python安装路径的问题1which python 看一下当前加载的python，不出意外应该是/usr/local/bin/python，这个是登录状态下才能加载的一个环境和路径，而web是非登录的，所以很多功能访问不到正常，我们要做的就是让系统直接加载/usr/bin/python，这就涉及到一个加载优先级的问题1sudo emacs /etc/paths /usr/local/bin/usr/bin/bin/usr/sbin/sbin tips:現在要把 /usr/local/bin 移到上面去 control + k：把一行字剪下來 control + y：把字貼上 control + x + s：存檔 control + x + c：關掉 emacs 然后再执行下边这句1echo $PATH 这个时候你再打开发现已经变成了下边这样 /usr/bin/usr/local/bin/bin/usr/sbin/sbin 这个时候你再执行1which python 发现已经变成了/usr/bin/python现在看来，系统加载某个功能的逻辑，就是直接在这些个加载列表中找这些个功能，如果逐个加载了一遍发现没有这个功能，那么就会报错，如果第一路径下有这个功能，第二路径下也有这个功能，那么就会用第一路径下的，所以我们更改第一路径是有意义的]]></content>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSString && NSData]]></title>
    <url>%2F2016%2F11%2F15%2F2014%2FFoundation%E7%B3%BB%E5%88%97-NSString%2F</url>
    <content type="text"><![CDATA[内存简述，Copy与Strong关键字内存简述为了方便观察引用计数，这里在MRC下来进行测试。先重新定义NSLog让其不打印时间戳。再编写一个打印宏，用来打印NSString对象的类、内存地址、值、引用计数。12#define NSLog(FORMAT, ...) fprintf(stderr,&quot;%s\n&quot;,[[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);#define YLog(_var) (&#123; NSString *name = @#_var; NSLog(@&quot;%@: %@ -&gt; %p : %@ %tu&quot;, name, [_var class], _var, _var, [_var retainCount]); &#125;) 再新建一个StrObject类，用于测试。该类创建实例时，将打印一个NSString，内容为”Str”。12345678910111213141516171819202122232425@interface StrObject : NSObject@end@implementation StrObject- (id)init &#123; self = [super init]; if (self) &#123; NSLog(@&quot;StrObj Create&quot;); NSString *strA = @&quot;Str&quot;; YLog(strA);&#125;return self;&#125;- (void)dealloc &#123; [super dealloc]; NSLog(@&quot;StrObj Dealloc&quot;);&#125; 之后运行以下代码。（一般来说我们可以用以下几种方法来创建NSString对象，其中stringWithString在iOS 6之后已变为多余的方法（redundant），因其等同于字面量创建法，使用这方法编译器会给出警告，） 123456789101112131415161718192021222324252627282930313233343536373839404142434445//创建并释放StrObject对象StrObject *obj = [StrObject new];[obj release];//创建一些字符串NSString *str1 = @&quot;Str&quot;; YLog(str1);NSString *str2 = @&quot;Str&quot;; YLog(str2);NSString *str3 = [NSString stringWithString:@&quot;Str&quot;]; YLog(str3);NSString *str4 = [NSString stringWithFormat:@&quot;Str&quot;]; YLog(str4);NSString *str5 = [str1 retain]; YLog(str5);NSString *str6 = [str1 copy]; YLog(str6);NSString *str7 = [str1 mutableCopy]; YLog(str7);//改变NSString变量的字符串内容str1 = @&quot;StrNew&quot;; YLog(str1);str2 = str1; YLog(str2);//创建一个字符串并将其释放NSString *str8 = @&quot;Str&quot;;[str8 retain];[str8 release];[str8 release];YLog(str8);//=======输出结果========//创建并释放StrObject对象//StrObj Create//strA: __NSCFConstantString -&gt; 0x10d2ce088 : Str 18446744073709551615//StrObj Dealloc//创建一些字符串//str1: __NSCFConstantString -&gt; 0x10d2ce088 : Str 18446744073709551615//str2: __NSCFConstantString -&gt; 0x10d2ce088 : Str 18446744073709551615//str3: __NSCFConstantString -&gt; 0x10d2ce088 : Str 18446744073709551615//str4: NSTaggedPointerString -&gt; 0xa000000007274533 : Str 18446744073709551615//str5: __NSCFConstantString -&gt; 0x10d2ce088 : Str 18446744073709551615//str6: __NSCFConstantString -&gt; 0x10d2ce088 : Str 18446744073709551615//str7: __NSCFString -&gt; 0x7f951a409c80 : Str 1//改变NSString变量的字符串内容//str1: __NSCFConstantString -&gt; 0x10d2ce1e8 : StrNew 18446744073709551615//str2: __NSCFConstantString -&gt; 0x10d2ce1e8 : StrNew 18446744073709551615//创建一个字符串并将其释放//str8: __NSCFConstantString -&gt; 0x10d2ce088 : Str 18446744073709551615 可观察到，虽然我们通过不同方法创建了不同的NSString对象，但字符串内容一致，结果显示strA、str1、str2、str3、str5、str6都指向同一个地址。即便@”Str”首先在StrObject对象中出现，赋值给strA，释放了之后，str1和其他对象仍然指向同一个地址。 将一个新的字符串内容@”Str a”赋值给str1，并且将str1赋值给str2后，从结果看到str1、str2的内存地址改变了，且指向同一个地址。 之后创建的str8，对其进行多次release后，内存地址（和strA地址相同）和retaionCount都不曾变化。 __NSCFConstantString这些对象地址相同，是因为他们都是NSCFConstantString对象，也就是字符串常量对象，可以看到其isa都是NSCFConstantString，该对象存储在栈上，创建之后由系统来管理内存释放，相同内容的NSCFConstantString对象地址相同。该对象引用计数很大，为固定值不会变化，表示无限运行的retainCount，对其进行retain或release也不会影响其引用计数。 当创建一个NSCFConstantString对象时，会检测这个字符串内容是否已经存在，如果存在，则直接将地址赋值给变量；不存在的话，则创建新地址，再赋值。 总的来说，对于NSCFConstantString对象，只要字符串内容不变，就不会分配新的内存地址，无论你是赋值、retain、copy。这种优化在大量使用NSString的情况下可以节省内存，提高性能。 __NSCFString在上面的输出结果中，我们看到另外还有两类isa分别是：NSCFString和NSTaggedPointerString，先来看NSCFString。 在我的理解，__NSCFString对象是一种NSString子类，存储在堆上，不属于字符串常量对象。该对象创建之后和其他的Obj对象一样引用计数为1，对其执行retain和release将改变其retainCount。123456789101112131415161718192021222324252627NSString *str1 = [NSString stringWithFormat:@&quot;ThisIsAStr&quot;];YLog(str1);NSString *str2 = [str1 retain];YLog(str1);YLog(str2);NSString *str3 = [str1 copy];YLog(str1);YLog(str2);YLog(str3);//输出结果//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr 1//str1 retain后赋值给str2//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr 2//str2: __NSCFString -&gt; 0x100206c70 : ThisIsAStr 2//str3由str1浅复制得来//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr 3//str2: __NSCFString -&gt; 0x100206c70 : ThisIsAStr 3//str3: __NSCFString -&gt; 0x100206c70 : ThisIsAStr 3//对str1进行release//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr 2//str2: __NSCFString -&gt; 0x100206c70 : ThisIsAStr 2//str3: __NSCFString -&gt; 0x100206c70 : ThisIsAStr 2 NSTaggedPointerString这个对象是标签指针，苹果在 64 位环境下对NSString、NSNumber等对象做了一些优化。简单的说就是把指针指向的内容直接放在了指针变量的内存地址中，在 64 位环境下指针变量的大小达到了 8 位，能容纳长度较小的内容，于是使用了标签指针来优化数据的存储。从其引用计数可以看出，这种对象也是无垠的retainCount，这种对象存储在指针的内容中。 对 NSString对象来说，当非字面量的数字，英文字母字符串的长度小于等于9的时候会自动成为NSTaggedPointerString类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为__NSCFString类型。 12345678910NSString *str1 = @&quot;123456789&quot;; YLog(str1);NSString *str2 = [NSString stringWithFormat:@&quot;123456789&quot;]; YLog(str2);NSString *str3 = [NSString stringWithFormat:@&quot;1234567890&quot;]; YLog(str3);NSString *str4 = [NSString stringWithFormat:@&quot;五&quot;]; YLog(str4);//输出结果//str1: __NSCFConstantString -&gt; 0x10a0c5108 : 123456789 18446744073709551615//str2: NSTaggedPointerString -&gt; 0xa1ea1f72bb30ab19 : 123456789 18446744073709551615//str3: __NSCFString -&gt; 0x7f8183c02630 : 1234567890 1//str4: __NSCFString -&gt; 0x7f8183c0fae0 : 五 1 声明NSSting为属性时用copy还是strong声明NSString属性一般来说用copy，因为父类指针可以指向子类对象，而NSMutableNSString是NSString的子类，使用strong的话该NSString属性可能指向一个NSMutableNSString可变对象，如果这个可变对象的内容在外部被修改了，那该属性所属的对象可能对此毫不知情。 先来看正常的情况，NSString属性指向一个不可变对象。123456789101112131415161718192021222324//Person对象@interface Person : NSObject@property (nonatomic, strong) NSString *name;@end@implementation Person@end//测试代码NSString *strA = @&quot;Susan_Miller&quot;;Person *personA = [Person new];personA.name = strA;YLog(strA);YLog(personA.name);strA = @&quot;Susan_Test&quot;;YLog(strA);YLog(personA.name);//输出结果//strA: __NSCFConstantString -&gt; 0x102f20108 : Susan_Miller 18446744073709551615//personA.name: __NSCFConstantString -&gt; 0x102f20108 : Susan_Miller 18446744073709551615//strA: __NSCFConstantString -&gt; 0x102f20148 : Susan_Test 18446744073709551615//personA.name: __NSCFConstantString -&gt; 0x102f20108 : Susan_Miller 18446744073709551615 从结果可观察到此时的name属性指向一个不可变的字符串常量，就算strA因为内容变化而生成了新地址，对name属性不会有影响，无论声明name属性时关键字用copy还是strong（不可变对象的copy是浅复制，strong也是指针引用，所以strA内容改变后地址同时改变，不会影响name属性）。 再来看name属性指向一个可变对象的情况，属性关键字用strong。12345678910111213141516171819//属性关键字为strong@property (nonatomic, strong) NSString *name;//测试代码NSMutableString *strB = [@&quot;Susan_Miller&quot; mutableCopy];Person *personB = [Person new];personB.name = strB;YLog(strB);YLog(personB.name);[strB setString:@&quot;Susan_Test&quot;];YLog(strB);YLog(personB.name);//输出结果//strB: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Miller 2//personB.name: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Miller 2//strB: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Test 2//personB.name: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Test 2 从结果可看出，name属性指向了一个可变对象strB，当strB的内容改变时，name属性也跟着改变，而person对此不知情，可能会产生错误。 继续来看name属性关键字使用copy时的情况。12345678910111213141516171819//属性关键字为copy@property (nonatomic, copy) NSString *name;//测试代码NSMutableString *strB = [@&quot;Susan_Miller&quot; mutableCopy];Person *personB = [Person new];personB.name = strB;YLog(strB);YLog(personB.name);[strB setString:@&quot;Susan_Test&quot;];YLog(strB);YLog(personB.name);//输出结果//strB: __NSCFString -&gt; 0x7fb15af31360 : Susan_Miller 1**//personB.name: __NSCFString -&gt; 0x7fb15af26620 : Susan_Miller 1**//strB: __NSCFString -&gt; 0x7fb15af31360 : Susan_Test 1**//personB.name: __NSCFString -&gt; 0x7fb15af26620 : Susan_Miller 1** 此时，因为对NSMutableString进行copy是深复制（即内容拷贝），所以name属性与strB指向不同的地址，strB的内容更改不会影响到name属性。 所以，声明NSString为属性时，如果希望保护属性封装性不受外界影响，则应该使用copy关键字，让所属对象持有的是一份“不可变”（immutable）副本，不用担心字符串内容无意间变动。 去除字符串中的中文1234567891011121314151617181920212223- (NSString *)removeChinese:(NSString *)string &#123; NSString *chi = [self getChineseStringWithString:string]; return [string stringByReplacingOccurrencesOfString:chi withString:@&quot;&quot;];&#125;- (NSString *)getChineseStringWithString:(NSString *)string&#123; //(unicode中文编码范围是0x4e00~0x9fa5) for (int i = 0; i &lt; string.length; i++) &#123; int utfCode = 0; void *buffer = &amp;utfCode; NSRange range = NSMakeRange(i, 1); BOOL b = [string getBytes:buffer maxLength:2 usedLength:NULL encoding:NSUTF16LittleEndianStringEncoding options:NSStringEncodingConversionExternalRepresentation range:range remainingRange:NULL]; if (b &amp;&amp; (utfCode &gt;= 0x4e00 &amp;&amp; utfCode &lt;= 0x9fa5)) &#123; return [string substringFromIndex:i]; &#125; &#125; return nil;&#125; - (BOOL)containsString:(NSString *)str NS_AVAILABLE(10_10, 8_0);//7以下不可用NSString的各种转换NSData 与 NSString12345 NSData --&gt; NSString NSString *aString = [[NSString alloc] initWithData:adata encoding:NSUTF8StringEncoding]; NSString --&gt; NSData NSString *aString = @&quot;1234&quot;; NSData *aData = [aString dataUsingEncoding: NSUTF8StringEncoding]; NSString转化为UNICODE String：1234(NSString*)fname ＝ @“Test”;char fnameStr[10];memcpy(fnameStr, [fname cStringUsingEncoding:NSUnicodeStringEncoding], 2*([fname length]));与strcpy相比，memcpy并不是遇到&apos;\0&apos;就结束，而是一定会拷贝完n个字节 NSString 转化为 char *12NSString * str＝ @“Test”;const char * a =[str UTF8String]; char * 转化为 NSString1NSString *str=[NSString stringWithCString encoding:NSUTF8StringEncoding]; char * 转化 NSData12方法一： char * a = (char*)malloc(sizeof(byte)*16); NSData *data = [NSData dataWithBytes: a length:strlen(a)]; 方法二： 转换为NSString： - (id)initWithUTF8String:(const char *)bytes 然后用NSString的 - (NSData *)dataUsingEncoding:(NSStringEncoding)encoding NSData 转化 char *12NSData data ； char* a=[data bytes]; NSString 转化 NSURL123//NSURL *url = [NSURL URLWithString:[str stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding ]];NSString *urlString=[@&quot;http://www.google.com/search?client=safari&amp;rls=en&amp;q=搜索&amp;ie=UTF-8&amp;oe=UTF-8&quot; stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; NSURL 转化 NSString123NSURL *url=[NSURL URLWithString:urlString];NSString *s=[[url absoluteString] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; NSData 与 Byte1234567 NSData --&gt; Byte NSString *testString = @&quot;1234567890&quot;; NSData *testData = [testString dataUsingEncoding: NSUTF8StringEncoding]; Byte *testByte = (Byte *)[testData bytes]; Byte --&gt; NSData Byte byte[] = &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23&#125;; NSData *adata = [[NSData alloc] initWithBytes:byte length:24]; NSData 与 UIImage12345678910 NSData --&gt; UIImage UIImage *aimage = [UIImage imageWithData: imageData]; //例：从本地文件沙盒中取图片并转换为NSData NSString *path = [[NSBundle mainBundle] bundlePath]; NSString *name = [NSString stringWithFormat:@&quot;ceshi.png&quot;]; NSString *finalPath = [path stringByAppendingPathComponent:name]; NSData *imageData = [NSData dataWithContentsOfFile: finalPath]; UIImage *aimage = [UIImage imageWithData: imageData]; UIImage－&gt; NSData NSData *imageData = UIImagePNGRepresentation(aimae); NSData 与 NSMutableData1234 NSData --&gt; MSMutableData NSData *data=[[NSData alloc]init]; NSMutableData *mdata=[[NSMutableData alloc]init]; mdata=[NSData dataWithData:data]; NSData合并为一个NSMutableData12345678910111213141516171819202122232425262728- (NSString *)filePathWithName:(NSString *)filename&#123;NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0];return [documentsDirectory stringByAppendingPathComponent:filename];&#125;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;//音频文件路径NSString *mp3Path1 = [[NSBundle mainBundle] pathForResource:@&quot;1&quot; ofType:@&quot;mp3&quot;];NSString *mp3Path2 = [[NSBundle mainBundle] pathForResource:@&quot;2&quot; ofType:@&quot;mp3&quot;];//音频数据NSData *sound1Data = [[NSData alloc] initWithContentsOfFile: mp3Path1];NSData *sound2Data = [[NSData alloc] initWithContentsOfFile: mp3Path2];//合并音频NSMutableData *sounds = [NSMutableData alloc];[sounds appendData:sound1Data];[sounds appendData:sound2Data];//保存音频NSLog(@&quot;data length:%d&quot;, [sounds length]);[sounds writeToFile:[self filePathWithName:@&quot;tmp.mp3&quot;] atomically:YES];[window makeKeyAndVisible];return YES;&#125; 转译字符 转义字符 意义 ASCII码值(十进制)\a 响铃(BEL) 007\b 退格(BS) 008\f 换页(FF) 012\n 换行(LF) 010\r 回车(CR) 013\t 水平制表(HT) 009\v 垂直制表(VT) 011\ 反斜杠 092\? 问号字符 063\’ 单引号字符 039\” 双引号字符 034\0 空字符(NULL) 000\ddd 任意字符 三位八进制\xhh 任意字符 二位十六进制\a:蜂鸣，响铃\b:回退：向后退一格\f:换页\n:换行，光标到下行行首\r:回车，光标到本行行首\t:水平制表\v:垂直制表\:反斜杠\’:单引号\”:双引号\?:问号\ddd:三位八进制\xhh:二位十六进制\0:空字符(NULL),什么都不做注：1，\v垂直制表和\f换页符对屏幕没有任何影响，但会影响打印机执行响应操作。2，\n其实应该叫回车换行。换行只是换一行，不改变光标的横坐标；回车只是回到行首，不改变光标的纵坐标。3，\t 光标向前移动四格或八格，可以在编译器里设置4，\’ 在字符里（即单引号里）使用。在字符串里(即双引号里)不需要，只要用 ‘ 即可。5，\? 其实不必要。只要用 ? 就可以了（在windows VC6 和tc2 中验证）。 常用的富文本单纯改变一句话中的某些字的颜色（一种颜色）1234567891011121314151617181920/*** 单纯改变一句话中的某些字的颜色（一种颜色）** @param color 需要改变成的颜色* @param totalStr 总的字符串* @param subArray 需要改变颜色的文字数组(要是有相同的 只取第一个)** @return 生成的富文本*/+ (NSMutableAttributedString *)ls_changeCorlorWithColor:(UIColor *)color TotalString:(NSString *)totalStr SubStringArray:(NSArray *)subArray &#123;NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalStr];for (NSString *rangeStr in subArray) &#123;NSRange range = [totalStr rangeOfString:rangeStr options:NSBackwardsSearch];[attributedStr addAttribute:NSForegroundColorAttributeName value:color range:range];&#125;return attributedStr;&#125; 改变每行的字间距123456789101112131415161718/*** 单纯改变句子的字间距（需要 &lt;CoreText/CoreText.h&gt;）** @param totalString 需要更改的字符串* @param space 字间距** @return 生成的富文本*/+ (NSMutableAttributedString *)ls_changeSpaceWithTotalString:(NSString *)totalString Space:(CGFloat)space &#123;NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];long number = space;CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);[attributedStr addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[attributedStr length])];CFRelease(num);return attributedStr;&#125; 改变行间距12345678910111213141516171819/*** 单纯改变段落的行间距** @param totalString 需要更改的字符串* @param lineSpace 行间距** @return 生成的富文本*/+ (NSMutableAttributedString *)ls_changeLineSpaceWithTotalString:(NSString *)totalString LineSpace:(CGFloat)lineSpace &#123;NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];NSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];[paragraphStyle setLineSpacing:lineSpace];[attributedStr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [totalString length])];return attributedStr;&#125; 同时更改行间距和字间距12345678910111213141516171819202122232425/*** 同时更改行间距和字间距** @param totalString 需要改变的字符串* @param lineSpace 行间距* @param textSpace 字间距** @return 生成的富文本*/+ (NSMutableAttributedString *)ls_changeLineAndTextSpaceWithTotalString:(NSString *)totalString LineSpace:(CGFloat)lineSpace textSpace:(CGFloat)textSpace &#123;NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];NSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];[paragraphStyle setLineSpacing:lineSpace];[attributedStr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [totalString length])];long number = textSpace;CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);[attributedStr addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[attributedStr length])];CFRelease(num);return attributedStr;&#125; 更改某些文字的颜色并修改其字体，突出重点强调1234567891011121314151617181920212223/*** 改变某些文字的颜色 并单独设置其字体** @param font 设置的字体* @param color 颜色* @param totalString 总的字符串* @param subArray 想要变色的字符数组** @return 生成的富文本*/+ (NSMutableAttributedString *)ls_changeFontAndColor:(UIFont *)font Color:(UIColor *)color TotalString:(NSString *)totalString SubStringArray:(NSArray *)subArray &#123;NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];for (NSString *rangeStr in subArray) &#123;NSRange range = [totalString rangeOfString:rangeStr options:NSBackwardsSearch];[attributedStr addAttribute:NSForegroundColorAttributeName value:color range:range];[attributedStr addAttribute:NSFontAttributeName value:font range:range];&#125;return attributedStr; 富文本相关属性汇总 NSFontAttributeName ：字体字号 value值：UIFont类型 NSParagraphStyleAttributeName ： 段落样式 value值：NSParagraphStyle类型（其属性如下） lineSpacing 行间距(具体用法可查看上面的设置行间距API) paragraphSpacing 段落间距 alignment 对齐方式 firstLineHeadIndent 指定段落开始的缩进像素 headIndent 调整全部文字的缩进像素 NSForegroundColorAttributeName 字体颜色 value值：UIColor类型 NSBackgroundColorAttributeName 背景颜色 value值：UIColor类型 NSObliquenessAttributeName 字体粗倾斜 value值：NSNumber类型 NSExpansionAttributeName 字体加粗 value值：NSNumber类型(比例) 0就是不变 1增加一倍 NSKernAttributeName 字间距 value值：CGFloat类型 NSUnderlineStyleAttributeName 下划线 value值：1或0 NSUnderlineColorAttributeName 下划线颜色 value值：UIColor类型 NSStrikethroughStyleAttributeName 删除线 value值：1或0 NSStrikethroughColorAttributeName 删除线颜色 value值：UIColor类型 NSStrokeColorAttributeName 字体颜色 value值：UIColor类型 NSStrokeWidthAttributeName 字体描边 value值：CGFloat NSLigatureAttributeName 连笔字 value值：1或0 NSShadowAttributeName 阴影 value值：NSShawdow类型（下面是其属性） shadowOffset 影子与字符串的偏移量 shadowBlurRadius 影子的模糊程度 shadowColor 影子的颜色 NSTextEffectAttributeName 设置文本特殊效果,目前只有图版印刷效果可用 value值：NSString类型 NSAttachmentAttributeName 设置文本附件 value值：NSTextAttachment类型（没研究过，可自行百度研究） NSLinkAttributeName 链接 value值：NSURL (preferred) or NSString类型 NSBaselineOffsetAttributeName 基准线偏移 value值：NSNumber类型 NSWritingDirectionAttributeName 文字方向 分别代表不同的文字出现方向 value值：@[@(1),@(2)] NSVerticalGlyphFormAttributeName 水平或者竖直文本 在iOS没卵用，不支持竖版 value值：1竖直 0水平 获取汉字的拼音12345678910111213+ (NSString *)transform:(NSString *)chinese&#123;//将NSString装换成NSMutableStringNSMutableString *pinyin = [chinese mutableCopy];//将汉字转换为拼音(带音标)CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);NSLog(@&quot;%@&quot;, pinyin);//去掉拼音的音标CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);NSLog(@&quot;%@&quot;, pinyin);//返回最近结果return pinyin;&#125;]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django部署+apache+mod_wsgi]]></title>
    <url>%2F2016%2F11%2F09%2F2016%2FDjango%E9%83%A8%E7%BD%B2-apache-mod-wsgi%2F</url>
    <content type="text"><![CDATA[Django的部署(apache + mod_wsgi)概念解析DjangoDjango是一个框架，可以用python来开发web应用，但是并不是独立的开发web，在UI放面依然需要依靠html+css+js，用这些来搭建界面，不过我们可以使用django无缝的使用python的逻辑功能，比如使用python来处理数据，然后交给页面来进行展示 Django本身是有web服务器的，但是这个服务器只能在本机提供web服务，其作用主要是用来做测试，如果想其他机器也能访问你的web这个时候你还需要另外一个服务器，提供网络访问的功能 apacheApache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等） mod_wsgimod_wsgi的目的是实现一个简单的使用Apache模块可以举办任何Python应用程序支持Python的WSGI接口。该模块将适用于主机的高性能生产的网站，以及一般的自我管理个人网站的网页寄存服务运行。） 虚拟主机在apache上配置虚拟主机，这将在你mac上提供一个简单管理多个网站的框架 静态文件django1.3新加入了一个静态资源管理的app，django.contrib.staticfiles。在以往的django版本中，静态资源的管理一向都是个问题。部分app发布的时候会带上静态资源文件，在部署的时候你必须手动从各个app中将这些静态资源文件复制到同一个static目录。在引入staticfiles后，你只需要执行./manage.py collectstatic就可以很方便的将所用到app中的静态资源复制到同一目录。staticfiles的引入，方便了django静态文件的管理，不过感觉staticfiles的文档写的并不是太清楚，初次使用的时候还是让我有些困惑。下面简单的介绍一下staticfiles的主要配置： STATIC_ROOT：运行manage.py collectstatic后静态文件将复制到的目录。注意：不要把你项目的静态文件放到这个目录。这个目录只有在运行collectstatic时才会用到。我最开始想当然的以为这个目录和MEDIA_ROOT的作用是相同的，致使在开发环境下一直无法找到静态文件。 STATIC_URL：设置的static file的起始url，这个只可以在template里面引用到。这个参数和MEDIA_URL的含义差不多。 STATICFILES_DIRS：除了各个app的static目录以外还需要管理的静态文件位置，比如项目公共的静态文件差不多。和TEMPLATE_DIRS的含义差不多。各个APP下static/目录下的静态文件django的开发服务器会自动找到，这点和以前APP下的templates目录差不多。在urls.py中加入静态文件处理的代码 123from django.contrib.staticfiles.urls import staticfiles_urlpatterns# ... the rest of your URLconf goes here ...urlpatterns += staticfiles_urlpatterns() 各种目录 django项目目录 静态文件目录 错误日志目录 请求的处理过程sitename.conf –&gt; wsgi.py –&gt; settings.py –&gt; urls.py –&gt; views.py 配置的过程 python是系统自带不需要安装 apache系统自带不需要安装mod_wsgi安装 brew tap homebrew/apache brew install mod_wsgi django安装及工程创建 安装pipsudo easy_install pip 利用pip安装django（sudo) pip install Django 检验是否安装成功 123456&gt;&gt;&gt; import django&gt;&gt;&gt; django.VERSION(1, 7, 6, &apos;final&apos;, 0)&gt;&gt;&gt; &gt;&gt;&gt; django.get_version()&apos;1.7.6&apos; 创建工程 1django-admin.py startproject project-name 创建app到工程的目录下，找到namage.py这个文件 1python manage.py startapp app-name apache配置/etc/apache2/httpd.conf这个文内 LoadModule wsgi_module /usr/local/Cellar/mod_wsgi/4.5.6/libexec/mod_wsgi.so这个目录是安装mod_wsgi这个文件的时候，生成的，找到它 Include /private/etc/apache2/extra/httpd-vhosts.conf放开这句话，意思是我要使用虚拟主机 配置虚拟主机在httpd-vhosts.conf这个文件内导入文件12include /private/etc/apache2/extra/vhosts/localhost.confinclude /private/etc/apache2/extra/vhosts/dev.mysite.com.conf 意思是导入这两个文件，作为虚拟主机的配置，但是这两个文件需要自己创建 虚拟主机配置dev.mysite.com.conf这个是最关键的地方12345678910111213141516171819202122232425262728293031323334353637383940414243444546Listen 89#虚拟主机的监听端口&lt;VirtualHost *:89&gt;LogLevel infoServerName dev.mysite.com#虚拟主机的名字ServerAdmin my@mysite.comErrorLog &quot;/Users/han/Sites/logs/mysite.com-error_log&quot;CustomLog &quot;/Users/han/Sites/logs/mysite.com-access_log&quot; common#这两个一定要配置，因为一旦有错误，我们需要依靠这两个文件的内的日志来找到错误WSGIScriptAlias / /Users/han/Documents/mysite/mysite/wsgi.py#这个是整个设置最重要的地方，让apache可以知道使用哪个wsgi&lt;Directory &quot;/Users/han/Documents/mysite/mysite&quot;&gt;&lt;Files wsgi.py&gt;Require all granted&lt;/Files&gt;&lt;/Directory&gt;#设置wsgi的文件权限#################下边的都不是重点了################### Static filesDocumentRoot &quot;/Users/han/Sites/mysite.com&quot;&lt;Directory &quot;/Users/han/Sites/mysite.com&quot;&gt;Options FollowSymLinks MultiviewsRequire all granted&lt;/Directory&gt;Alias /static/ /Users/han/Sites/mysite.com/static/&lt;Directory &quot;/Users/han/Sites/mysite.com/static&quot;&gt;Require all granted&lt;/Directory&gt;# WGSI configuration#WSGIDaemonProcess dev.mysite.com processes=2 threads=15 display-name=%&#123;GROUP&#125; python-#path=/Users/han/Documents/mysite/:/Users/han/Documents/VirtualEnvs/python2.7-django/lib/python2.7/site-#packages#WSGIProcessGroup dev.mysite.com&lt;Directory &quot;/Users/han/Documents/mysite&quot;&gt;Options FollowSymLinks MultiviewsRequire all granted&lt;/Directory&gt;&lt;/VirtualHost&gt; django工程配置设置wsgi文件，让mod_wsgi知道，使用哪个django项目12345678910111213import osfrom os.path import join,dirname,abspathPROJECT_DIR = dirname(dirname(abspath(__file__)))#3import sys # 4sys.path.insert(0,PROJECT_DIR) # 5from django.core.wsgi import get_wsgi_applicationos.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;mysite.settings&quot;)application = get_wsgi_application() 最重要的是3，4，5三句，让mod_wsgi知道去哪里找django项目，剩下的就是django的事情了 错误说明 其实所有的static文件都是非重点，因为我们最终调用的是django的服务，所以没有静态文件，只是不展示而已，不过如果我们需要一些小的icon等等，我们还是需要这个静态文件的，这是后话，先实现服务这是大事 如果我们遇到了权限问题， Permission denied: access to / denied (filesystem path ‘/Users/han/Documents/mysite use search permissions are missing on a component of the path 像下边这样的，说明我们没有合适的权限，这是所有文档都没有说明白的地方，这里之所以回访问这个是因为在mod_wsgi中进行了设置，mod_wsgi去这个文件中寻找django的服务，但是我们并没有在所有的设置中设置mod_wsgi的访问权限，这是其一，其二我们并不能直接设置mysite的权限，这样到最后我们发现还是一直报这个错误，我们需要设置上层目录的权限，不知道为啥会这么坑爹到～目录下，然后chmod o+rx Documents最后我们输入dev.mysite.com:89的时候显示的就是django的首页了 常用命令行 sudo apachectl restart重启命令 apachectl confittest修改配之后测试一下看看哪里有错误，只出现一个OK才是没有问题]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FLV格式解析]]></title>
    <url>%2F2016%2F07%2F30%2F2016%2FFLV%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[FLV 是 FLASH VIDEO 的简称,，FLV流媒体格式是一种新的视频格式，全称为Flash Video。FLV 压缩与转换非常方便，适合做短片.，并且 FLV 可以很好的保护原始地址，不容易下载到，可以起到保护版权的目的 最近要用到flv，整理了一些flv格式的资料，供参考。 flv文件主要由两部分组成：header和body。 1.headerheader部分记录了flv的类型、版本等信息，是flv的开头，一般都差不多，占9bytes。具体格式如下： 文件类型 3bytes “FLV” 版本 1 byte 一般为0x01 流信息 1 byte 倒数第一位是1表示有视频，倒数第三位是1表示有音频，倒数第二、四位必须为0 header长度 4 bytes 整个header的长度，一般为9；大于9表示下面还有扩展信息 2.bodybody部分由一个个Tag组成，每个Tag的下面有一块4bytes的空间，用来记录这个tag的长度，这个后置用于逆向读取处理，他们的关系如下图： flv 2.1.Tag每个Tag由也是由两部分组成的：Tag Header和Tag Data。Tag Header里存放的是当前Tag的类型、数据区（Tag Data）长度等信息，具体如下： 名称 长度 介绍 Tag类型 1 bytes 8：音频 9：视频 18：脚本 其他：保留 数据区长度 3 bytes 在数据区的长度 时间戳 3 bytes 整数，单位是毫秒。对于脚本型的tag总是0 时间戳扩展 1 bytes 将时间戳扩展为4bytes，代表高8位。很少用到 StreamsID 3 bytes 总是0 数据区(data) 由数据区长度决定 数据实体 2.2.Tag Data数据区根据Tag类型的不同可分为三种，音频数据、视频数据和脚本数据。 2.2.1.音频数据第一个byte是音频的信息，格式如下。 名称 长度 介绍 音频格式 4 bits 0 = Linear PCM, platform endian,1 = ADPCM,2 = MP3,3 = Linear PCM, little endian,4 = Nellymoser 16-kHz mono,5 = Nellymoser 8-kHz mono,6 = Nellymoser,7 = G.711 A-law logarithmic PCM,8 = G.711 mu-law logarithmic PCM,9 = reserved,10 = AAC,11 = Speex,14 = MP3 8-Khz,15 = Device-specific sound 采样率 2 bits 0 = 5.5-kHz,1 = 11-kHz,2 = 22-kHz,3 = 44-kHz,对于AAC总是3 采样的长度 1 bit 0 = snd8Bit,1 = snd16Bit,压缩过的音频都是16bit 音频类型 1 bit 0 = sndMono,1 = sndStereo,对于AAC总是1 第2byte开始就是音频流数据了。 2.2.2.视频数据和音频数据一样，第一个byte是视频信息，格式如下： 名称 长度 介绍 帧类型 4 bits 1: keyframe (for AVC, a seekable frame) 2: inter frame (for AVC, a non-seekable frame)3: disposable inter frame (H.263 only)4: generated keyframe (reserved for server use only)5: video info/command frame||编码ID |4 bits |1: JPEG (currently unused)2: Sorenson H.2633: Screen video4: On2 VP65: On2 VP6 with alpha channel6: Screen video version 27: AVC| 2.2.3脚本数据脚本Tag一般只有一个，是flv的第一个Tag，用于存放flv的信息，比如duration、audiodatarate、creator、width等。首先介绍下脚本的数据类型。所有数据都是以数据类型+（数据长度）+数据的格式出现的，数据类型占1byte，数据长度看数据类型是否存在，后面才是数据。其中数据类型的种类有： 0 = Number type 1 = Boolean type 2 = String type 3 = Object type 4 = MovieClip type 5 = Null type 6 = Undefined type 7 = Reference type 8 = ECMA array type 10 = Strict array type 11 = Date type 12 = Long string type 如果类型为String，后面的2bytes为字符串的长度（Long String是4bytes），再后面才是字符串数据；如果是Number类型，后面的8bytes为Double类型的数据；Boolean类型，后面1byte为Bool类型。 知道了这些后再来看看flv中的脚本，一般开头是0x02，表示String类型，后面的2bytes为字符串长度，一般是0x000a（“onMetaData”的长度），再后面就是字符串“onMetaData”。好像flv格式的文件都有onMetaData标记，在运行ActionScript的时候会用到它。后面跟的是0x08，表示ECMA Array类型，这个和Map比较相似，一个键跟着一个值。键都是String类型的，所以开头的0x02被省略了，直接跟着的是字符串的长度，然后是字符串，再是值的类型，也就是上面介绍的那些了。 3.总结flv的格式还是比较简单的，header部分很简洁，body部分都是由一个个tag，tag的话也就三种，脚本tag一般只有一个的，我想这也是flv能成为在线视频格式的原因吧。只要了解了格式，我们就可以写个程序来解析flv文件了，这也是我下一步要做的。最后附上flv官方手册：video_file_format_spec_v10]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>流媒体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS性能优化概述]]></title>
    <url>%2F2016%2F07%2F21%2F2016%2FiOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[响应速度与运行速度响应速度和运行速度之间有着微妙的区别，响应速度是指监听用户输入到反馈用户的速度，而运行速度是指处理任务的速度。用户都讨厌等待，所以你会说让App运行的更快非常重要。确实如此，但是运行速度的提升有一个边界，假如数据要通过网络下载，或者要进行复杂的计算和渲染，那么App不可能立即显示这些内容。这种情况下用户实际上还是愿意等待的，但是你要针对他们的操作给出即时的响应，这种响应可以是简单的按钮状态的改变也可以是复杂的动画效果。让App运行更快很重要，让其迅速响应同样重要。使用现实中真实的按钮和开关时会让人感觉靠谱，当按下按钮或者打开开关时你可以百分百确定你进行了操作。但是在触摸屏上你无法感知，所以视觉响应非常重要。如果一个App不能提供这种即时的响应那体验将变得非常糟糕，更具体点说就是响应时间不要超过三分之一秒。当你点击了某个位置但是没有任何事情发生，你会自然而然的认为点击有可能没有被接受。绝大多数人在这时会再点击一次，这可能造成重复的操作。 关于响应速度的三个原则： 迅速回馈用户他的操作已经被接受，然后迅速执行。例如点击按钮时提供一个touch-down状态呈现给用户。 允许用户任意时刻中断 当耗时操作进行时，反馈用户一个进度 针对上边提出的问题，给予状态提示是UI层面的事情，比较容易做到，但是如果保证无论任何时候用户的操作和触摸事件都能得到立刻的响应呢？ runloop与用户事件响应在每次的runloop中，需要处理下边几种事件： handlePort：跨线程通信的一些消息 customSrc: 被标记为UI待处理的事件 mySelector：本线程方法的调用 timerFired：定时器 当我们程序启动完之后，基本上线程就没有什么事情要处理了，这个时候能够做出改变这个状态的事物有下边这几种： 用户手势事件，点一下或者拖一下 系统消息，来电话等 具体的两种如下面所描述： 界面刷新： 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。 苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 手势识别： 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 总的来讲，并不是当用户触发一个事件的时候这个事件就会被马上执行，而是这个事件会被标记，加入被执行的事件队列，然后等待runloop从这个事件队列中取出来事件，然后执行。现在假如说，你有一个点击事件，这个时候这个事件被加入到待执行的事件中，如果前边有一系列的事件要做，那么这个事件就要排队，现象就是，你发现你点完之后没有任何的反应。[self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];利用该方法将大段的方法进行拆分，这样可以保证用户事件的响应。 性能优化运行时间前边我们保证了响应速度，现在我们来看一下，如何加快执行的速度。基本上我们能够依赖的就是Time Profiler， 渲染速度不幸的是Time Profiler不能找出所有的性能问题。当你的App的帧率掉到60（帧/秒）以下你的App就感觉运行得不是那么平滑了。低帧率导致滚动视图和动画卡顿。 帧率下降通常意味着iPad的渲染速度跟不上。视觉上较为理想的帧率不低于60（帧/秒），意味着每一帧应该在六十分之一秒内渲染完。 基本上我们使用上边这些选项来查找影响渲染的因素。 color blended layers我们知道GPU是图形硬件，主要的工作是混合纹理并算出像素的RGB值，这是一个非常复杂的计算过程，计算的过程越复杂，所需要消耗的时间就越长，GPU的使用率就越高，这并不是一个好的现像，而我们需要做的是减少GPU的计算量。我们在这个图层上放置一个完全不透明的图层，那么GPU将会把上面的图层合成到下面的图层当中，由于上面的是一个完全不透明的图层，所以上面的图层会部份遮盖掉下面的图层，而在遮盖掉的矩形区域内，GPU会直接使用上面图层的像素来显示。如果我们最底的图层上放置的是一个有透明度的图层，那么在这个矩形区域里，GPU需要混合上下两个图层来计算出在屏幕上显示出来的像素的RGB值。若在同一个区域内，存在着多个有透明度的图层，那么GPU需要更多的计算才能得出最终像素的RGB值。而我们要做的就是避免像素混合，尽可能地为视图设置背景色，且设置opaque为YES，这会大大减少GPU的计算。以label为例上边为不透明，下边为透明，那么我们得到的结果是下边混合严重上边为iOS7的情况，那么iOS8呢虽然设置了背景色，但在iOS8上用UILabel显示中文却出现了像素混合的情况，这是为什么呢？我们来看看UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变，就像上图所视(在iOS8刚发布的时候，我一度怀疑Apple歧视中文)。 那怎么解决呢？首先我们来观察一下上图，从图中我们可以看到在背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，既然发现这了一点，那么解决方案就很明了了。 设置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪，我们来看一下修改后的效果。木有问题了。maskTobounds需要与cornerRadius结合才会离屏渲染，所以这里并不会导致离屏渲染。可以的话，要求美工在切图的时候，一定不要切出那些留有透明区域的图片，不然在你显示图片的时候，同样会出现像素混合问题。 tableView的优化iOS平台因为UIKit本身的特性，需要将所有的UI操作都放在主线程执行，所以有时候就习惯将一些线程安全性不确定的逻辑，以及它线程结束后的汇总工作等等放到了主线程，所以主线程包含大量计算、IO、绘制都有可能造成卡顿。 可以通过监控runLoop监控监控卡顿，调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿. 使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化 监控后另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手. 监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈 当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑 设置正确的 reuseidentifer 以重用 cell 尽量将 View 设置为不透明,包括 cell 本身（backgroundcolor默认是透明的），图层混合靠GPU去渲染,如果透明度设置为100%，那么GPU就会忽略下面所有的layer，节约了很多不必要的运算。模拟器上点击“Debug”菜单，然后选择“color Blended Layers”，会把所有区域分成绿色和红色,绿色的好,红色的性能差（经过混合渲染的），当然也有一些图片虽然是不透明的，但是也会显示红色，如果检查代码没错的话，一般就是图片自身的性质问题了，直接联系美工或后台解决就好了。除非必须要用GPU加载的，其他最好要用CPU加载，因为CPU一般不会百分百加载，可以通过CoreGraphics画出圆角 有时候美工失误，图片大小给错了，引起不必要的图片缩放（可以找美工去改，当然也可以异步去裁剪图片然后缓存下来），还是使用Instrument的Color Misaligned Images，黄色表示图片需要缩放，紫色表示没有像素对齐。当然一般情况下图片格式不会给错，有些图片格式是GPU不支持的，就还要劳烦CPU去进行格式转换。还有可以通过Color Offscreen-Rendered Yellow来检测离屏渲染（就是把渲染结果临时保存，等到用的时候再取出，这样相对于普通渲染更消耗内存，使用maskToBounds、设置shadow，重写drawRect方法都会导致离屏渲染）避免渐变，cornerRadius在默认情况下，这个属性只会影响视图的背景颜色和 border，但是不会离屏绘制，不影响性能。不用clipsToBounds（过多调用GPU去离屏渲染），而是让后台加载图片并处理圆角，并将处理过的图片赋值给UIImageView。UIImageView 的圆角通过直接截取图片实现，圆角路径直接用贝塞尔曲线UIBezierPath绘制（人为指定路径之后就不会触发离屏渲染），UIGraphicsBeginImageContextWithOptions。UIView的圆角可以使用CoreGraphics画出圆角矩形，核心是CGContextAddArcToPoint 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回，最后把这个图片插入到视图层级的底部。“Flash updated Regions”用于标记发生重绘的区域 如果 row 的高度不相同,那么将其缓存下来 如果 cell 显示的内容来自网络,那么确保这些内容是通过异步下载 使用 shadowPath 来设置阴影，图层最好不要使用阴影,阴影会导致离屏渲染(在进入屏幕渲染之前,还看不到的时候会再渲染一次,尽量不要产生离屏渲染) 减少 subview 的数量，不要去添加或移除view，要就显示，不要就隐藏 在 cellForRowAtIndexPath 中尽量做更少的操作,最好是在别的地方算好，这个方法里只做数据的显示，如果需要做一些处理,那么最好做一次之后将结果储存起来. 使用适当的数据结构来保存需要的信息,不同的结构会带来不同的操作代价 使用,rowHeight , sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定高度 , 而不是从代理(delegate)中获取 cell做数据绑定的时候，最好在willDisPlayCell里面进行，其他操作在cellForRowAtIndexPath，因为前者是第一页有多少条就执行多少次，后者是第一次加载有多少个cell就执行多少次，而且调用后者的时候cell还没显示 读取文件,写入文件,最好是放到子线程,或先读取好,在让tableView去显示 tableView滚动的时候,不要去做动画(微信的聊天界面做的就很好,在滚动的时候,动态图就不让他动,滚动停止的时候才动,不然可能会有点影响流畅度)。在滚动的时候加载图片，停止拖拽后在减速过程中不加载图片，减速停止后加载可见范围内图片 代码优化checkList2.3 提前调整ImageView中的图片大小（同图片和动画的渲染）如果要在UIImageView中显示一个图片，你应保证图片的大小和UIImageView的大小相同。因为在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。 如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。 这个类比到图片和动画的渲染中，是通用的。 具体方法参考上面的GCD操作。 2.4 正确使用容器的特性Arrays: 有序的一组值。使用index来查找很快，使用value 查找很慢， 插入/删除很慢。 Dictionaries: 存储键值对。 用键来查找比较快。 Sets: 无序的一组值。用值来查找很快，插入/删除很快。 2.5 大文件传输使用gzip大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。 问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。 减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。 当然，现在苹果已经自动支持了，你只需要告诉你们服务端的同学，传输大文件的时候记得用gzip就完了。 2.6 View的重用和懒加载更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。 重用就是模仿UITableView和UICollectionView的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。当需要使用View的时候，去可重用队列里面找一找有没有可以被复用的View。这里我的一份框架中曾经使用过类似的方法去创建一个图片浏览器，大家可以稍做参考。View的重用 懒加载就是在程序启动时并不进行加载，只有当用到这个对象的时候，才进行加载。这个不仅在属性中可以进行这样的使用，在View上面也是一样，不过实现稍有不同。懒加载会消耗更少内存，但是在View的显示上会稍有滞后。 2.7 Cache一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。 我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。 NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。 下面是一个可用的代码段，你可以可以用它去为一个基本不会改变的图片创建一个NSURLRequest并缓存它： (NSMutableURLRequest )imageRequestWithURL:(NSURL )url { NSMutableURLRequest request = [NSMutableURLRequest requestWithURL:url]; request.cachePolicy = NSURLRequestReturnCacheDataElseLoad; // this will make sure the request always returns the cached image request.HTTPShouldHandleCookies = NO; request.HTTPShouldUsePipelining = YES; [request addValue:@”image/“ forHTTPHeaderField:@”Accept”]; return request; } 注意你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。 如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。 2.8 记得处理内存警告一旦系统内存过低，iOS会通知所有运行中app。在官方文档中是这样记述: 如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references. 幸运的是，UIKit提供了几种收集低内存警告的方法: 在app delegate中使用applicationDidReceiveMemoryWarning: 的方法 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning 注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知 一旦收到这类通知，你就需要释放任何不必要的内存使用。 例如，UIViewController的默认行为是移除一些不可见的view， 它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。 这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。 然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。 2.9 重用大的开销对象这里的大开销是指一些初始化很慢的objects，如：NSDateFormatter和NSCalendar。但是，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。 想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。 注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。 下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例： // in your .h or inside a class extension @property (nonatomic, strong) NSDateFormatter formatter; // inside the implementation (.m) // When you need, just use self.formatter - (NSDateFormatter )formatter { if (! _formatter) { _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @”EEE MMM dd HH:mm:ss Z yyyy”; // twitter date format } return _formatter; } 还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。 2.10 避免反复的处理数据许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。 比如你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。 类似的，如果需要从特定key中取数据，那么就使用键值对的dictionary。 2.11 正确设定背景图片在View里放背景图片就像很多其它iOS编程一样有很多方法: 使用UIColor的 colorWithPatternImage来设置背景色； 在view中添加一个UIImageView作为一个子View。 如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背景的。这种情形下使用UIImageView可以节约不少的内存： // You could also achieve the same result in Interface Builder UIImageView *backgroundView = [ [UIImageView alloc] initWithImage:[UIImage imageNamed:@”background”]]; [self.view addSubview:backgroundView]; 如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存： self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@”background”]]; 2.12 试试苹果最新的WKWebView来处理webUIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。 但是你可能有注意到UIWebView并不像驱动Safari的那么快。这是由于以JIT compilation 为特色的Webkit的Nitro Engine的限制。 所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。 另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。 最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。 当然，上面是针对你在使用UIWebView的情况下，需要尽量减少使用web的特性，而苹果最近刚推出的Safari的底层框架WKWebView也许能帮我们规避掉很多这样的性能问题。 2.13 优化你的TableViewTable view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。 为了保证table view平滑滚动，确保你采取了以下的措施: 正确使用reuseIdentifier来重用cells 尽量使所有的view opaque，包括cell自身 避免渐变，图片缩放，后台选人 缓存行高 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 使用shadowPath来画阴影 减少subviews的数量 尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate 2.14 选择正确的数据存储方式当存储大块数据时你会怎么做？ 你有很多选择，比如： 使用NSUerDefaults 使用XML, JSON, 或者 plist 使用NSCoding存档 使用类似SQLite的本地SQL数据库 使用 Core Data NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了 XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。 NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。 在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。 在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。 如果你使用SQLite，你可以用FMDB(https://github.com/ccgus/fmdb)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了。 2.15 把Xib换成Storyboard吧当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。 Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller. 当加载XIB时，所有图片都被缓存，如果你在做OS X开发的话，声音文件也是。Apple在相关文档中的记述是： 当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的imageNamed:方法来获取图片资源。 很明显，同样的事情也发生在storyboards中，但我并没有找到任何支持这个结论的文档。 另外，快速打开app是很重要的，特别是用户第一次打开它时，对app来讲，第一印象太太太重要了。 你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。 还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！ 注意，用Xcode debug时watchdog并不运行，一定要把设备从Xcode断开来测试启动速度 2.16 学会手动创建Autorelease PoolNSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。 假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。 好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为： NSArray urls = [@”url1”,@”url2”]; for (NSURL url in urls) { @autoreleasepool { NSError error; NSString fileContents = [NSString stringWithContentsOfURL: url encoding: NSUTF8StringEncoding error: &amp;error]; / Process the string, creating and autoreleasing more objects. / } } 这段代码在每次遍历后释放所有autorelease对象 2.17UIImage初始化A：imagedNamed初始化 B：imageWithContentsOfFile初始化 二者不同之处在于，imageNamed默认加载图片成功后会内存中缓存图片，这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象，如果缓存中没有找到相应的图片对象，则从指定地方加载图片然后缓存对象，并返回这个图片对象 而imageWithContentsOfFile则仅只加载图片，不缓存 大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事，当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式，这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间 使用场景需要编程时，应该根据实际应用场景加以区分，UIimage虽小，但使用元素较多问题会有所凸显 2.18列表滚动的时候不要对imageview赋值12// 只在NSDefaultRunLoopMode模式下显示图片 [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;placeholder&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]]; 比如修改sdwebimage中的方法，如果设置imageview为滚动列表模式，则加入该方法，当列表停止滚动模式的时候才加载图片 一些第三方的使用 当然有时候也会用到一些第三方，比如在使用UICollectionView和UITableView的时候，Facebook有一个框架叫AsyncDisplayKit，这个库就可以很好地提升滚动时流畅性以及图片异步下载功能（不支持sb和autoLayout，需要手动进行约束设置），AsyncDisplayKit用相关node类，替换了UIView和它的子类,而且是线程安全的。它可以异步解码图片，调整图片大小以及对图片和文本进行渲染，把这些操作都放到子线程，滑动的时候就流畅许多。我认为这个库最方便的就是实现图片异步解码。UIImage显示之前必须要先解码完成，而且解码还是同步的。尤其是在UICollectionView/UITableView 中使用 prototype cell显示大图，UIImage的同步解码在滚动的时候会有明显的卡顿。另外一个很吸引人的点是AsyncDisplayKit可以把view层次结构转成layer。因为复杂的view层次结构开销很大，如果不需要view特有的功能（例如点击事件），就可以使用AsyncDisplayKit 的layer backing特性从而获得一些额外的提升。当然这个库还处于开发阶段，还有一些地方地方有待完善，比如不支持缓存，我要使用这个库的时候一般是结合Alamofire和AlamofireImage实现图片的缓存]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[block进阶4--block的逻辑理解]]></title>
    <url>%2F2016%2F06%2F29%2F2016%2F%E8%BD%AC-block%E8%BF%9B%E9%98%B64-block%E7%9A%84%E9%80%BB%E8%BE%91%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[对为什么要像前边三篇文章分析的那样去实现block？block是一种类似于闭包的技术，也就是将一段代码保存，然后在需要的时候再执行，这样就带来了两个问题 我怎么保证当我需要执行这段block代码的时候，block本身是存在的 因为代码执行的参数需要，我如何保证当我执行的时候参数是可用的 我们通过前边的学习知道，block是一个结构体，要执行的代码会被封装为一段函数，然后这个函数的指针被结构体引用，而这个函数的一个参数就是block结构体，因为我们需要从结构体中获取需要的参数block结构体---&gt;方法-----&gt;从block结构体获取参数 保证block本身存在首先如果 block字面量写在全局区为global block block字面量没有获取任何外部变量，为global block其他情况全部为statck block，global block存在于全局区，不依赖上下文，内存管理没有啥大的困扰，栈block在内存中的栈区，变量的作用域结束后，block会被废弃，同时block也会被废弃，我们需要为栈block找到一个提升生命周期的方法。为了解决这个问题，block提供了copy功能，将block和block变量从栈拷贝到堆，此时这个block也就变成了堆block，这样只要引用的指针存在，block的生存就不成问题。至于这个copy的功能应该说比较隐晦copy的调用时机因为block是匿名的，所以当我们不创建一个block声明的话，我们不能够调用和使用这个block，所以所以我们可以对block的使用情况做如下的归纳： 作为变量 作为方法参数 第一种情况下，我们总需要做一个赋值的操作，否则无法使用block，我们可以像下边这样打印一个捕获局部变量的block1NSLog(@&quot;%@&quot;, ^&#123;NSLog(@&quot;%d&quot;, c);&#125;);//结果是这是给stackblock 所以并不是捕获了局部变量就是堆block的，需要做一个赋值操作123void(^myBlock)() = ^&#123;NSLog(@&quot;%d&quot;, c);&#125;; NSLog(@&quot;%@&quot;, myBlock); 这个时候我们得到的就是一个mallocblock了，这是因为这个变量前边有个默认的关键字__strong，这个时候编译器会默认对block做copy操作的 第二种情况，作为一个参数被传递的时候，如果是栈block，那么默认也是做copy操作的1234- (MyBlcok)getaBlock&#123; int a = 0; return ^()&#123;NSLog(@&quot;%d&quot;, a);&#125;;&#125; 打印该block发现是mallocblock 保证参数可用全局变量我们使用一个参数无非做取值和赋值两种操作，而我们能否拿到这个变量一个关键点在于这个变量的作用域，本质来讲block是一个单独的作用域，全局变量穿透没有问题，但是局部变量就无法被直接使用，所以局部变量在使用的时候，是在block结构体内部又重新定义了另外一个变量，然后将值赋给这个变量，这样的结果就是，该变量首先可以被block使用了，其次生命周期与block一致了，不会存在被访问的时候释放这样的问题了，这个block内部的同名变量与局部变量其实没有任何的关系。修改该变量的值并不会改变局部变量的值。 局部变量当我们在局部变量的外边加上一个const的时候，这个变量的生命周期发生了改变，并且内存上移动到了静态变量区，但是作用域并没有变化，所以还是不能穿透block像全局变量一样被赋值，当然我们发现，这个时候我们是可以改变局部变量的值得，其实这个时候系统的做法是，将该局部变量的指针传入进去，因为加上了const首先起码生命周期一致了，能够保证不会被释放了，将指针传入进去，这个时候我们可以通过指针来访问该静态变量的内存地址进行一些修改的操作 __block当然对于修改局部变量除了提升其生命周期还有一种办法就是加上__block关键字，该关键字的作用是生成了另外一个结构体，然后赋值给block，这样一方面保证了生命周期一致，又因为最后的执行函数以block为参数，所以访问该变量问题不大，也解决了作用域的问题]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)block进阶3--block和对象的内存管理]]></title>
    <url>%2F2016%2F06%2F25%2F2016%2F%E8%BD%AC-block%E8%BF%9B%E9%98%B63-block%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[原文链接https://www.zybuluo.com/MicroCai/note/51116在上一篇文章中，我们讲了很多关于 block 和基础变量的内存管理，接着我们聊聊 block 和对象的内存管理，如 block 经常会碰到的循环引用问题等等。 获取对象照例先来段代码轻松下，瞧瞧 block 是怎么获取外部对象的123456789101112131415161718/********************** capturing objects **********************/typedef void (^blk_t)(id obj);blk_t blk;- (void)viewDidLoad&#123; [self captureObject]; blk([[NSObject alloc] init]); blk([[NSObject alloc] init]); blk([[NSObject alloc] init]);&#125;- (void)captureObject&#123; id array = [[NSMutableArray alloc] init]; blk = [^(id obj) &#123; [array addObject:obj]; NSLog(@&quot;array count = %ld&quot;, [array count]); &#125; copy];&#125; 翻译后的关键代码摘录如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* a struct for the Block and some functions */struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0 *Desc; id __strong array; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id __strong _array, int flags=0) : array(_array) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself, id obj)&#123; id __strong array = __cself-&gt;array; [array addObject:obj]; NSLog(@&quot;array count = %ld&quot;, [array count]);&#125;static void __main_block_copy_0(struct __main_block_impl_0 *dst, __main_block_impl_0 *src)&#123; _Block_object_assign(&amp;dst-&gt;array, src-&gt;array, BLOCK_FIELD_IS_OBJECT);&#125;static void __main_block_dispose_0(struct __main_block_impl_0 *src)&#123; _Block_object_dispose(src-&gt;array, BLOCK_FIELD_IS_OBJECT);&#125;struct static struct __main_block_desc_0&#123; unsigned long reserved; unsigned long Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0 &#125;;/* Block literal and executing the Block */blk_t blk;&#123; id __strong array = [[NSMutableArray alloc] init]; blk = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, array, 0x22000000); blk = [blk copy];&#125;(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]); 在本例中，当变量变量作用域结束时，array 被废弃，强引用失效，NSMutableArray 类的实例对象会被释放并废弃。在这危难关头，block 及时调用了 copy 方法，在 _Block_object_assign 中，将 array 赋值给 block 成员变量并持有。所以上面代码可以正常运行，打印出来的 array count 依次递增。 总结代码可正常运行的原因关键就在于 block 通过调用 copy 方法，持有了 __strong 修饰的外部变量，使得外部对象在超出其作用域后得以继续存活，代码正常执行。 在以下情形中， block 会从栈拷贝到堆： 当 block 调用 copy 方法时，如果 block 在栈上，会被拷贝到堆上； 当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法； 当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法； 当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;其实后三种情况在上篇文章block的自动拷贝已经做过说明除此之外，都需要手动调用。 延伸阅读：Objective-C 结构体中的 __strong 成员变量 注意到 main_block_impl_0 结构体有什么异常没？在 C 结构体中出现了 strong 关键字修饰的变量。 通常情况下， Objective-C 的编译器因为无法检测 C 结构体初始化和释放的时间，不能进行有效的内存管理，所以 Objective-C 的 C 结构体成员是不能用 strong、weak 等等这类关键字修饰。然而 runtime 库是可以在运行时检测到 block 的内存变化，如 block 何时从栈拷贝到堆，何时从堆上释放等等，所以就会出现上述结构体成员变量用 __strong 修饰的情况。 __block 变量和对象__block 说明符可以修饰任何类型的自动变量。下面让我们再看个小例子，啊，愉快的代码时间又到啦。 12/******* block 修饰对象 *******/__block id obj = [[NSObject alloc] init]; ARC 下，对象所有权修饰符默认为 __strong，即 123456789101112131415161718192021222324252627282930__block id __strong obj = [[NSObject alloc] init];/******* block 修饰对象转换后的代码 *******//* struct for __block variable */struct __Block_byref_obj_0 &#123; void *__isa; __Block_byref_obj_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); __strong id obj;&#125;;static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123; _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);&#125;static void __Block_byref_id_object_dispose_131(void *src) &#123; _Block_object_dispose(*(void * *) ((char*)src + 40), 131);&#125;/* __block variable declaration */__Block_byref_obj_0 obj = &#123; 0, &amp;obj, 0x2000000, sizeof(__Block_byref_obj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, [[NSObject alloc] init] &#125;; block id strong obj 的作用和 id strong obj 的作用十分类似。当 block id strong obj 从栈上拷贝到堆上时，_Block_object_assign 被调用，block 持有 obj；当 block id __strong obj 从堆上被废弃时，_Block_object_dispose 被调用用以释放此对象，block 引用消失。 所以，只要是堆上的 strong 修饰符修饰的 block 对象类型的变量，和 block 内获取到的 __strong 修饰符修饰的对象类型的变量，编译器都能对它们的内存进行适当的管理。 如果上面的 strong 换成 weak，结果会怎样呢？ 123456789101112131415161718192021222324/********************** capturing __weak objects **********************/typedef void (^blk_t)(id obj);blk_t blk;- (void)viewDidLoad&#123; [self captureObject]; blk([[NSObject alloc] init]); blk([[NSObject alloc] init]); blk([[NSObject alloc] init]);&#125;- (void)captureObject&#123; id array = [[NSMutableArray alloc] init]; id __weak array2 = array; blk = [^(id obj) &#123; [array2 addObject:obj]; NSLog(@&quot;array2 count = %ld&quot;, [array2 count]); &#125; copy];&#125;结果是：array2 count = 0array2 count = 0array2 count = 0 原因很简单，array2 是弱引用，当变量作用域结束，array 所指向的对象内存被释放，array2 指向 nil，向 nil 对象发送 count 消息就返回结果 0 了。 如果 weak 再改成 unsafe_unretained 呢？__unsafe_unretained 修饰的对象变量指针就相当于一个普通指针。使用这个修饰符有点需要注意的地方是，当指针所指向的对象内存被释放时，指针变量不会被置为 nil。所以当使用这个修饰符时，一定要注意不要通过悬挂指针（指向被废弃内存的指针）来访问已经被废弃的对象内存，否则程序就会崩溃。 如果 unsafe_unretained 再改成 autoreleasing 会怎样呢？会报错，编译器并不允许你这么干！如果你这么写 __block id __autoreleasing obj = [[NSObject alloc] init];编译器就会报下面的错误，意思就是 block 和 autoreleasing 不能同时使用。 1error: __block variables cannot have __autoreleasing ownership __block id __autoreleasing obj = [[NSObject alloc] init]; 循环引用千辛万苦，重头戏终于来了。block 如果使用不小心，就容易出现循环引用，导致内存泄露。到底哪里泄露了呢？通过前面的学习，各位童鞋应该有个底了，下面就让我们一起进入这泄露地区瞧瞧，哪儿出了问题！ 愉快的代码时间到 123456789101112131415161718192021222324252627// ARC enabled/************** MyObject Class **************/typedef void (^blk_t)(void);@interface MyObject : NSObject&#123; blk_t blk_;&#125; @end@implementation MyObject- (id)init&#123; self = [super init]; blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;; return self;&#125;- (void)dealloc&#123; NSLog(@&quot;dealloc&quot;);&#125; @end/************** main function **************/int main()&#123; id myObject = [[MyObject alloc] init]; NSLog(@&quot;%@&quot;, myObject); return 0;&#125; 由于 self 是 __strong 修饰，在 ARC 下，当编译器自动将代码中的 block 从栈拷贝到堆时，block 会强引用和持有 self，而 self 恰好也强引用和持有了 block，就造成了传说中的循环引用。 由于循环引用的存在，造成在 main() 函数结束时，内存仍然无法释放，即内存泄露。编译器也会给出警告信息12345warning: capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle [-Warc-retain-cycles] blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;;note: Block will be retained by an object strongly retained by the captured object blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;; 为了避免这种情况发生，可以在变量声明时用 weak 修饰符修饰变量 self，让 block 不强引用 self，从而破除循环。iOS4 和 Snow Leopard 由于对 weak 的支持不够完全，可以用 unsafe_unretained 代替。ƒ12345678910111213- (id)init&#123; self = [super init]; id __weak tmp = self; blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, tmp);&#125;; return self;&#125;``` ![](http://i1.piimg.com/567571/b1057b9ff703d7cd.png)再看一个例子 @interface MyObject : NSObject{ blkt blk; id obj_;}@end@implementation MyObject (id)init{ self = [super init]; blk = ^{ NSLog(@”obj = %@”, obj_); }; return self;}……@end1234567上面的例子中，虽然没有直接使用 self，却也存在循环引用的问题。因为对于编译器来说，obj_ 就相当于 self-&gt;obj_，所以上面的代码就会变成`blk_ = ^&#123; NSLog(@&quot;obj_ = %@&quot;, self-&gt;obj_); &#125;;`所以这个例子只要用 __weak，在 init 方法里面加一行即可`id __weak obj = obj_;`破解循环引用还有一招，使用 __block 修饰对象，在 block 内将对象置为 nil 即可，如下 typedef void (^blk_t)(void);@interface MyObject : NSObject{ blkt blk;}@end@implementation MyObject (id)init{ self = [super init]; _block id tmp = self; blk = ^{ NSLog(@&quot;self = %@&quot;, tmp); tmp = nil; }; return self;} (void)execBlock{ blk_();} (void)dealloc{ NSLog(@”dealloc”);}@endint main(){ id object = [[MyObject alloc] init]; [object execBlock]; return 0;}1234567891011这个例子挺有意思的，如果执行 execBlock 方法，就没有循环引用，如果不执行就有循环引用，挺值得玩味的。一方面，使用 __block 挺危险的，万一代码中不执行 block ，就造成了循环引用，而且编译器还没法检查出来；另一方面，使用 __block 可以让我们通过 __block 变量去控制对象的生命周期，而且有可能在一些非常老旧的 MRC 代码中，由于不支持 __weak，我们可以使用此方法来代替 __unsafe_unretained，从而避免悬挂指针的问题。还有个值得一提的时，在 MRC 下，使用 __block 说明符也可以避免循环引用。因为当 block 从栈拷贝到堆时，__block 对象类型的变量不会被 retain，没有 __block 说明符的对象类型的变量则会被 retian。正是由于 __block 在 ARC 和 MRC 下的巨大差异，我们在写代码时一定要区分清楚到底是 ARC 还是 MRC。&gt;尽管 ARC 已经如此普及，我们可能已经可以不用去管 MRC 的东西，但要有点一定要明白，ARC 和 MRC 都是基于引用计数的内存管理，其本质上是一个东西，只不过 ARC 在编译期自动化的做了内存引用计数的管理，使得系统可以在适当的时候保留内存，适当的时候释放内存。循环引用到此为止，东西并不多。如果明白了之前的知识点，就会了解循环引用不过是前面知识点的自然延伸点罢了。## Copy 和 Release在 ARC 下，有时需要手动拷贝和释放 block。在 MRC 下更是如此，可以直接用 copy 和 release 来拷贝和释放 void (^blk_on_heap)(void) = [blk_on_stack copy];[blk_on_heap release];12拷贝到堆后，就可以 用 retain 持有 block [blk_on_heap retain];123然而如果 block 在栈上，使用 retain 是毫无效果的，因此推荐使用 copy 方法来持有 block。block 是 C 语言的扩展，所以可以在 C 中使用 block 的语法。比如，在上面的例子中，可以直接使用 Block_copy 和 Block_release 函数来代替 copy 和 release 方法 void (^blk_on_heap)(void) = Block_copy(blk_on_stack);Block_release(blk_on_heap);```Block_copy 的作用相当于之前看到过的 _Block_copy 函数，而且 Objective-C runtime 库在运行时拷贝 block 用的就是这个函数。同理，释放 block 时，runtime 调用了 Block_release 函数。 最后这里有一篇总结 block 的文章的很不错，推荐大家看看：http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)block进阶2--block和变量内存管理]]></title>
    <url>%2F2016%2F06%2F25%2F2016%2F%E8%BD%AC-block%E8%BF%9B%E9%98%B62-block%E5%92%8C%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[了解了 block的实现，我们接着来聊聊 block 和变量的内存管理。本文将介绍可写变量、block的内存段、__block变量的内存段等内容，看完本文会对 block 和变量的内存管理有更加清晰的认识。上篇文章举了个例子，在 block 内获取了一个外部的局部变量，可以读取，但无法进行写入的修改操作。在 C 语言中有三种类型的变量，可在 block 内进行读写操作 全局变量 全局静态变量 静态变量 全局变量 和 全局静态变量 由于作用域在全局，所以在 block 内访问和读写这两类变量和普通函数没什么区别，而 静态变量 作用域在 block 之外，是怎么对它进行读写呢？通过 clang 工具，我们发现原来 静态变量 是通过指针传递，将变量传递到 block 内，所以可以修改变量值。而上篇文章中的外部变量是通过值传递，自然没法对获取到的外部变量进行修改。由此，可以给我们一个启示，当我们需要修改外部变量时，是不是也可以像 静态变量 这样通过指针来修改外部变量的值呢？ Apple 早就为我们准备了这么一个东西 —— “__block” __block 说明符按照惯例，重写一小段代码看看 __block 的真身123456789/************* 使用 __block 的源码 *************/int main()&#123; __block int intValue = 0; void (^blk)(void) = ^&#123; intValue = 1; &#125;; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/************* 使用 clang 翻译后如下 *************/struct __block_impl&#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;struct __Block_byref_intValue_0&#123; void *__isa; __Block_byref_intValue_0 *__forwarding; int __flags; int __size; int intValue;&#125;;struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_intValue_0 *intValue; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_intValue_0 *_intValue, int flags=0) : intValue(_intValue-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; __Block_byref_intValue_0 *intValue = __cself-&gt;intValue; // bound by ref (intValue-&gt;__forwarding-&gt;intValue) = 1;&#125;static void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)&#123; _Block_object_assign((void*)&amp;dst-&gt;intValue, (void*)src-&gt;intValue, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0 *src)&#123; _Block_object_dispose((void*)src-&gt;intValue, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0 &#125;;int main()&#123; __attribute__((__blocks__(byref))) __Block_byref_intValue_0 \ intValue = &#123; (void*)0, (__Block_byref_intValue_0 *)&amp;intValue, 0, sizeof(__Block_byref_intValue_0), 0 &#125;; void (*blk)(void) = (void (*)()) &amp;__main_block_impl_0 \ ( (void *)__main_block_func_0, \ &amp;__main_block_desc_0_DATA, \ (__Block_byref_intValue_0 *)&amp;intValue, \ 570425344 \ ); return 0;&#125; 在加了 __block 之后，代码量增加了不少，仔细查看，其实只是比原来多了 -Block_byref_intValue_0 结构体：用于封装 block 修饰的外部变量。 _Block_object_assign 函数：当 block 从栈拷贝到堆时，调用此函数。 _Block_object_dispose 函数：当 block 从堆内存释放时，调用此函数。 OC源码中的 block intValue 翻译后变成了 Block_byref_intValue_0 结构体指针变量 intValue，通过指针传递到 block 内，这与前面说的 静态变量 的指针传递是一致的。除此之外，整体的执行流程与不加 block 基本一致，不再赘述。但 Block_byref_intValue_0 这个结构体需特别注意下 123456789// 存储 __block 外部变量的结构体struct __Block_byref_intValue_0&#123; void *__isa; // 对象指针 __Block_byref_intValue_0 *__forwarding; // 指向自己的指针 int __flags; // 标志位变量 int __size; // 结构体大小 int intValue; // 外部变量&#125;; 在已有结构体指针指向 __Block_byref_intValue_0 时，结构体里面还多了个 __forwarding 指向自己的指针变量，难道不显得多余吗？一点也不，本文后面会阐述。 block 的内存管理在前文中，已经提到了 block 的三种类型 NSConcreteGlobalBlock、_NSConcreteStackBlock、_NSConcreteMallocBlock，见名知意，可以看出三种 block 在内存中的分布 _NSConcreteGlobalBlock 1、当 block 字面量写在全局作用域时，即为 global block； 2、当 block 字面量不获取任何外部变量时，即为 global block； 除了上述描述的两种情况，其他形式创建的 block 均为 stack block。 123456// 下面 block 虽然定义在 for 循环内，但符合第二种情况，所以也是 global blocktypedef int (^blk_t)(int);for (int rate = 0; rate &lt; 10; ++rate) &#123; blk_t blk = ^(int count)&#123;return rate * count;&#125;; &#125; _NSConcreteGlobalBlock 类型的 block 处于内存的 ROData 段，此处没有局部变量的骚扰，运行不依赖上下文，内存管理也简单的多。 _NSConcreteStackBlock_NSConcreteStackBlock 类型的 block 处于内存的栈区。global block 由于处在 data 段，可以通过指针安全访问，但 stack block 处在内存栈区，如果其变量作用域结束，这个 block 就被废弃，block 上的 __block 变量也同样会被废弃。 为了解决这个问题，block 提供了 copy 的功能，将 block 和 __block 变量从栈拷贝到堆，就是下面要说的 _NSConcreteMallocBlock。 _NSConcreteMallocBlock当 block 从栈拷贝到堆后，当栈上变量作用域结束时，仍然可以继续使用 block此时，堆上的 block 类型为 _NSConcreteMallocBlock，所以会将 _NSConcreteMallocBlock 写入 isa 1impl.isa = &amp;_NSConcreteMallocBlock; 如果你细心的观察上面的转换后的代码，会发现访问结构体 Block_byref_intValue_0 内部的成员变量都是通过访问 forwarding 指针完成的。为了保证能正确访问栈上的 block 变量，进行 copy 操作时，会将栈上的 forwarding 指针指向了堆上的 block 结构体实例。 block 的自动拷贝和手动拷贝在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当 block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法； 但方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝，比如： 当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法； 当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法； 当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝; 让我们看个 block 自动拷贝的例子123456/************ ARC下编译器自动拷贝block ************/typedef int (^blk_t)(int);blk_t func(int rate)&#123; return ^(int count)&#123;return rate * count;&#125;;&#125; 上面的 block 获取了外部变量，所以是创建在栈上，当 func 函数返回给调用者时，脱离了局部变量 rate 的作用范围，如果调用者使用这个 block 就会出问题。那 ARC 开启的情况呢？运行这个 block 一切正常。和我们的预期结果不一样，ARC 到底给 block 施了什么魔法？我们将上面的代码翻译下123456blk_t func(int rate)&#123; blk_t tmp = &amp;__func_block_impl_0(__func_block_func_0, &amp;__func_block_desc_0_DATA, rate); tmp = objc_retainBlock(tmp); return objc_autoreleaseReturnValue(tmp); &#125; 转换后出现两个新函数 objc_retainBlock、objc_autoreleaseReturnValue。如果你看过runtime 库（点此下载） ，在 runtime/objc-arr.mm 文件中就有这两个函数的实现： 1234567891011121314/*********** objc_retainBlock() 的实现 ***********/id objc_retainBlock(id x) &#123;#if ARR_LOGGING objc_arr_log(&quot;objc_retain_block&quot;, x); ++CompilerGenerated.blockCopies;#endif return (id)_Block_copy(x);&#125;// Create a heap based copy of a Block or simply add a reference to an existing one.// This must be paired with Block_release to recover memory, even when running// under Objective-C Garbage Collection.BLOCK_EXPORT void *_Block_copy(const void *aBlock) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2); 123456789101112 /*********** objc_autoreleaseReturnValue() 的实现 ***********/id objc_autoreleaseReturnValue(id obj)&#123;#if SUPPORT_RETURN_AUTORELEASE assert(_pthread_getspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY) == NULL); if (callerAcceptsFastAutorelease(__builtin_return_address(0))) &#123; _pthread_setspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY, obj); return obj; &#125;#endif return objc_autorelease(obj);&#125; 通过上面的代码和注释，意思就很明显了，由于 block 字面量是创建在栈内存，通过 objc_retainBlock() 函数拷贝到堆内存，让 tmp 重新指向堆上的 block，然后将 tmp 所指的堆上的 block 作为一个 Objective-C 对象放入 autoreleasepool 里面，从而保证了返回后的 block 仍然可以正确执行。 看完了 block 的自动拷贝，那么看看在 ARC 下需要手动拷贝 block 的例子 12345678/************ ARC下编译器手动拷贝block ************/- (id)getBlockArray&#123; int val = 10; return [[NSArray alloc] initWithObjects: ^&#123;NSLog(@&quot;blk0:%d&quot;, val);&#125;, ^&#123;NSLog(@&quot;blk1:%d&quot;, val);&#125;, nil];&#125; 一个例子就了然，返回的数组里面的 block 是不可用的，需要再手动拷贝一次才可以，这个较为简单，就不作过多解释。 关于 block 的拷贝操作可以用一张表总结下 block 拷贝的讲解就到此为止，有兴趣可以了解下 block 的多次拷贝。 123456789101112131415161718192021block的多次拷贝：下面的例子在 ARC 下并不会产生内存泄露哦// block 多次拷贝源码blk = [[[[blk copy] copy] copy] copy]; // 翻译后的代码&#123; blk_t tmp = [blk copy]; blk = tmp; &#125;&#123; blk_t tmp = [blk copy]; blk = tmp; &#125;&#123; blk_t tmp = [blk copy]; blk = tmp; &#125;&#123; blk_t tmp = [blk copy]; blk = tmp;&#125; __block 变量的内存管理上面啰嗦一堆，这小节主要用图说话，必要时加文字说明。 当 block 从栈内存被拷贝到堆内存时，block 变量的变化如下图。需要说明的是，当栈上的 block 被拷贝到堆上，堆上的 block 再次被拷贝时，对 block 变量已经没有影响了。 当多个 block 获取同一个 __block 变量，block 从栈被拷贝到堆时 当 block 被废弃时，__block 变量被释放 __forwarding 前文已经说过，当 block 从栈被拷贝到堆时，forwarding 指针变量也会指向堆区的结构体。但是为什么要这么做呢？为什么要让原本指向栈区的结构体的指针，去指向堆区的结构体呢？看起来匪夷所思，实则原因很简单，要从 forwarding 产生的缘由说起。想想起初为什么要给 block 添加 copy 的功能，就是因为 block 获取了局部变量，当要在其他地方（超出局部变量作用范围）使用这个 block 的时候，由于访问局部变量异常，导致程序崩溃。为了解决这个问题，就给 block 添加了 copy 功能。在将 block 拷贝到堆上的同时，将 forwarding 指针指向堆上结构体。后面如果要想使用 block 变量，只要通过 __forwarding 访问堆上变量，就不会出现程序崩溃了。123456789/*************** __forwarding 的作用 ***************///猜猜下面代码的打印结果？&#123; __block int val = 0; void (^blk)(void) = [^&#123;++val;&#125; copy]; ++val; blk(); NSLog(@&quot;%d&quot;, val);&#125; 一定有很多人会猜 1，其实打印 2。原因很简单，当栈上的 block 被拷贝到堆上时，栈上的 forwarding 也会指向堆上的 block 变量的结构体。 上面的代码中 ^{++val;} 和 ++val; 都会被转换成 ++(val.__forwarding-&gt;val);，堆上的 val 被加了两次，最后打印堆上的 val 为 2。]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础知识-文件操作]]></title>
    <url>%2F2016%2F04%2F16%2F2017%2FPython%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[python中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块。 得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd() 返回指定目录下的所有文件和目录名:os.listdir() 函数用来删除一个文件:os.remove() 删除多个目录：os.removedirs（r“c：\python”） 检验给出的路径是否是一个文件：os.path.isfile() 检验给出的路径是否是一个目录：os.path.isdir() 判断是否是绝对路径：os.path.isabs() 检验给出的路径是否真地存:os.path.exists() 返回一个路径的目录名和文件名:os.path.split() 1os.path.split(&apos;/home/swaroop/byte/code/poem.txt&apos;) 结果：(&apos;/home/swaroop/byte/code&apos;, &apos;poem.txt&apos;) 分离扩展名：os.path.splitext() 获取路径名：os.path.dirname() 获取文件名：os.path.basename() 运行shell命令: os.system() 读取和设置环境变量:os.getenv() 与os.putenv() 给出当前平台使用的行终止符:os.linesep Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’ 指示你正在使用的平台：os.name 对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’ 重命名：os.rename（old， new） 创建多级目录：os.makedirs（r“c：\python\test”） 创建单个目录：os.mkdir（“test”） 获取文件属性：os.stat（file） 修改文件权限与时间戳：os.chmod（file） 终止当前进程：os.exit（） 获取文件大小：os.path.getsize（filename） os.mknod(“test.txt”) 创建空文件 fp = open(“test.txt”,w) 直接打开一个文件，如果文件不存在则创建文件 关于open 模式:w 以写方式打开，a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a )rb 以二进制读模式打开wb 以二进制写模式打开 (参见 w )ab 以二进制追加模式打开 (参见 a )rb+ 以二进制读写模式打开 (参见 r+ )wb+ 以二进制读写模式打开 (参见 w+ )ab+ 以二进制读写模式打开 (参见 a+ ) fp.read([size]) #size为读取的长度，以byte为单位 fp.readline([size]) #读一行，如果定义了size，有可能返回的只是一行的一部分 fp.readlines([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。 fp.write(str) #把str写到文件中，write()并不会在str后加上一个换行符 fp.writelines(seq) #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。 fp.close() #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError fp.flush() #把缓冲区的内容写入硬盘 fp.fileno() #返回一个长整型的”文件标签“ fp.isatty() #文件是否是一个终端设备文件（unix系统中的） fp.tell() #返回文件操作标记的当前位置，以文件的开头为原点 fp.next() #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。 fp.seek(offset[,whence]) #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。 fp.truncate([size]) #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。 os.mkdir(“file”) 创建目录复制文件： shutil.copyfile(“oldfile”,”newfile”) oldfile和newfile都只能是文件 shutil.copy(“oldfile”,”newfile”) oldfile只能是文件夹，newfile可以是文件，也可以是目标目录复制文件夹： shutil.copytree(“olddir”,”newdir”) olddir和newdir都只能是目录，且newdir必须不存在重命名文件（目录） os.rename(“oldname”,”newname”) 文件或目录都是使用这条命令移动文件（目录） shutil.move(“oldpos”,”newpos”)删除文件 os.remove(“file”)删除目录 os.rmdir(“dir”)只能删除空目录shutil.rmtree(“dir”) 空目录、有内容的目录都可以删转换目录 os.chdir(“path”) 换路径]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础知识-字典]]></title>
    <url>%2F2016%2F04%2F10%2F2017%2FPython%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[字典这种数据结构，我们又称之为映射(mapping)，在java中也是这么称呼的，但是在python中我们称之为字典，与OC中的叫法一致。 创建字典1234567891011121314&gt;&gt;&gt; dicts = &#123;&apos;name&apos;:&apos;han&apos;,&apos;tele&apos;:&apos;136&apos;&#125;//直接创建&gt;&gt;&gt; xiaohan = (&apos;xiaohan&apos;,42)//利用dict函数来创建&gt;&gt;&gt; xiaoming = (&apos;xiaoming&apos;,45)&gt;&gt;&gt; items = [xiaohan,xiaoming]&gt;&gt;&gt; d = dict(items)&gt;&gt;&gt; d&#123;&apos;xiaohan&apos;: 42, &apos;xiaoming&apos;: 45&#125;&gt;&gt;&gt; &gt;&gt;&gt; d = dict(name=&apos;han&apos;,age=43)//或者dict函数还可以这样来用&gt;&gt;&gt; d&#123;&apos;age&apos;: 43, &apos;name&apos;: &apos;han&apos;&#125;&gt;&gt;&gt; 基本操作 len(d)返回d中键值对的数量 d[k]返回关联到k上的值 d[k]=v将值v关联到键为k的项上 del d[k]删除键为k的项 k in d检查d中是否含有键为k的项 键类型可以是任意类型，比如元组，浮点数或者字符串 自动添加，及时键起出在字典中并不存在，也可以赋值，这样字典就会建立起新的项 成员资格:用k in d查找的是键而不是值，而在列表中，v in l是用值在查找，而不是索引 字典方法clear12 ###]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础知识-列表/元组/字符串]]></title>
    <url>%2F2016%2F04%2F09%2F2017%2FPython%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%88%97%E8%A1%A8-%E5%85%83%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[列表和元组在python中我们有两种很重要的数据结构，分别为序列和映射，对应到OC中就是数组和字典，序列又分为列表和元组，他们的区别在于，列表可修改，元组不能，列表用方括号[]，而元组用小括号（）12list = [&apos;hanshenghui&apos;,&apos;xiaoming&apos;]list1 = (&apos;hanshenghui&apos;,&apos;xiaoming&apos;) 序列通用操作列表和元组都能做的操作 索引12345678910111213&gt;&gt;&gt; greeting = &apos;hello&apos;&gt;&gt;&gt; greeting[1]&apos;e&apos;&gt;&gt;&gt; greeting[2]&apos;l&apos;&gt;&gt;&gt; &gt;&gt;&gt; greeting1 = (&apos;h&apos;,&apos;e&apos;,&apos;l&apos;)&gt;&gt;&gt; greeting1[0]&apos;h&apos;&gt;&gt;&gt; greeting1[1]&apos;e&apos;&gt;&gt;&gt; 字符串可以理解为由一个个的字符拼成的列表 分片我们不但可以用一个索引来获取某一个元素，也可以获取某个范围的元素。123&gt;&gt;&gt; numbers = [1,2,3,4,5,6,7,8,9,0]&gt;&gt;&gt; numbers[0:2][1, 2] 我们可以看到，左边的边界包含在其中，而右边的边界是不包含在其中的123456789&gt;&gt;&gt; numbers[-1:2][]&gt;&gt;&gt; numbers[-1:-3][]&gt;&gt;&gt; numbers[-3:-1][8, 9]&gt;&gt;&gt; &gt;&gt;&gt; numbers[-3:][8, 9, 0] 我们还可以用倒序来取元素，但是切记一定要左边小，右边的大，只标记一个就会从这个开始取所有，或者到这个为止 还可以给一个步长12&gt;&gt;&gt; numbers[::3][1, 4, 7, 0] 相加1234567891011121314&gt;&gt;&gt; item1 = [1,2,3]&gt;&gt;&gt; item2 = [4,5,6]&gt;&gt;&gt; item1 + item2[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; string1 = &apos;hansheng&apos;&gt;&gt;&gt; string2 = &apos;hui&apos;&gt;&gt;&gt; string1 + string2&apos;hanshenghui&apos;&gt;&gt;&gt; string1 + item1Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: cannot concatenate &apos;str&apos; and &apos;list&apos; objects 但是只有同种类型才能相加 乘法1234&gt;&gt;&gt; &apos;python&apos; * 5&apos;pythonpythonpythonpythonpython&apos;&gt;&gt;&gt; [10,11] * 3[10, 11, 10, 11, 10, 11] 成员资格123456&gt;&gt;&gt; han = &apos;hanshenghui&apos;&gt;&gt;&gt; &apos;shenghui&apos; in hanTrue&gt;&gt;&gt; &apos;wahha&apos; in hanFalse&gt;&gt;&gt; 长度，最大值，最小值12345678910111213141516han = &apos;hanshenghui&apos;item1 = [1,2,3]&gt;&gt;&gt; len(han)11&gt;&gt;&gt; max(han)&apos;u&apos;&gt;&gt;&gt; min(han)&apos;a&apos;&gt;&gt;&gt; len(item1)3&gt;&gt;&gt; max(item1)3&gt;&gt;&gt; min(item1)1&gt;&gt;&gt; 列表操作list与join123456789&gt;&gt;&gt; name = list(&apos;hanshenghui&apos;)&gt;&gt;&gt; name[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;]&gt;&gt;&gt; len(name)11&gt;&gt;&gt; &apos;&apos;.join(name)&apos;hanshenghui&apos;&gt;&gt;&gt; &apos;a&apos;.join(name)&apos;haaanasahaeanagahauai&apos; 赋值更改某个元素的值123&gt;&gt;&gt; name[0] = &apos;i&apos;&gt;&gt;&gt; name[&apos;i&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;] 删除del12345678&gt;&gt;&gt; name = &apos;han&apos;&gt;&gt;&gt; name&apos;han&apos;&gt;&gt;&gt; name = list(name)&gt;&gt;&gt; del name[0]&gt;&gt;&gt; name[&apos;a&apos;, &apos;n&apos;]&gt;&gt;&gt; 分片赋值这是异常强大的一个特性，可以用来插入元素，更改元素，甚至删除元素1234567891011&gt;&gt;&gt; name = list(&apos;han&apos;)&gt;&gt;&gt; name[1:] = list(&apos;python&apos;)&gt;&gt;&gt; name[&apos;h&apos;, &apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]&gt;&gt;&gt; name[2:]=[]&gt;&gt;&gt; name[&apos;h&apos;, &apos;p&apos;]&gt;&gt;&gt; name[1:1] = list(&apos;wahha&apos;)&gt;&gt;&gt; name[&apos;h&apos;, &apos;w&apos;, &apos;a&apos;, &apos;h&apos;, &apos;h&apos;, &apos;a&apos;, &apos;p&apos;]&gt;&gt;&gt; append追加123456789&gt;&gt;&gt; name = list(&apos;han&apos;)&gt;&gt;&gt; name[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;]&gt;&gt;&gt; name.append(&apos;shenghui&apos;)&gt;&gt;&gt; name[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;shenghui&apos;]&gt;&gt;&gt; &apos;&apos;.join(name)&apos;hanshenghui&apos;&gt;&gt;&gt; count统计出现的次数123456&gt;&gt;&gt; name = &apos;hanshenghui&apos;&gt;&gt;&gt; name.count(&apos;h&apos;)3&gt;&gt;&gt; name.count(&apos;n&apos;)2&gt;&gt;&gt; extend一个列表后追加一个新的列表，同加法作用一致123456789&gt;&gt;&gt; name[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;]&gt;&gt;&gt; name1 = list(&apos;sheng&apos;)&gt;&gt;&gt; name1[&apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]&gt;&gt;&gt; name.extend(name1)&gt;&gt;&gt; name[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]&gt;&gt;&gt; index找出列表中某个项的第一个匹配索引12345&gt;&gt;&gt; name[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]&gt;&gt;&gt; name.index(&apos;h&apos;)0&gt;&gt;&gt; insert123456&gt;&gt;&gt; name[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]&gt;&gt;&gt; name.insert(0,&apos;wahha&apos;)&gt;&gt;&gt; name[&apos;wahha&apos;, &apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]&gt;&gt;&gt; pop移除某个值并且将该值返回，需要提供索引123456789&gt;&gt;&gt; name[&apos;wahha&apos;, &apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]&gt;&gt;&gt; name.pop()&apos;g&apos;&gt;&gt;&gt; name.pop()&apos;n&apos;&gt;&gt;&gt; name.pop(0)&apos;wahha&apos;&gt;&gt;&gt; remove移除某个匹配项123456789&gt;&gt;&gt; name[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;]&gt;&gt;&gt; name.remove(&apos;s&apos;)&gt;&gt;&gt; name[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;h&apos;, &apos;e&apos;]&gt;&gt;&gt; name.remove(&apos;s&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list 如果该值不存在，那么就会报错 reverse12345&gt;&gt;&gt; name[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;h&apos;, &apos;e&apos;]&gt;&gt;&gt; name.reverse()&gt;&gt;&gt; name[&apos;e&apos;, &apos;h&apos;, &apos;n&apos;, &apos;a&apos;, &apos;h&apos;] sort改变原来的列表，返回一个空值123456&gt;&gt;&gt; name[&apos;e&apos;, &apos;h&apos;, &apos;n&apos;, &apos;a&apos;, &apos;h&apos;]&gt;&gt;&gt; name.sort()&gt;&gt;&gt; name[&apos;a&apos;, &apos;e&apos;, &apos;h&apos;, &apos;h&apos;, &apos;n&apos;]&gt;&gt;&gt; 需要返回值，sorted12345&gt;&gt;&gt; name = list(&apos;hna&apos;)&gt;&gt;&gt; name1 = sorted(name)&gt;&gt;&gt; name1[&apos;a&apos;, &apos;h&apos;, &apos;n&apos;]&gt;&gt;&gt; 高级排序12345678&gt;&gt;&gt; name = list(&apos;hanshenghui&apos;)&gt;&gt;&gt; name.sort(reverse = True)&gt;&gt;&gt; name[&apos;u&apos;, &apos;s&apos;, &apos;n&apos;, &apos;n&apos;, &apos;i&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;g&apos;, &apos;e&apos;, &apos;a&apos;]&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; returnList.sort(key=lambda k: (k.get(&apos;date&apos;, 0)), reverse=False) 字符串字符串格式化1234&gt;&gt;&gt; python = &apos;%s is a %s&apos; &gt;&gt;&gt; value = (&apos;xiaohong&apos;,&apos;dog&apos;)&gt;&gt;&gt; print python % valuexiaohong is a dog 符号说明:s代表字符串，后边的对象将以str转译，%代表占位，只有元组才会被分开解释，如果是一个列表，那么只能被解释为一个对象，这点要特别注意。d代表整型，f代表浮点数 123&gt;&gt;&gt; python = &apos;%10.1fha&apos;&gt;&gt;&gt; print python % 10 10.0ha f前边的小数点后的数字代表，小数点的保留位数，而前边的10代表字段宽。 1234567891011&gt;&gt;&gt; python = &apos;%010.1fha&apos;&gt;&gt;&gt; print python % 1000000010.0ha&gt;&gt;&gt; python = &apos;%+10.1fha&apos;&gt;&gt;&gt; print python % 10 +10.0ha&gt;&gt;&gt; print python % 1010.0 ha&gt;&gt;&gt; 在字段宽和精度前边还可以放置一个标志，这个标志可以是零，加号和减号或者空格，用法见上 字符串方法1、findfind方法可以在一个较长的字符串中查找子字符串。它返回子串所在位置的最左端索引。如果没有找到则返回-1。1234567891011&gt;&gt;&gt; name = &apos;hanshenghui&apos;&gt;&gt;&gt; name.find(&apos;h&apos;)0&gt;&gt;&gt; name.find(&apos;h&apos;,2)4&gt;&gt;&gt; name.find(&apos;h&apos;,2,6)4&gt;&gt;&gt; name.find(&apos;h&apos;,2,5)4&gt;&gt;&gt; name.find(&apos;h&apos;,2,3)-1 2、join &amp;&amp; splitjoin方法是非常重要的字符串方法，它是split方法的逆方法，用来在队列中添加元素：123&gt;&gt;&gt; s = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]&gt;&gt;&gt; &apos;+&apos;.join(s)&apos;1+2+3&apos; 注意：需要添加的队列元素都必须是字符串。 split这是个非常重要的字符串方法，它是join的逆方法，用来将字符串分割成序列。1234&gt;&gt;&gt; &apos;1+2+3+4&apos;.split(&apos;+&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]&gt;&gt;&gt; &apos;1 2 3 4&apos;.split()[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;] 3.lower &amp;&amp; upperlower方法返回字符串的小写字母版。1234567891011&gt;&gt;&gt; name = &apos;A&apos;&gt;&gt;&gt; name.lower()&apos;a&apos;&gt;&gt;&gt; b = name.lower()&gt;&gt;&gt; b.upper()&apos;A&apos;S.lower() #小写 S.upper() #大写 S.swapcase() #大小写互换 S.capitalize() #首字母大写 4.stripstrip方法返回去除两侧（不包含内部）空格的字符串去两边空格：str.strip()去左空格：str.lstrip()去右空格：str.rstrip()去两边字符串：str.strip(‘d’)，相应的也有lstrip，rstrip 5.replace &amp;&amp; translatetranslate方法和replace方法一样，可以替换字符串中的某些部分，但是和前者不同的是，translate方法只处理单个字符。它的优势在于可以同时进行多个替换，有些时候比replace效率高得多。 123&gt;&gt;&gt; name = &apos;hanshenghui&apos;&gt;&gt;&gt; name.replace(&apos;h&apos;,&apos;z&apos;)&apos;zanszengzui&apos; 在使用translate转换前，需要先完成一张转换表。转换表中是以某字符替换某字符的对应关系。因为这个表（事实上是字符串）有多达256个项目，我们还是不要自己写了，用string模块里面的maketrans函数就行了。 maketrans函数接收两个参数：两个等长的字符串，表示第一个字符串中的每个字符都用第二个字符串中相同位置的字符替换。12345678910&gt;&gt;&gt; from string import maketrans&gt;&gt;&gt; table = maketrans(&apos;cs&apos;, &apos;kz&apos;) 创建这个表后，可以将它用作translate方法的参数，进行字符串的转换：&gt;&gt;&gt; &apos;this is an incredible test&apos;.translate(table)&apos;thiz iz an inkredible tezt&apos;translate的第二个参数是可选的，这个参数是用来指定需要删除的字符。&gt;&gt;&gt; &apos;this is an incredible test&apos;.translate(table, &apos; &apos;)&apos;thizizaninkredibletezt&apos; 6.字符串判断相关字符串判断相关是否以start开头：str.startswith(‘start’)是否以end结尾：str.endswith(‘end’)是否全为字母或数字：str.isalnum()是否全字母：str.isalpha()是否全数字：str.isdigit()是否全小写：str.islower()是否全大写：str.isupper() 7.字符串比较cmp方法比较两个对象，并根据结果返回一个整数。cmp(x,y)如果X&lt; Y,返回值是负数 如果X&gt;Y 返回的值为正数。sStr1 = ‘strch’sStr2 = ‘strchr’print cmp(sStr1,sStr2)##-1 列表，元组，字符串的转换list与tuple意义在于元组可以作为一个参数整体使用，而列表不可以1234567&gt;&gt;&gt; name = &apos;hanshenghui&apos;&gt;&gt;&gt; tuple(name)(&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;)&gt;&gt;&gt; list(name)[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;]&gt;&gt;&gt; tuple(list(name))(&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)delegate/KVO/Notification选择]]></title>
    <url>%2F2016%2F03%2F18%2F2016%2F%E8%BD%AC-delegate-KVO-Notification%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[前面分别讲了delegate、notification和KVO的实现原理，以及实际使用步骤，我们心中不禁有个疑问，他们的功能比较类似，那么在实际的编程中，如何选择这些方式呢？在网上看到一个博客上详细的分析了三者之间的区别以及各自的优势，博文地址为http://blog.shinetech.com/2011/06/14/delegation-notification-and-observation/，因为博文是用英文写的，下面将其翻译成中文。 在开发ios应用的时候，我们会经常遇到一个常见的问题：在不过分耦合的前提下，controllers间怎么进行通信。在IOS应用不断的出现三种模式来实现这种通信： 1.委托delegation； 2.通知中心Notification Center； 3.键值观察key value observing，KVO 因此，那为什么我们需要这些模式以及什么时候用它以及什么时候不用它。 下面完全根据我的开发经验来讨论这三中模式。我将讨论为什么我觉得某种模式要好于另外一种模式以及为什么我觉得在一定的环境下某中模式比较好。我给出的这些原因并不是圣经，而仅仅是个人观点。如果你有什么不同的观点或者还可以进行补充的地方，可以联系我，一起讨论。 上面的三种模式是什么？ 三种模式都是一个对象传递事件给另外一个对象，并且不要他们有耦合。三种模式都是对象来通知某个事件发生了的方法，或者更准确的说，是允许其他的对象收到这种事件的方法。这对于一个对象来说，是非常普通而且必须做的任务，因为没有通信，controllers将不能整合到整个应用中。controller的另外一个目的是尽可能的自包含。我们希望controllers以自己的方式存在，在controllers层面上不能与其他的controllers进行耦合。Controllers能够穿件其他的controllers而且他们之间可以自由通信，但是我们不希望controller又回接到创建自己的controller。如果我们耦合了他们，那么我们将不能复用他们，以及完全失去对应用中一个独立的组件的控制。 这三种模式给controllers(也可以是其他的对象）提供通信的方法。下面将描述如何在ios应用中使用这些模式，同样需要注意的他们在其他的地方也会用到，并且确实是存在。 delegation当我们第一次编写ios应用时，我们注意到不断的在使用“delegate”，并且贯穿于整个SDK。delegation模式不是IOS特有的模式，而是依赖与你过去拥有的编程背景。针对它的优势以及为什么经常使用到，这种模式可能不是很明显的。 delegation的基本特征是，一个controller定义了一个协议（即一系列的方法定义）。该协议描述了一个delegate对象为了能够响应一个controller的事件而必须做的事情。协议就是delegator说，“如果你想作为我的delegate，那么你就必须实现这些方法”。实现这些方法就是允许controller在它的delegate能够调用这些方法，而它的delegate知道什么时候调用哪种方法。delegate可以是任何一种对象类型，因此controller不会与某种对象进行耦合，但是当该对象尝试告诉委托事情时，该对象能确定delegate将响应。 delegate的优势： 1.非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义。 2.如果delegate中的一个方法没有实现那么就会出现编译警告/错误 3.协议必须在controller的作用域范围内定义 4.在一个应用中的控制流程是可跟踪的并且是可识别的； 5.在一个控制器中可以定义定义多个不同的协议，每个协议有不同的delegates 6.没有第三方对象要求保持/监视通信过程。 7.能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller 缺点： 1.需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义 2.在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash 3.在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。 notification在IOS应用开发中有一个”Notification Center“的概念。它是一个单例对象，允许当事件发生时通知一些对象。它允许我们在低程度耦合的情况下，满足控制器与一个任意的对象进行通信的目的。这种模式的基本特征是为了让其他的对象能够接收到在该controller中发生某种事件而产生的消息，controller用一个key（通知名称）。这样对于controller来说是匿名的，其他的使用同样的key来注册了该通知的对象（即观察者）能够对通知的事件作出反应。 优势： 1.不需要编写多少代码，实现比较简单； 2.对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单 3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息 缺点： 1.在编译期不会检查通知是否能够被观察者正确的处理； 2.在释放注册的对象时，需要在通知中心取消注册； 3.在调试的时候应用的工作以及控制过程难跟踪； 4.需要第三方对喜爱那个来管理controller与观察者对象之间的联系； 5.controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况； 6.通知发出后，controller不能从观察者获得任何的反馈信息。 KVOKVO是一个对象能够观察另外一个对象的属性的值，并且能够发现值的变化。前面两种模式更加适合一个controller与任何其他的对象进行通信，而KVO更加适合任何类型的对象侦听另外一个任意对象的改变（这里也可以是controller，但一般不是controller）。这是一个对象与另外一个对象保持同步的一种方法，即当另外一种对象的状态发生改变时，观察对象马上作出反应。它只能用来对属性作出反应，而不会用来对方法或者动作作出反应。 优点： 1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步； 2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现； 3.能够提供观察的属性的最新值以及先前值； 4.用key paths来观察属性，因此也可以观察嵌套对象； 5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察 缺点： 1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查； 2.对属性重构将导致我们的观察代码不再可用； 3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向； 4.当释放观察者时不需要移除观察者。 总结：从上面的分析中可以看出3中设计模式都有各自的优点和缺点。其实任何一种事物都是这样，问题是如何在正确的时间正确的环境下选择正确的事物。下面就讲讲如何发挥他们各自的优势，在哪种情况下使用哪种模式。注意使用任何一种模式都没有对和错，只有更适合或者不适合。每一种模式都给对象提供一种方法来通知一个事件给其他对象，而且前者不需要知道侦听者。在这三种模式中，我认为KVO有最清晰的使用案例，而且针对某个需求有清晰的实用性。而另外两种模式有比较相似的用处，并且经常用来给controller间进行通信。那么我们在什么情况使用其中之一呢？ 根据我开发iOS应用的经历，我发现有些过分的使用通知模式。我个人不是很喜欢使用通知中心。我发现用通知中心很难把握应用的执行流程。UserInfo dictionaries的keys到处传递导致失去了同步，而且在公共空间需要定义太多的常量。对于一个工作于现有的项目的开发者来说，如果过分的使用通知中心，那么很难理解应用的流程。 我觉得使用命名规则好的协议和协议方法定义对于清晰的理解controllers间的通信是很容易的。努力的定义这些协议方法将增强代码的可读性，以及更好的跟踪你的app。代理协议发生改变以及实现都可通过编译器检查出来，如果没有将会在开发的过程中至少会出现crash，而不仅仅是让一些事情异常工作。甚至在同一事件通知多控制器的场景中，只要你的应用在controller层次有着良好的结构，消息将在该层次上传递。该层次能够向后传递直至让所有需要知道事件的controllers都知道。 当然会有delegation模式不适合的例外情况出现，而且notification可能更加有效。例如：应用中所有的controller需要知道一个事件。然而这些类型的场景很少出现。另外一个例子是当你建立了一个架构而且需要通知该事件给正在运行中应用。 根据经验，如果是属性层的事件，不管是在不需要编程的对象还是在紧紧绑定一个view对象的model对象，我只使用观察。对于其他的事件，我都会使用delegate模式。如果因为某种原因我不能使用delegate，首先我将估计我的app架构是否出现了严重的错误。如果没有错误，然后才使用notification。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS技能总结]]></title>
    <url>%2F2016%2F02%2F19%2F2016%2FiOS%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[参考–唐巧，iOS技能图谱 编程语言 Swift Objective-C C++/C JavaScript Python 操作系统 Mac OSX iOS watchOS tvOS Linux 常用命令 开发基础 UI 控件 Storyboard &amp; Xib Core Data &amp; Sqlite数据持久化CoreData的多线程 了解没? CoreData 的不同版本的数据迁移怎么做? Core Graphics Animation Block &amp; GCD，GCD ,NSThread ,NSOperation 能不能滔滔不绝的讲出来 Test Case 编写 Framework Autolayout WebController 手势识别，重力感应 推送 网络加密 keyChain 钥匙串存储 开发进阶 内存管理 Runtime，在项目中的应用 Runloop，在项目中的应用 对象模型 Hybrid 沙盒机制 AVFoundation Core Text app瘦身 插件制作 打包.a和framwork 优化 电量 流量 性能 网络 逆向与安全 class dump IDA Pro Hopper iOS Class Guard 设计模式 MVC MVVM 通知 代理 KVO 工厂模式 命令模式 开发工具 IDE Xcode AppCode 调试工具 Charles、Wireshark Reveal Instruments 插件 Alcatraz VVDocument XVim FuzzyAutocompletePlugin KSImageNamed-Xcode 辅助工具 xScope ImageOptim 马克鳗 Dash Deploymate FauxPas PaintCode 命令行工具 xcodebuild、xcode-select nomad xctool fastlane 持续集成 Jenkins Travis CI Bot 开源项目 AFNetworking &amp; Alamofire Masonry SDWebImage SwiftyJSON JSPatch React Native App 打包上传与审核 Apple Developer 网站 iTunes Connect 网站 IAP 加急审核申请 打包脚本 第三方服务 崩溃收集 Bugly Crashlytics BugHD Fabric 数据统计 Google Analytics 友盟 MTA Flurry App Annie 应用分发 TestFlight 蒲公英 FIR 包管理 CocoaPods Carthage Swift Package Manager 函数式编程 ReactiveCocoa RxSwift]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)项目优化--安装包体积控制]]></title>
    <url>%2F2016%2F01%2F18%2F2016%2F%E8%BD%AC-%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96-%E5%AE%89%E8%A3%85%E5%8C%85%E4%BD%93%E7%A7%AF%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[iOS微信安装包瘦身 前提 微信经过多次版本迭代，产生不少冗余代码和无用资源。之前微信也没有很好的手段知道哪个模块增量多少。另外去年10月微信开始做ARC支持，目的是为了减少野指针带来的Crash，但代价是可执行文件增大20%左右。而苹果规定今年6月提交给Appstore的应用必须支持64位，32位和64位两个架构的存在使得可执行文件增加了一倍多。安装包大小优化迫在眉睫。 Appstore安装包是由资源和可执行文件两部分组成，安装包瘦身也是从这两部分进行。 资源瘦身资源瘦身主要是去掉无用资源和压缩资源，资源包括图片、音视频文件、配置文件以及多语言wording。无用资源是指资源在工程文件里，但没有被代码引用。检查方法是，用资源关键字（通常是文件名，图片资源需要去掉@2x @3x），搜索代码，搜不到就是没有被引用。当然，有些资源在使用过程中是拼接而成的（如loading_xxx.png），需要手工过滤。 资源压缩主要对png进行无损压缩，用的是ImageOptim工具和compress命令（需要安装XQuartz-2.7.5.dm插件）。不建议对资源做有损压缩，有损压缩需要设计一个个检查，通常压缩后效果不尽人意。 Xcode’s Link Map File在讲可执行文件瘦身之前先介绍Xcode的LinkMap文件。LinkMap文件是Xcode产生可执行文件的同时生成的链接信息，用来描述可执行文件的构造成分，包括代码段（TEXT）和数据段（DATA）的分布情况。只要设置Project-&gt;Build Settings-&gt;Write Link Map File为YES，并设置Path to Link Map File，build完后就可以在设置的路径看到LinkMap文件了： 每个LinkMap由3个部分组成，以微信为例： Object files: [ 0] linker synthesized [ 1] /xxxx/WCPayInfoItem.o [ 2] /xxxx/GameCenterFriendRankCell.o [ 3] /xxxx/WloginTlv_0x168.o … 第一部分列举可执行文件里所有.obj文件，以及每个文件的编号。 Sections: 第二部分是可执行文件的段表，描述各个段在可执行文件中的偏移位置和大小。第一列是段的偏移量，第二列是段占用大小，Address(n)=Address(n-1)+Size(n-1)；第三列是段类型，代码段和数据段；第四列是段名字，如text是可执行机器码，cstring是字符串常量。有关段的概念可参考苹果官方文档《OS X ABI Mach-O File Format Reference》 Symbols: Address Size File Name0x100005A50 0x00000074 [ 1] +[WCPayInfoItem initialize] … 0x10231C120 0x00000018 [ 1] literal string: I16@?0@”WCPayInfoItem”8 … 0x10252A41A 0x0000000E [ 1] literal string: WCPayInfoItem … 第三部分详细描述每个obj文件在每个段的分布情况，按第二部分Sections顺序展示。例如序号1的WCPayInfoItem.o文件，+[WCPayInfoItem initialize]方法在TEXT.text地址是0x100005A50，占用大小是116字节。根据序号累加每个obj文件在每个段的占用大小，从而计算出每个obj文件在可执行文件的占用大小，进而算出每个静态库、每个功能模块代码占用大小。这里要注意的地方是，由于DATA.bbs是代表未初始化的静态变量，Size表示应用运行时占用的堆大小，并不占用可执行文件，所以计算obj占用大小时，要排除这个段的Size。 可执行文件瘦身回到我们的可执行文件瘦身问题，LinkMap文件可以帮助我们寻找优化点。 1. 查找无用selector以往C++在链接时，没有被用到的类和方法是不会编进可执行文件里。但Objctive-C不同，由于它的动态性，它可以通过类名和方法名获取这个类和方法进行调用，所以编译器会把项目里所有OC源文件编进可执行文件里，哪怕该类和方法没有被使用到。 结合LinkMap文件的TEXT.text，通过正则表达式([+|-][.+\s(.+)])，我们可以提取当前可执行文件里所有objc类方法和实例方法（SelectorsAll）。再使用otool命令otool -v -s DATA objc_selrefs逆向DATA.objc_selrefs段，提取可执行文件里引用到的方法名（UsedSelectorsAll），我们可以大致分析出SelectorsAll里哪些方法是没有被引用的（SelectorsAll-UsedSelectorsAll）。注意，系统API的Protocol可能被列入无用方法名单里，如UITableViewDelegate的方法，我们只需要对这些Protocol里的方法加入白名单过滤即可。 另外第三方库的无用selector也可以这样扫出来的。 2. 查找无用oc类查找无用oc类有两种方式，一种是类似于查找无用资源，通过搜索”[ClassName alloc/new”、”ClassName *”、”[ClassName class]”等关键字在代码里是否出现。另一种是通过otool命令逆向DATA.objc_classlist段和DATA.objc_classrefs段来获取当前所有oc类和被引用的oc类，两个集合相减就是无用oc类。 3. 扫描重复代码可以利用第三方工具simian扫描。南非支付copy代码就是这样被发现的。但除此成果之外，扫描出来的结果过多，重构起来也不方便，不如砍功能需求效果好。 4. protobuf精简改造protobuf是Google推出的一种轻量高效的结构化数据存储格式，在微信用于网络协议和本地文件序列化。但google默认工具生成的代码比较冗余，像序列化、反序列化、计算序列化大小等方法都生成在具体的pb类里，每个类的实现大同小异。通过代码分析以及结合protobuf原理，要想把这些方法抽象到基类，派生类提供每个字段相关信息就够了： field number field label, optional, required or repeated wire type, double, float, int, etc 是否packed repeated的数据类型 123456789101112typedef struct &#123; Byte _fieldNumber; Byte _fieldLabel; Byte _fieldType; BOOL _isPacked; int _enumInitValue; union &#123; __unsafe_unretained NSString* _messageClassName; __unsafe_unretained Class _messageClass; // ClassName对应的Class IsEnumValidFunc _isEnumValidFunc; // 检测枚举值是否合法函数指针 &#125;;&#125; PBFieldInfo; 另外通过无用selector列表，发现不少pb类属性的getter或setter没有被使用。原先的pb类属性是用@synthesize修饰，编译器会自动生成getter和setter。如果不想编译器生成，则要用@dynamic。甚至我们可以把pb类的成员变量去掉。做法如下： 基类增加id类型数组ivarValues（参考了objc_class结构体ivars做法），用于存放对象的属性值。对象属性值统一用oc对象表示，如果类型是基础类型（primitive，如int、float等），则用NSValue存 重载methodSignatureForSelector:方法，返回属性getter、setter的方法签名 重载forwardInvocation:方法，分析invocation.selector类型。如果是getter，从ivarValues获取属性值并设置为invocation的returnValue；如果是setter，从invocation第二个argument获取属性值，并存放到ivarValues里 重载setValue:forUndefinedKey:、valueForUndefinedKey:，防止通过KVO访问属性Crash 做下性能优化，如pb类在initialize做一次初始化，缓存属性名的hash值，属性的getter、setter方法的objcType等；属性值不用std::map（属性名-&gt;属性值），而是改用数组；MRC代替ARC（有些时候ARC自动添加的retain/release挺影响性能的）；等等 1234567891011121314151617181920212223class PBClassInfo &#123;public: PBClassInfo(Class cls, PBFieldInfo* fieldInfo); ~PBClassInfo();public: unsigned int _numberOfProperty; std::string* _propertyNames; size_t* _propertyNameHashes; std::string* _getterObjCTypes; std::string* _setterObjCTypes; PBFieldInfo* _fieldInfos;&#125;;@interface WXPBGeneratedMessage () &#123; uint32_t _has_bits_[3]; // 最多96个属性，表示属性是否有赋值 int32_t _serializedSize; PBClassInfo* _classInfo; id* _ivarValues;&#125;- (NSMethodSignature*) methodSignatureForSelector:(SEL) aSelector;- (void) forwardInvocation:(NSInvocation*) anInvocation;- (void) setValue:(id) value forUndefinedKey:(NSString*) key;- valueForUndefinedKey:(NSString*) key;@end 把冗余代码去掉后，整个类清爽多了。像GameResourceReq只有3个属性的proto结构体，类方法代码行数由以前的127行变成现在的8行。protobuf精简改造中，精简类方法减少了可执行文件8.8M，去掉类成员变量和类属性改用@dynamic减少了2.5M。 1234567891011121314151617181920212223242526272829303132333435363738394041message GameResourceReq &#123; required BaseRequest BaseRequest = 1; required int32 PropsCount = 2; repeated uint32 PropsIdList = 3[packed=true];&#125;// 老实现@implementation GameResourceReq@synthesize hasBaseRequest;@synthesize baseRequest;@synthesize hasPropsCount;@synthesize propsCount;@synthesize mutablePropsIdListList;@dynamic propsIdList;- (id) init &#123;...&#125;- (void) SetBaseRequest:(BaseRequest*) value &#123;...&#125;- (void) SetPropsCount:(int32_t) value &#123;...&#125;- (NSArray*) propsIdListList &#123;...&#125;- (NSMutableArray*)propsIdList &#123;...&#125;- (void)setPropsIdList:(NSMutableArray*) values &#123;...&#125;- (BOOL) isInitialized &#123;...&#125;- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output &#123;...&#125;- (int32_t) serializedSize &#123;...&#125;+ (GameResourceReq*) parseFromData:(NSData*) data &#123;...&#125;- (GameResourceReq*) mergeFromCodedInputStream:(PBCodedInputStream*) input &#123;...&#125;- (void) addPropsIdList:(uint32_t) value &#123;...&#125;- (void) addPropsIdListFromArray:(NSArray*) values &#123;...&#125;@end// 新实现@implementation GameResourceReqPB_PROPERTY_TYPE baseRequest;PB_PROPERTY_TYPE opType;PB_PROPERTY_TYPE brandUserName;+ (void) initialize &#123; static PBFieldInfo _fieldInfoArray[] = &#123; &#123;1, FieldLabelRequired, FieldTypeMessage, NO, 0, ._messageClassName = STRING_FROM(BaseRequest)&#125;, &#123;2, FieldLabelRequired, FieldTypeInt32, NO, 0, 0&#125;, &#123;3, FieldLabelRepeated, FieldTypeUint32, NO, 0, 0&#125;, &#125;; initializePBClassInfo(self, _fieldInfoArray);&#125;@end 编译选项优化 Strip Link Product设成YES，WeChatWatch可执行文件减少0.3M Make Strings Read-Only设为YES，也许是因为微信工程从低版本Xcode升级过来，这个编译选项之前一直为NO，设为YES后可执行文件减少了3M 去掉异常支持，Enable C++ Exceptions和Enable Objective-C Exceptions设为NO，并且Other C Flags添加-fno-exceptions，可执行文件减少了27M，其中gcc_except_tab段减少了17.3M，text减少了9.7M，效果特别明显。可以对某些文件单独支持异常，编译选项加上-fexceptions即可。但有个问题，假如ABC三个文件，AC文件支持了异常，B不支持，如果C抛了异常，在模拟器下A还是能捕获异常不至于Crash，但真机下捕获不了（有知道原因可以在下面留言：）。去掉异常后，Appstore后续几个版本Crash率没有明显上升。个人认为关键路径支持异常处理就好，像启动时NSCoder读取setting配置文件得要支持捕获异常，等等 其他可探索途径 iOS8 Embed-Framework：提取WeChatWatch、ShareExtention和微信主工程的公共代码，可执行文件可以减少5M+，不过这特性需要最低版本iOS8才能用，iOS7设备启动会crash iOS9 App Thinning：严格来说App Thinning不会让安装包变小，但用户安装应用时，苹果会根据用户的机型自动选择合适的资源和对应CPU架构的二进制执行文件（也就是说用户本地可执行文件不会同时存在armv7和arm64），安装后空间占用更小 建立监控 通过对LinkMap文件的分析，可以得知每个模块可执行文件占用大小。再对比两个版本，就知道业务模块的增量大小。参考如下：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热修复技术在移动端的应用]]></title>
    <url>%2F2016%2F01%2F12%2F2016%2F%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[热修复技术概述移动应用的部署方式，即发布-&gt;下载-&gt;安装-&gt;运行，决定了他不具备Web的高灵活性，尤其新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。热修复技术(HotfixPatch)，是一种基于原生应用开发的灵活性解决方案，可以在不改变开发人员技能要求和已有的开发方式的前提下，给于应用在发布后改变程序行为的能力。热补丁的主要优势是不会使设备当前正在运行的业务中断，即在不重启设备的情况下可以对设备当前软件版本的缺陷进行修复。一般用于某个函数导致的bug，如果是某个类导致的bug，或者增减业务模块，不建议使用热修复，而使用Reactive Native。 市场中的热修复技术方案对比 WaxPatch(阿里在维护) JSPatch(个人项目) 两者相比，JSPatch的优势： 1.JS语言: JS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。 2.符合Apple规则: JSPatch更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。 3.小巧: 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。 4.支持block: wax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。 JSPatch的劣势： 相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。 问题与风险JSPatch让脚本语言获得调用所有原生OC方法的能力，不像web前端把能力局限在浏览器，使用上会有一些安全风险：1.若在网络传输过程中下发明文JS，可能会被中间人篡改JS脚本，执行任意方法，盗取APP里的相关信息。可以对传输过程进行加密，或用直接使用https解决。2.若下载完后的JS保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在APP内相关信息被盗用的风险。若要避免用户修改代码影响APP运行，可以选择简单的加密存储。3.由于主要的应用方式是对函数的替换，所以如果某个函数包含几千行的代码，修复的时候工作量会相对较大 JSPatch简介 作者bang(腾讯)个人博客，github 项目创建于2015-5 JSPatch接入平台 淘宝，美团等都有使用，SDK后台接入统计数据超过1200个应用 JSPatch交流群(207283178) 需要的基础知识-JavaScriptCore的使用-runtime JSPatch原理 运行时修复不用等待App重新启动，iOS 利用运行时特性修改函数的IMP，从而达到修复目的。 所谓的脚本执行其实只是增加了内存中的类以及新增的IMP，以及对OC中的IMP的组合。 jspatch脚本只是一套规则，jspatch内部对其进行了字符串截取的转换，为类名，方法名，以及参数，然后利用运行时的方法进行调用。 evaluateScript方法只是让脚本去调用js方法域中的方法，然后iOS会去调用对应IMP，所以JSPatch文件的作用是增加js方法域中的方法。 能做到通过JS调用和改写OC方法最根本的原因是 Objective-C 是动态语言，OC上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法，具体来说能做的有： 通过类名和方法名得到具体的类以及方法 替换某个类的方法的实现 注册一个新的类并且为该类添加方法实现 JSPatch具体实现 最外层需要的是js的调用能力，所以需要定义js函数，提供脚本调用的接口 又因为我们需要用到运行时的函数，所以需要利用js来调用OC中的方法，所以我们需要生成一系列的IMP require JS接口(.alloc().init())/(NSInvocation)invocation对消息的直接调用 消息传递(JSContext) 对象持有/转换 类型转换 方法替换 新增方法 property 参考:bang-JSPatch原理详解 JSPatch使用流程 开发热修复脚本 压缩为zip(节省空间) 上传脚本到服务器 app每次启动判断本地脚本是否超过一天，如果超过一天向服务器请求新的，否则检查该脚本是否合法如果不合法就删除 获取到脚本文件后，调用JSPatch引擎，执行脚本文件进行修复 补充:终端获取脚本文件是需要一个策略的，最简单的就是，终端根据版本号，获取与该版本号有关的脚本文件：如：本次终端发布的版本是：1.0.3，那在上传脚本文件时，就可以将脚本文件的名称定义为：patch1_0_3.js这样终端就可以根据版本号，动态组织脚本的下载地址，而且一个版本对应一个脚本文件，简单明了～～ JSPatch的引入 引入SDK 原版SDK 酷狗SDK 自定义：源文件+版本管理规则 项目启动函数中添加JSPatch引擎启动命令 脚本分发平台接入 官方平台(http://jspatch.com/Docs/price) 酷狗后台：秘钥生成，url传入 JSPatch中的js语法1.https://github.com/bang590/JSPatch/wiki/JSPatch-基础用法#常量枚举 2.语法转译工具 3.一些踩过的坑123456789tmpLitterImg.length 不能写成 tmpLitterImg.length()infoModel.kugouId() 不能写成 infoModel.kugouIdself.headerView().sd__setImageWithURL//单下划线要用双下划线self.locationIconView().right()//left/right后要加()UIScreen.mainScreen().bounds().width//CGrect这种结构取值不用加()//宏要直接用具体的值//枚举要用具体的数字//int类型转string类型要用下面的方法self.viewerNumLbl().setText(&apos;&apos; + info.viewerNum()); 问题 swift因为没有OC的动态性，所以暂时没有成熟的只是针对swift的热修复技术方案 当发布了新版，原来下发的脚本怎么办？ 根据版本号进行js文件的读取，新版本情况下旧版本文件不会再被执行 关于实时推送的实现？ 现在的技术方案是使用长连接进行推送，单台服务器暂时能够能够支撑200万的链接量 服务器需要做的 上传功能 MD5唯一性验证 CDN缓存，加速(待定) 对文件进行RSA加密同时生成MD5签名 http接口1 参数：appversion 返回 patchId appversion fileHash downloadUrl http接口2返回加密后的文件 - 在最开始增加参数，配置是否在主线程执行，主要解决假如首页崩溃，可以堵塞。 - 唤醒的时候进行下载，24小时执行一次 Demo javascriptCore的使用 JSPatchDemo 在繁星中的使用 启动崩溃两次判断 本地回滚 js文件的版本号，如果这个版本号本地已经有了，那就不再下发了 本地保存的上一次的这个文件是加密呢还是明文呢？ MD5两次加密]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[category内部实现原理]]></title>
    <url>%2F2015%2F12%2F15%2F2015%2Fcategory%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[见过的比较好的一篇讲述category实现的博客，在此做个记录 转载自：http://tech.meituan.com/DiveIntoCategory.html 无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。 简介 本文作者来自美团酒店旅游事业群iOS研发组。我们致力于创造价值、提升效率、追求卓越。欢迎大家加入我们（简历请发送到邮箱majia03@meituan.com）。本文系学习Objective-C的runtime源码时整理所成，主要剖析了category在runtime层的实现原理以及和category相关的方方面面，内容包括： 初入宝地-category简介 连类比事-category和extension 挑灯细览-category真面目 追本溯源-category如何加载 旁枝末叶-category和+load方法 触类旁通-category和方法覆盖 更上一层-category和关联对象 1、初入宝地-category简介category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景1 可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。 声明私有方法 不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景： 模拟多继承 把framework的私有方法公开 Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。 2、连类比事-category和extensionextension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见2） 但是category则完全不一样，它是在运行期决议的。就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。 3、挑灯细览-category真面目我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了1)、类的名字（name）2)、类（cls）3)、category中所有给类添加的实例方法的列表（instanceMethods）4)、category中所有添加的类方法的列表（classMethods）5)、category实现的所有协议的列表（protocols）6)、category中添加的所有属性（instanceProperties） 12345678typedef struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties;&#125; category_t; 从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。ok，我们先去写一个category看一下category到底为何物：123456789101112131415161718192021222324252627282930313233343536373839404142434445MyClass.h：#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject- (void)printName;@end@interface MyClass(MyAddition)@property(nonatomic, copy) NSString *name;- (void)printName;@endMyClass.m：#import &quot;MyClass.h&quot;@implementation MyClass- (void)printName&#123; NSLog(@&quot;%@&quot;,@&quot;MyClass&quot;);&#125;@end@implementation MyClass(MyAddition)- (void)printName&#123; NSLog(@&quot;%@&quot;,@&quot;MyAddition&quot;);&#125;@end 我们使用clang的命令去看看category到底会变成什么： clang -rewrite-objc MyClass.m 好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static struct /*_method_list_t*/ &#123;unsigned int entsize; // sizeof(struct _objc_method)unsigned int method_count;struct _objc_method method_list[1];&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;sizeof(_objc_method),1,&#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_MyClass_MyAddition_printName&#125;&#125;&#125;;static struct /*_prop_list_t*/ &#123;unsigned int entsize; // sizeof(struct _prop_t)unsigned int count_of_properties;struct _prop_t prop_list[1];&#125; _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;sizeof(_prop_t),1,&#123;&#123;&quot;name&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;&#125;&#125;;extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;static struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =&#123;&quot;MyClass&quot;,0, // &amp;OBJC_CLASS_$_MyClass,(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,0,0,(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,&#125;;static void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) &#123;_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;&#125;#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;(void *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,&#125;;static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;&amp;OBJC_CLASS_$_MyClass,&#125;;static struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = &#123;&amp;OBJC_CLASS_$_MyClass,&#125;;static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;&amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,&#125;; 我们可以看到，1)、首先编译器生成了实例方法列表OBJC$CATEGORY_INSTANCE_METHODS_MyClass$MyAddition和属性列表_OBJC$PROP_LIST_MyClass$MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。2)、其次，编译器生成了category本身_OBJC$CATEGORY_MyClass$MyAddition，并用前面生成的列表来初始化category本身。3)、最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABELCATEGORY$（当然，如果有多个category，会生成对应长度的数组^^），用于运行期category的加载。到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。 4、追本溯源-category如何加载 我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。想了解更多dyld地同学可以移步这里（3）。 对于OC运行时，入口方法如下（在objc-os.mm文件中）： 123456789101112131415161718void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); lock_init(); exception_init(); // Register for unmap first, in case some +load unmaps something _dyld_register_func_for_remove_image(&amp;unmap_image); dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch*/, &amp;map_images); dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Discover categories. for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; class_t *cls = remapClass(cat-&gt;cls); if (!cls) &#123; // Category&apos;s target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = NULL; if (PrintConnecting) &#123; _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot; &quot;missing weak-linked target class&quot;, cat-&gt;name, cat); &#125; continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class&apos;s method lists (etc) if // the class is realized. BOOL classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (isRealized(cls)) &#123; remethodizeClass(cls); classExists = YES; &#125; if (PrintConnecting) &#123; _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, getName(cls), cat-&gt;name, classExists ? &quot;on existing class&quot; : &quot;&quot;); &#125; &#125; if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) &#123; addUnattachedCategoryForClass(cat, cls-&gt;isa, hi); if (isRealized(cls-&gt;isa)) &#123; remethodizeClass(cls-&gt;isa); &#125; if (PrintConnecting) &#123; _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, getName(cls), cat-&gt;name); &#125; &#125; &#125; &#125; 首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。略去PrintConnecting这个用于log的东西，这段代码很容易理解：1)、把category的实例方法、协议以及属性添加到类上2)、把category的类方法和协议添加到类的metaclass上 值得注意的是，在代码中有一小段注释 / || cat-&gt;classProperties /，看来苹果有过给类添加属性的计划啊。ok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。 12345678910111213141516171819202122232425262728293031323334353637383940414243static void remethodizeClass(class_t *cls)&#123; category_list *cats; BOOL isMeta; rwlock_assert_writing(&amp;runtimeLock); isMeta = isMetaClass(cls); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls))) &#123; chained_property_list *newproperties; const protocol_list_t **newprotos; if (PrintConnecting) &#123; _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;, getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;); &#125; // Update methods, properties, protocols BOOL vtableAffected = NO; attachCategoryMethods(cls, cats, &amp;vtableAffected); newproperties = buildPropertyList(NULL, cats, isMeta); if (newproperties) &#123; newproperties-&gt;next = cls-&gt;data()-&gt;properties; cls-&gt;data()-&gt;properties = newproperties; &#125; newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols); if (cls-&gt;data()-&gt;protocols &amp;&amp; cls-&gt;data()-&gt;protocols != newprotos) &#123; _free_internal(cls-&gt;data()-&gt;protocols); &#125; cls-&gt;data()-&gt;protocols = newprotos; _free_internal(cats); // Update method caches and vtables flushCaches(cls); if (vtableAffected) flushVtables(cls); &#125;&#125; 而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods： 12345678910111213141516171819202122232425262728static voidattachCategoryMethods(class_t *cls, category_list *cats, BOOL *inoutVtablesAffected)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); BOOL isMeta = isMetaClass(cls); method_list_t **mlists = (method_list_t **) _malloc_internal(cats-&gt;count * sizeof(*mlists)); // Count backwards through cats to get newest categories first int mcount = 0; int i = cats-&gt;count; BOOL fromBundle = NO; while (i--) &#123; method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= cats-&gt;list[i].fromBundle; &#125; &#125; attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected); _free_internal(mlists);&#125; attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段： 123456789101112131415161718192021222324for (uint32_t m = 0; (scanForCustomRR || scanForCustomAWZ) &amp;&amp; m &lt; mlist-&gt;count; m++) &#123; SEL sel = method_list_nth(mlist, m)-&gt;name; if (scanForCustomRR &amp;&amp; isRRSelector(sel)) &#123; cls-&gt;setHasCustomRR(); scanForCustomRR = false; &#125; else if (scanForCustomAWZ &amp;&amp; isAWZSelector(sel)) &#123; cls-&gt;setHasCustomAWZ(); scanForCustomAWZ = false; &#125; &#125; // Fill method list array newLists[newCount++] = mlist; . . . // Copy old methods to the method list array for (i = 0; i &lt; oldCount; i++) &#123; newLists[newCount++] = oldLists[i]; &#125; 需要注意的有两点：1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。 5、旁枝末叶-category和+load方法我们知道，在类和category中都可以有+load方法，那么有两个问题：1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？2)、这么些个+load方法，调用顺序是咋样的呢？鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的： 我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）: 运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：1234567891011121314151617objc[1187]: REPLACED: -[MyClass printName] by category Category1objc[1187]: REPLACED: -[MyClass printName] by category Category2...objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +loadobjc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +loadobjc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +loadobjc[1187]: LOAD: +[MyClass load]...objc[1187]: LOAD: +[MyClass(Category1) load]...objc[1187]: LOAD: +[MyClass(Category2) load] 所以，对于上面两个问题，答案是很明显的：1)、可以调用，因为附加category到类的工作会先于+load方法的执行2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。目前的编译顺序是这样的： 我们调整一个Category1和Category2的编译顺序，run。ok，我们可以看到控制台的输出顺序变了：1234567891011121314151617objc[1187]: REPLACED: -[MyClass printName] by category Category2objc[1187]: REPLACED: -[MyClass printName] by category Category1...objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +loadobjc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +loadobjc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +loadobjc[1187]: LOAD: +[MyClass load]...objc[1187]: LOAD: +[MyClass(Category2) load]...objc[1187]: LOAD: +[MyClass(Category1) load] 虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。 6、触类旁通-category和方法覆盖鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:怎么调用到原来类中被category覆盖掉的方法？对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法： 12345678910111213141516171819202122232425Class currentClass = [MyClass class];MyClass *my = [[MyClass alloc] init];if (currentClass) &#123; unsigned int methodCount; Method *methodList = class_copyMethodList(currentClass, &amp;methodCount); IMP lastImp = NULL; SEL lastSel = NULL; for (NSInteger i = 0; i &lt; methodCount; i++) &#123; Method method = methodList[i]; NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) encoding:NSUTF8StringEncoding]; if ([@&quot;printName&quot; isEqualToString:methodName]) &#123; lastImp = method_getImplementation(method); lastSel = method_getName(method); &#125; &#125; typedef void (*fn)(id,SEL); if (lastImp != NULL) &#123; fn f = (fn)lastImp; f(my,lastSel); &#125; free(methodList);&#125; 7、更上一层-category和关联对象如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。12345678910111213141516171819202122232425262728293031323334353637383940414243MyClass+Category1.h:#import &quot;MyClass.h&quot;@interface MyClass (Category1)@property(nonatomic,copy) NSString *name;@endMyClass+Category1.m:#import &quot;MyClass+Category1.h&quot;#import &lt;objc/runtime.h&gt;@implementation MyClass (Category1)+ (void)load&#123; NSLog(@&quot;%@&quot;,@&quot;load in Category1&quot;);&#125;- (void)setName:(NSString *)name&#123; objc_setAssociatedObject(self, &quot;name&quot;, name, OBJC_ASSOCIATION_COPY);&#125;- (NSString*)name&#123; NSString *nameObject = objc_getAssociatedObject(self, &quot;name&quot;); return nameObject;&#125;@end 但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：123456789101112131415161718192021222324252627282930313233343536373839404142434445void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); _class_setInstancesHaveAssociatedObjects(_object_getClass(object)); &#125; &#125; else &#123; // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下： 12345678910111213class AssociationsManager &#123; static OSSpinLock _lock; static AssociationsHashMap *_map; // associative references: object pointer -&gt; PtrPtrHashMap.public: AssociationsManager() &#123; OSSpinLockLock(&amp;_lock); &#125; ~AssociationsManager() &#123; OSSpinLockUnlock(&amp;_lock); &#125; AssociationsHashMap &amp;associations() &#123; if (_map == NULL) _map = new AssociationsHashMap(); return *_map; &#125;&#125;; AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。而在对象的销毁逻辑里面，见objc-runtime-new.mm: 12345678910111213141516171819void *objc_destructInstance(id obj)&#123; if (obj) &#123; Class isa_gen = _object_getClass(obj); class_t *isa = newcls(isa_gen); // Read all of the flags at once for performance. bool cxx = hasCxxStructors(isa); bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen); // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); if (!UseGC) objc_clear_deallocating(obj); &#125; return obj;&#125; 嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。 后记 正如侯捷先生所讲-“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的(在http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码)。本系列runtime源码学习将会持续更新，意犹未尽的同学可以自行到上述网站下载源码学习。行笔简陋，如有错误，望指正。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS知识地图]]></title>
    <url>%2F2015%2F09%2F25%2F2015%2FiOS%E7%9F%A5%E8%AF%86%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[主要罗列iOS开发中涉及到的基础知识点以及架构和基础的一些方面 基础 需求 质量 效率 01 UI视图(基础) 事件传递机制 UI绘制原理 UI绘制原理2 异步绘制原理 流式页面的性能优化 离屏渲染 UIImageView的完成绘制过程 UILabel完整绘制过程 事件传递1.如何更改响应对象 2.最重要的两个函数 3.传递链和响应链 4.一个事件多次响应 UI绘制原理 卡顿的本质 绘制的时候cpu和gpu怎么分工 绘制优化点 02 OC语言(基础) KVO，observer KVC，set value for key kvc vs kvo 分类 分类与拓展区别 kvo/delegate/notification选择 关联对象 copy/strong/weak property 通知(同步执行还是异步？) 03 Runtime(基础)runtime概述 对象、类对象、元类对象 消息传递机制 消息转发流程 Method-Swizzling 对象、类对象、原类对象的理解、消息传递机制、消息转发流程、Method-Swizzling、ISA-swizzling、动态方法解析、动态添加方法 一个程序启动之后，类对象和方法是如何存在的？ 04 内存(基础) 引用计数表 弱引用表 ARC、MRC 循环引用 内存管理 为什么用copy，哪些情况下用copy，为什么用copy? NSTimer的引用释放(runloop引用timer，timer引用self，导致不能释放) 05 Block(基础) Block本质 截获变量特性 内存管理 循环引用 06 多线程(基础) GCD、nsoperation 资源共享 线程同步 SpinLock等 atomic和线程安全 你怎样实现线程安全的？这些线程安全的办法和atomic有什么不一样？atomic的实现机制是怎样 07 RunLoop(基础) 事件循环 用户态 核心态 常驻线程 08 网络(基础) HTTPS 对称加密算法 非对称加密 DNS解析 HTTP、TCP ASI AFN 有听过HTTPDNS吗？ 有哪些方法能加快网络连接速度 如何维持长链接 如何发送心跳包 用户产生一个下拉刷新动作，请详细描述网络如何传输 简述tcp连接时的握手过程，不要第三次握手行不行？ 09 设计模式(基础) 桥接、适配器、命令 责任链、单例 六大设计原则 10 架构/框架(效率) MVVM、时长统计框架 图片缓存框架 PV量级10亿级业务架构 CocoaPods 编译原理 宏 编译过程 clang 优化理论与实践(质量)YYKit终极优化 启动时长优化 卡顿优化 cpu占用 内存占用 UI主线程 电量 图片 瘦身 效率提升(效率) 代码块 功能模版 自动代码 json转model 跨平台 研发质量管理(质量) codereview clang二次开发(编译器警告) oclint infer git commit(增量检测) 冗余代码 重复代码 重复图片检测 ipa包大小和模块大小检测 监控理论和实践(质量) crash 网络 流量 性能 行为 截图行为应用 热修复理论与实践 JSPatch Lua？ 发包与灰度(效率) testflight灰度的应用 CI的优化(自动发包) 算法 字符串反转 句子反转 快速排序 单链表反转 有序数组归并 无序数组找中位数(快排) 12 第三方 AFNetworking ReactCocoa响应式编程库]]></content>
  </entry>
  <entry>
    <title><![CDATA[runtime概述]]></title>
    <url>%2F2015%2F08%2F10%2F2015%2Fruntime%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[runtime概述 什么是runtime?runtime直译就是运行时间,run(跑,运行) time(时间),网上大家都叫它运行时,它是一套比较底层的纯C语言API,属于一个C语言库,包含了很多底层的C语言API,它是OC的幕后工作者,我们平时写的OC代码,在运行过程时,都会转为runtime的C语言代码 类与对象####Object123interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125; objc_method12345typedef struct objc_ method &#123; SEL method_name; char *method_types; IMP method_imp;&#125;; objc_class12345678910111213141516struct objc_class &#123; Class isa;#if !__OBJC2__ Class super_class; const char *name; long version; //类的版本信息，默认为0 long info; //类信息，供运行期使用的一些位标识 long instance_size; //该类的实例变量大小 struct objc_ivar_list *ivars; //成员列表 struct objc_method_list **methodLists; //方法列表 struct objc_cache *cache; //方法缓存 struct objc_protocol_list *protocols; //协议链表#endif&#125; OBJC2_UNAVAILABLE; Method &amp; SEL &amp; IMP Method:(typedef struct objc_method *Method)在类定义中表示方法的类型，相当于SEL和IMP的映射 SEL(selector):typedef struct objc_selector *SEL方法选择器，用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。 IMP(implement):typedef id (*IMP)(id, SEL, …)方法的实现，这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。 注意，SEL是由方法的名字，也就是字符串来生成的(包含参数)，也就是说，在不同的类中的方法，只要名字和参数相同，那么它的SEL也是相同的，SEL本质是一个Int类型的一个地址(用%p来表示)，地址中存放着方法的名字所有的SEL存储在一个NSSet中，所以SEL是唯一的，以hash实现搜索定位，效率高于NSArray，在方法的调用的时候，是通过数字的查找而非字符串的查找来进行方法定位的，当我定义一个类的时候，有声明或者实现，都会有对应的SEL以及Method对象存在，但是没有实现是IMP则为空，SEL selector = NSSelectorFromString(@&quot;run&quot;);这个代码永远是正确的，但是IMP ipmSel = [FXViewController methodForSelector:selector];如果这个类没有这个实现，那么是会返回(libobjc.A.dylib_objc_msgForward)。所以理论上来讲iOS不存在私有方法，因为我们可以通过运行时来调用任何存在的method，只不过这个方法没有在.h文件进行声明的话，在编译层面会进行一些禁止而已，这样也保障了运行的安全。12345SEL selector = NSSelectorFromString(@&quot;run&quot;);Class class = NSClassFromString(@&quot;FXViewController&quot;);if ([class respondsToSelector:selector]) &#123; [class performSelector:selector withObject:nil];&#125; 当我们在类中进行方法的声明或者实现的时候，底层会默认根据方法名，来注册这个方法，生成对应的SEL和Method，SEL会由一个NSSet来做一个统一的维护，另外Method对象会保存在对应的类的methodlist中，当我们在方法调用的时候，系统会快速的通过注册方法来拿到SEL，然后到对应的类的实现中去根据SEL查找Method，如果Method存在则直接跳转到IMP去调用其指向的函数。如果一个方法只有声明没有实现，那么这个类中是不会有Method对象存在的，可以用class_copyMethodList进行验证 这张图在加载类的时候创建，当发现有方法声明，或者方法实现，或者方法调用的时候，就会把对应的字符串进行一个注册，形成上边那样的一张表，这张表中的SEL是经过运算得到的，而不是查找。 1234567SEL sel = NSSelectorFromString(@&quot;thename123&quot;);NSLog(@&quot;%d&quot;, sel); NSLog(@&quot;%@&quot;, NSStringFromSelector(sel)); SEL sel1 = NSSelectorFromString(@&quot;thename123&quot;);NSLog(@&quot;%d&quot;, sel1); 结果 123xiancheng[69979:33043952] 41424xiancheng[69979:33043952] thename123xiancheng[69979:33043952] 41424 我们看到这是一个hash的过程，是经过运算得到的，而不是查找。，从一个字符串得到一个数字，然后从数字得到一个字符串，这样就更能保证效率了 运行时方法总结通过名字获取SEL，通过SEL和Class获取IMP123456789101112131415// 添加方法BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );// 获取实例方法Method class_getInstanceMethod ( Class cls, SEL name );// 获取类方法Method class_getClassMethod ( Class cls, SEL name );// 获取所有实例方法的数组，不能获取类方法Method * class_copyMethodList ( Class cls, unsigned int *outCount );// 替代方法的实现，如果IMP不存在则默认调用class_addMethod方法IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );// 返回方法的具体实现IMP class_getMethodImplementation ( Class cls, SEL name );IMP class_getMethodImplementation_stret ( Class cls, SEL name );// 类实例是否响应指定的selectorBOOL class_respondsToSelector ( Class cls, SEL sel ); 获取列表123456789101112131415161718192021222324252627282930unsigned int count; //获取属性列表 objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count); for (unsigned int i=0; i&lt;count; i++) &#123; const char *propertyName = property_getName(propertyList[i]); NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]); &#125; //获取方法列表 Method *methodList = class_copyMethodList([self class], &amp;count); for (unsigned int i; i&lt;count; i++) &#123; Method method = methodList[i]; NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method))); &#125; //获取成员变量列表 Ivar *ivarList = class_copyIvarList([self class], &amp;count); for (unsigned int i; i&lt;count; i++) &#123; Ivar myIvar = ivarList[i]; const char *ivarName = ivar_getName(myIvar); NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]); &#125; //获取协议列表 __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count); for (unsigned int i; i&lt;count; i++) &#123; Protocol *myProtocal = protocolList[i]; const char *protocolName = protocol_getName(myProtocal); NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]); &#125; isa指针 方法的执行 调用类的alloc方法，分配内存，初始化成员变量，其中isa指针也会被初始化，让这个对象有访问其类的能力； 当我们调用某个方法的时候，编译器会对这个方法调用进行转换 1234567//1.利用msgSend函数 [someone method]; [someone performSelector:@selector(method)]; ----&gt;objc_msgSend(someone, @selector(method));//2.利用转发函数 NSinvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];[invocation invoke]; objc_msgSend的作用: 它首先找到 SEL 对应的方法实现 IMP。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型 然后将消息接收者对象(指向消息接收者对象的指针)以及方法中指定的参数传递给方法实现 IMP。 最后，将方法实现的返回值作为该函数的返回值返回。 注意：当我们创建一个对象的时候，首先根据类的info来分配内存，然后初始化成员变量，其中isa指针也会被初始化，让这个对象有访问其类的能力，当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程。动态绑定为我们写代码提供了方便，却带来了性能的损耗，因为函数的调用通过地址可以直接确定，而方法需要通过函数的查找，但是方法的缓存一定程度上解决了这个问题。 消息转发机制消息转发用到的方法(消息拦截用到的方法) 12345+ (BOOL)resolveClassMethod:(SEL)sel;+ (BOOL)resolveInstanceMethod:(SEL)sel;//后两个方法需要转发到其他的类处理- (id)forwardingTargetForSelector:(SEL)aSelector;- (void)forwardInvocation:(NSInvocation *)anInvocation; 我们调用一个方法有两种形式123[object message];[object performSelector:@selector(method) withObject:nil]; 第一种我们可以确定对象是否能够处理该方法，如果没有声明编译器会直接报错，不过也存在没有方法实现的风险，第二种方式就会直接编译通过，运行崩溃。规避的方法有两种 第一就是在调用方法之前判断是否该方法实现 123if ([self respondsToSelector:@selector(method)]) &#123; [self performSelector:@selector(method)];&#125; 消息转发机制：通过这一机制，我们可以告诉对象如何处理未知的消息。 默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息： 123-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940&apos; 这段异常信息实际上是由NSObject的”doesNotRecognizeSelector”方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。消息转发机制基本上分为三个步骤： 动态方法解析 备用接收者 完整转发 动态方法解析对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。 123456789101112void functionForMethod1(id self, SEL _cmd) &#123; NSLog(@&quot;%@, %p&quot;, self, _cmd);&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; NSString *selectorString = NSStringFromSelector(sel); if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123; class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;); &#125; return [super resolveInstanceMethod:sel];&#125; 不过这种方案更多的是为了实现@dynamic属性。 备用接收者1- (id)forwardingTargetForSelector:(SEL)aSelector 如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。 12345678910111213141516171819202122232425262728293031323334353637interface SUTRuntimeMethodHelper : NSObject- (void)method2;endimplementation SUTRuntimeMethodHelper- (void)method2 &#123; NSLog(@&quot;%@, %p&quot;, self, _cmd);&#125;@(02-Foundation)end#pragma mark -@interface SUTRuntimeMethod () &#123; SUTRuntimeMethodHelper *_helper;&#125;@end@implementation SUTRuntimeMethod+ (instancetype)object &#123; return [[self alloc] init];&#125;- (instancetype)init &#123; self = [super init]; if (self != nil) &#123; _helper = [[SUTRuntimeMethodHelper alloc] init]; &#125; return self;&#125;- (void)test &#123; [self performSelector:@selector(method2)];&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; NSLog(@&quot;forwardingTargetForSelector&quot;); NSString *selectorString = NSStringFromSelector(aSelector); // 将消息转发给_helper来处理 if ([selectorString isEqualToString:@&quot;method2&quot;]) &#123; return _helper; &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end 完整转发如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法1- (void)forwardInvocation:(NSInvocation *)anInvocation 对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象1234567891011121314- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) &#123; if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123; signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector]; &#125; &#125; return signature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:_helper]; &#125;&#125; NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。 动态方法添加首先调用一个不存在的方法12//隐式调用方法[target performSelector:@selector(resolveAdd:) withObject:@&quot;test&quot;]; 然后，在target对象内部重写拦截调用的方法，动态添加方法。1234567891011void runAddMethod(id self, SEL _cmd, NSString *string)&#123; NSLog(@&quot;add C IMP &quot;, string);&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; //给本类动态添加一个方法 if ([NSStringFromSelector(sel) isEqualToString:@&quot;resolveAdd:&quot;]) &#123; class_addMethod(self, sel, (IMP)runAddMethod, &quot;v@:*&quot;); &#125; return YES;&#125; 其中class_addMethod的四个参数分别是： Class cls 给哪个类添加方法，本例中是self SEL name 添加的方法，本例中是重写的拦截调用传进来的selector。 IMP imp 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用- + (IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。 “v@:*”方法的签名，代表有一个参数的方法 ###Method Swizzling为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。123456789101112131415161718192021222324252627282930313233#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@&quot;viewWillAppear: %@&quot;, self);&#125;@end 注意 Swizzling应该总是在+load中执行 在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。 Swizzling应该总是在dispatch_once中执行 与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践 小心无限循环 咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是[self viewWillAppear:animated]，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为xxx_viewWillAppear:了。 对象关联现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。这种情况的一般解决办法就是继承。但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。这个时候，runtime的关联属性就发挥它的作用了。123456//首先定义一个全局变量，用它的地址作为关联对象的keystatic char associatedObjectKey;//设置关联对象objc_setAssociatedObject(target, &amp;associatedObjectKey, @&quot;添加的字符串属性&quot;, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象NSString *string = objc_getAssociatedObject(target, &amp;associatedObjectKey);NSLog(@&quot;AssociatedObject = %@&quot;, string); objc_setAssociatedObject的四个参数： id object给谁设置关联对象。 const void *key关联对象唯一的key，获取时会用到。 id value关联对象。 objc_AssociationPolicy关联策略，有以下几种策略：enum { OBJC_ASSOCIATION_ASSIGN = 0, OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, OBJC_ASSOCIATION_COPY_NONATOMIC = 3, OBJC_ASSOCIATION_RETAIN = 01401, OBJC_ASSOCIATION_COPY = 01403};如果你熟悉OC，看名字应该知道这几种策略的意思了吧。 objc_getAssociatedObject的两个参数。 id object获取谁的关联对象。 const void *key根据这个唯一的key获取关联对象。其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中，方便使用。12345678//添加关联对象- (void)addAssociatedObject:(id)object&#123; objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;//获取关联对象- (id)getAssociatedObject&#123; return objc_getAssociatedObject(self, _cmd);&#125; 注意：这里面我们把getAssociatedObject方法的地址作为唯一的key，_cmd代表当前调用方法的地址。 总结 方法调用的本质就是通过instance/class+SEL来找到IMP，最终调用IMP的函数来执行调用的 方法调用可以使用invoke的方法 增加方法的是在某个类中增加Method，也就是增加SLE和IMP 替换方法的是更改SLE与IMP的映射关系 参考：南峰子-runtime iOS-runtime理解-简书]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runloop概述]]></title>
    <url>%2F2015%2F07%2F21%2F2015%2FRunloop%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[参考ibireme’s Block 1.基本概念为什么需要runloop 使程序一直活着 决定程序何时应该处理哪些event 调用解耦(message queue) 节省CPU时间 开启主线程要消耗1M内存，开启一个后台线程需要消耗512k内存，我们应当在线程没有任务的时候休眠，来释放所占用的资源 与runloop相关的类 NSTimer UIEvent Autorelease NSObjec–&gt;NSDelayedPerforming NSObjec–&gt;NSThreadPerformAddition CADisplayLink CATransition CAAnimation dispatch_get_main_queue() NSURLConnection runloop与线程 每条线程都有唯一的一个与之对应的RunLoop对象 主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建 RunLoop在第一次获取时创建，在线程结束时销毁 一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件，比如说主线程。 线程和RunLoop之间是以键值对的形式一一对应的，其中key是thread，value是runLoop(这点可以从苹果公开的源码中看出来)，其实RunLoop是管理线程的一种机制，这种机制不仅在IOS上有，在Node.js中的EventLoop，Android中的Looper，都有类似的模式 获取runloop Foundation12[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象 Core Foundation12CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象CFRunLoopGetMain(); // 获得主线程的RunLoop对象 runloop基本结构NSRunLoop继承自NSObject runloop与Thread一一对应，但是并不是一个thread只能有一runloop，我们可以给runloop嵌套runloop CFRunLoopMode CFRunLoopModeRef代表RunLoop的运行模式 一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source/Timer/Observer 每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode 如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入 这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响 系统默认注册了5个Mode:(前两个跟最后一个常用) kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到 kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mod CFRunLoopSource CFRunLoopSourceRef是事件源（输入源） 按照官方文档的分类 Port-Based Sources (基于端口,跟其他线程交互,通过内核发布的消息) Custom Input Sources (自定义) Cocoa Perform Selector Sources (performSelector…方法) 按照函数调用栈的分类 Source0：非基于Port的 Source1：基于Port的 Source0: event事件，只含有回调，需要先调用CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop。Source1: 包含了一个 mach_port 和一个回调，被用于通过内核和其他线程相互发送消息,能主动唤醒 RunLoop 的线程。 CFRunLoopTimer本质就是一个timer12345+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;//该方法定义在RunLoop中，不过是NSObject的分类；+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;//这个类方法定义在DisPlayLink中- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode;//这也是DisPlayLink中的方法 CFRunLoopTimerRef是基于时间的触发器 基本上说的就是NSTimer(CADisplayLink也是加到RunLoop),它受RunLoop的Mode影响 GCD的定时器不受RunLoop的Mode影响CFRunLoopObserver CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变 可以监听的时间点有以下几个 应用 CADisplayLink NSTimer ImageView显示 PerformSelector 常驻线程 自动释放池 NSURLConnection的执行过程 AFNetWorking中是如何使用RunLoop的? 深入理解Perform Selector12345678910111213- (void)tryPerformSelectorOnMianThread&#123;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [self performSelector:@selector(perform1) withObject:nil]; &#125;);&#125;- (void)mainThreadMethod&#123;NSLog(@&quot;execute %s&quot;,__func__);// print: execute -[ViewController mainThreadMethod]&#125; 123456789101112131415- (void)tryPerformSelectorOnBackGroundThread&#123;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];&#125;);&#125;- (void)backGroundThread&#123;NSLog(@&quot;%u&quot;,[NSThread isMainThread]);NSLog(@&quot;execute %s&quot;,__FUNCTION__);&#125; 这样我们在ViewDidLoad中调用tryPerformSelectorOnMianThread,就会立即执行，并且输出:print: execute -[ViewController mainThreadMethod];上边的performselector在子线程中依然可以执行，因为它不依赖于timer，不需要启动runloop，但是下边的做法就不行。 和上面的例子一样，我们使用GCD,让这个方法在后台线程中执行 123456789101112131415- (void)tryPerformSelectorOnBackGroundThread&#123;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];&#125;);&#125;- (void)backGroundThread&#123;NSLog(@&quot;%u&quot;,[NSThread isMainThread]);NSLog(@&quot;execute %s&quot;,__FUNCTION__);&#125; 同样的，我们调用tryPerformSelectorOnBackGroundThread这个方法，我们会发现，下面的backGroundThread不会被调用，这是什么原因呢？这是因为，在调用performSelector:onThread: withObject: waitUntilDone的时候，系统会给我们创建一个Timer的source，加到对应的RunLoop上去，然而这个时候我们没有RunLoop,如果我们加上RunLoop:1234567891011- (void)tryPerformSelectorOnBackGroundThread&#123;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];NSRunLoop *runLoop = [NSRunLoop currentRunLoop];[runLoop run];&#125;);&#125; 这时就会发现我们的方法正常被调用了。那么为什么主线程中的perfom selector却能够正常调用呢？通过上面的例子相信你已经猜到了，主线程的RunLoop是一直存在的，所以我们在主线程中执行的时候，无需再添加RunLoop。小结:当perform selector在后台线程中执行的时候，这个线程必须有一个开启的runLoop Perform Selector after当某个事件触发了某段代码执行的时候，是要在一个runloop中执行完毕的，如果这个线程有runloop的话，这样如果在一个主线程有一大段代码要执行，那么就会阻碍这个线程，或者更准确来讲是让这个runloop不能去处理用户事件和刷新屏幕，那该怎么办呢？答案就是这个方法- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay我们可以把一个大段的方法执行切分成几份，然后用该方法连接，每次执行这个方法，就会进入到下一个runloop才会执行，而每个runloop的执行，用户事件的处理和屏幕刷新是在代码执行前边的，所以这样就有机会中断代码的执行，就像是下边这样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677@property (nonatomic, strong) UIButton *btn1;@property (nonatomic, strong) UIButton *btn2;@property (nonatomic, assign) BOOL next;@endint b = 0;@implementation ViewController- (UIButton *)btn1 &#123; if (!_btn1) &#123; _btn1 = [UIButton buttonWithType:UIButtonTypeCustom]; [_btn1 setTitle:@&quot;点我1&quot; forState:UIControlStateNormal]; [_btn1 sizeToFit]; [_btn1 addTarget:self action:@selector(click1) forControlEvents:UIControlEventTouchUpInside]; [_btn1 setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; &#125; return _btn1;&#125;- (UIButton *)btn2 &#123; if (!_btn2) &#123; _btn2 = [UIButton buttonWithType:UIButtonTypeCustom]; [_btn2 setTitle:@&quot;点我2&quot; forState:UIControlStateNormal]; [_btn2 sizeToFit]; [_btn2 addTarget:self action:@selector(click2) forControlEvents:UIControlEventTouchUpInside]; [_btn2 setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; &#125; return _btn2;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; [self.view addSubview:self.btn1]; [self.view addSubview:self.btn2]; self.btn1.frame = CGRectMake(10, 30, 50, 20); self.btn2.frame = CGRectMake(100, 30, 50, 20);&#125;- (void)click1 &#123; for (int i = 0; i &lt; 3000; i++) &#123; NSLog(@&quot;%d&quot;, i); &#125;[self performSelector:@selector(perform1) withObject:nil afterDelay:0.005];&#125;- (void)perform1 &#123; for (int i = 3000; i &lt; 6000; i++) &#123; NSLog(@&quot;%d&quot;, i); &#125; [self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];&#125;- (void)perform4 &#123; if (!_next) return; for (int i = 6000; i &lt; 9000; i++) &#123; NSLog(@&quot;%d&quot;, i); &#125; [self performSelector:@selector(perform5) withObject:nil afterDelay:0.005];&#125;- (void)perform5 &#123; if (!_next) return; for (int i = 600; i &lt; 900; i++) &#123; NSLog(@&quot;%d&quot;, i); &#125;&#125;- (void)click2 &#123; _next = NO;&#125; 实验证明，只有after方法有这样的魔力。 总结:当我们创建了一个timer事件的时候，这个时候这个事件就会被放到下一个runloop中执行，如果这个线程中根本就没有起runloop，那么也就不存在下一个runloop，这个事件也就永远不会被执行了。 CADisplayLink用法和timer一样，放在子线程的话记得自己创建runloop1234567dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // Track FPS using display link _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkTick)]; // [_displayLink setPaused:YES]; [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; [[NSRunLoop currentRunLoop] run]; &#125;); Timer123456789101112131415161718192021222324252627282930@interface ViewController ()@property (nonatomic, strong) UIScrollView *scrollView;@property (nonatomic, assign) NSInteger count;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self.view addSubview:self.scrollView]; NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(printfString) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];// 标记为common modes的模式：UITrackingRunLoopMode和NSDefaultRunLoopMode兼容,timer就都可以跑了&#125;- (UIScrollView *)scrollView &#123; if (!_scrollView) &#123; _scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 100, kScreenW, 200)]; _scrollView.backgroundColor = [UIColor redColor]; _scrollView.contentSize = CGSizeMake(kScreenW * 2, 0); &#125; return _scrollView;&#125;- (void)printfString &#123; self.count ++; NSLog(@&quot;%ld&quot;, self.count);&#125; 这个时候代码按照我们预定的结果运行，如果我们把这个Tiemr放到后台线程中呢?1234567dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSTimer *myTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES]; [myTimer fire];&#125;); 这个时候我们会发现，这个timer只执行了一次，就停止了。这是为什么呢？通过上面的讲解，想必你已经知道了，NSTimer,只有注册到RunLoop之后才会生效，这个注册是由系统自动给我们完成的,既然需要注册到RunLoop,那么我们就需要有一个RunLoop,我们在后台线程中加入如下的代码:12NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop run]; 这样我们就会发现程序正常运行了。在Timer注册到RunLoop之后，RunLoop会为其重复的时间点注册好事件，比如1：10，1：20，1：30这几个时间点。有时候我们会在这个线程中执行一个耗时操作，这个时候RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer，这就造成了误差(Timer有个冗余度属性叫做tolerance,它标明了当前点到后，容许有多少最大误差)，可以在执行一段循环之后调用一个耗时操作，很容易看到timer会有很大的误差，这说明在线程很闲的时候使用NSTiemr是比较傲你准确的，当线程很忙碌时候会有较大的误差。系统还有一个CADisplayLink,也可以实现定时效果，它是一个和屏幕的刷新率一样的定时器。如果在两次屏幕刷新之间执行一个耗时的任务，那其中就会有一个帧被跳过去，造成界面卡顿。另外GCD也可以实现定时器的效果，由于其和RunLoop没有关联，所以有时候使用它会更加的准确，这在最后会给予说明。 ImageView需求:当用户在拖拽时(UI交互时)不显示图片,拖拽完成时显示图片 方法1 监听UIScrollerView滚动 (通过UIScrollViewDelegate监听,此处不再举例) 方法2 RunLoop 设置运行模式 12// 只在NSDefaultRunLoopMode模式下显示图片 [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;placeholder&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]]; 比如修改sdwebimage中的方法，如果设置imageview为滚动列表模式，则加入该方法，当列表停止滚动模式的时候才加载图片 一直活着的后台线程现在有这样一个需求，每点击一下屏幕，让子线程做一个任务,然后大家一般会想到这样的方式: 12345678910111213141516171819202122232425262728293031@interface ViewController ()@property(nonatomic,strong) NSThread *myThread;@end@implementation ViewController- (void)alwaysLiveBackGoundThread&#123;NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(myThreadRun) object:@&quot;etund&quot;];self.myThread = thread;[self.myThread start];&#125;- (void)myThreadRun&#123;NSLog(@&quot;my thread run&quot;);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;%@&quot;,self.myThread); [self performSelector:@selector(doBackGroundThreadWork) onThread:self.myThread withObject:nil waitUntilDone:NO];&#125;- (void)doBackGroundThreadWork&#123; NSLog(@&quot;do some work %s&quot;,__FUNCTION__);&#125;@end 这个方法中，我们利用一个强引用来获取了后天线程中的thread,然后在点击屏幕的时候，在这个线程上执行doBackGroundThreadWork这个方法，此时我们可以看到，在touchesBegin方法中，self.myThread是存在的，但是这是为是什么呢？这就要从线程的五大状态来说明了:新建状态、就绪状态、运行状态、阻塞状态、死亡状态，这个时候尽管内存中还有线程，但是这个线程在执行完任务之后已经死亡了，经过上面的论述，我们应该怎样处理呢？我们可以给这个线程的RunLoop添加一个source，那么这个线程就会检测这个source等待执行，而不至于死亡(有工作的强烈愿望而不死亡): 12345678- (void)myThreadRun&#123;[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];[[NSRunLoop currentRunLoop] run] NSLog(@&quot;my thread run&quot;);&#125; 这个时候再次点击屏幕，我们就会发现，后台线程中执行的任务可以正常进行了。小结:正常情况下，后台线程执行完任务之后就处于死亡状态，我们要避免这种情况的发生可以利用RunLoop，并且给它一个Source这样来保证线程依旧还在 NSURLConnection的执行过程在使用NSURLConnection时，我们会传入一个Delegate,当我们调用了[connection start]之后，这个Delegate会不停的收到事件的回调。实际上，start这个函数的内部会获取CurrentRunloop，然后在其中的DefaultMode中添加4个source。如下图所示，CFMultiplexerSource是负责各种Delegate回调的，CFHTTPCookieStorage是处理各种Cookie的。如下图所示:从中可以看出，当开始网络传输是，我们可以看到NSURLConnection创建了两个新的线程:com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket是处理底层socket链接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过之前添加的source，来通知(唤醒)上层的Delegate。这样我们就可以理解我们平时封装网络请求时候常见的下面逻辑了: 1234567891011121314while (!_isEndRequest)&#123; NSLog(@&quot;entered run loop&quot;); [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];&#125;NSLog(@&quot;main finished，task be removed&quot;);- (void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; _isEndRequest = YES;&#125; 这里我们就可以解决下面这些疑问了: 为什么这个While循环不停的执行，还需要使用一个RunLoop? 程序执行一个while循环是不会耗费很大性能的，我们这里的目的是想让子线程在有任务的时候处理任务，没有任务的时候休眠，来节约CPU的开支。 如果没有为RunLoop添加item,那么它就会立即退出，这里的item呢? 其实系统已经给我们默认添加了4个source了。 既然[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];让线程在这里停下来，那么为什么这个循环会持续的执行呢？因为这个一直在处理任务，并且接受系统对这个Delegate的回调，也就是这个回调唤醒了这个线程，让它在这里循环。 AFNetWorking中是如何使用RunLoop的?在AFN中AFURLConnectionOperation是基于NSURLConnection构建的，其希望能够在后台线程来接收Delegate的回调。为此AFN创建了一个线程,然后在里面开启了一个RunLoop，然后添加item 12345678910111213141516171819+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;@autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run];&#125;&#125;+ (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; 这里这个NSMachPort的作用和上文中的一样，就是让线程不至于在很快死亡，然后RunLoop不至于退出(如果要使用这个MachPort的话，调用者需要持有这个NSMachPort，然后在外部线程通过这个port发送信息到这个loop内部,它这里没有这么做)。然后和上面的做法相似，在需要后台执行这个任务的时候，会通过调用:[NSObject performSelector:onThread:..]来将这个任务扔给后台线程的RunLoop中来执行。 12345678910- (void)start &#123;[self.lock lock];if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];&#125; else if ([self isReady]) &#123; self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];&#125;[self.lock unlock];&#125; GCD定时器的实现12345678910111213141516171819202122232425262728- (void)gcdTimer&#123;// get the queuedispatch_queue_t queue = dispatch_get_global_queue(0, 0);// creat timerself.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);// config the timer (starting time，interval)// set begining timedispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));// set the intervaluint64_t interver = (uint64_t)(1.0 * NSEC_PER_SEC);dispatch_source_set_timer(self.timer, start, interver, 0.0);dispatch_source_set_event_handler(self.timer, ^&#123; // the tarsk needed to be processed async dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; for (int i = 0; i &lt; 100000; i++) &#123; NSLog(@&quot;gcdTimer&quot;); &#125; &#125;);&#125;);dispatch_resume(self.timer);&#125; 谈谈你对Run Loop的理解 RunLoop是多线程的一个很重要的机制，就是一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程会通过do-while死循环让程序持续等待下一个任务不退出。通过mach_msg()让runloop没事时进入trap状态，节省CPU资源。非主线程通常来说就是为了执行某个任务而创建的，执行完就会归还资源，因此默认不开启RunLoop 实质上，对于子线程的runloop是默认不存在的，因为苹果采用了懒加载的方式，如果没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询当前线程的RunLoop，也不会创建、加载 当然如果子线程处理完某个任务后不退出，需要继续等待接受事件，需要启动的时候也可以手动启动，比如说添加定时器的时候就要手动开始RunLoop如何处理事件 界面刷新： 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。 苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 手势识别： 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 网络请求：最底层是CFSocket层，然后是CFNetwork将其封装，然后是NSURLConnection对CFNetwork进行面向对象的封装，NSURLConnection是iOS7中新增的接口。当网络开始传输时，NSURLConnection创建了两个新线程：com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket线程是处理底层socket连接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接受底层socket的事件，并添加到上层的Delegate 应用 滑动与图片刷新：当tableView的cell上有需要从网络获取的图片的时候，滚动tableView，异步线程回去加载图片，加载完成后主线程会设置cell的图片，但是会造成卡顿。可以设置图片的任务在CFRunloopDefaultMode下进行，当滚动tableView的时候，Runloop切换到UITrackingRunLoopMode，不去设置图片，而是而是当停止的时候，再去设置图片。（在viewDidLoad中调用self.imageView performSelector@selector(setImage) withObject:…afterDelay:…inModes@[NSDefayltRunLoopMode]） 常驻子线程，保持子线程一直处理事件 为了保证线程长期运转，可以在子线程中加入RunLoop，并且给Runloop设置item，防止Runloop自动退出 RunLoop处理的几种事件 static void CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION();static void CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK();static void CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE();static void CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION();static void CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION();static void CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION(); 他对这六类事件有如下解释 1.Observer事件，runloop中状态变化时进行通知。（微信卡顿监控就是利用这个事件通知来记录下最近一次main runloop活动时间，在另一个check线程中用定时器检测当前时间距离最后一次活动时间过久来判断在主线程中的处理逻辑耗时和卡主线程）。这里还需要特别注意，CAAnimation是由RunloopObserver触发回调来重绘，。 2.Block事件，非延迟的NSObject PerformSelector立即调用，dispatch_after立即调用，block回调。 3.Main_Dispatch_Queue事件：GCD中dispatch到main queue的block会被dispatch到main loop执行，如果主线程是睡眠的，这个行为是会唤醒主线程的。 4.Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。CADisplayLink也是这里触发，同时这个行为也是会唤醒线程的。如果某个timer到了回调时机，但是这个时候runloop在忙着，那么这个timer就会被跳过去，而不是延时执行，等到下一次timer触发才会被执行。 5.Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是Source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 _UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。[self performSelector:@selector(perform1) withObject:nil];是走source0的。 6.Source1事件：处理系统内核的mach_msg事件。 验证方法是，打断点，lldb上边的调用栈 深刻理解一下就是，点击事件等，和UI绘制，都只是先标记，然后等到线程睡眠前再根据标记，统一处理。而做一个值计算之类的，直接就是source0直接进行操作了。 如何涉及到切换线程，一般是触发一个source1，不需要切换线程的perform是一个source0事件。 几个问题runloop被唤醒有几种情况？ 基于port的source事件，比如触摸这种source1 timer到时间了 runloop自身睡眠时间到了，iOS现在测试是1分钟，这是自身的一个保活机制，如果一个线程长期休眠，那么unix就会把它杀死 被其他什么调用者手动唤醒，比如其他线程要求回到这个线程执行个啥方法 在主线程执行一个大计算的方法，如何保证最低限度影响UI将这个任务进行拆分，通过perform after进行拼接，这样这个任务会被分成几个runloop去执行，这样有机会进入到线程休眠，这个时候就会机会提交UI的一些变化了 具体问题，要求打印1-10000，然后点击一个按钮可以暂停，怎么做？ 总结如果我们想要打断一个方法的执行，一个办法就是用[self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];来连接方法的执行，这里延迟时间设置为0有时是无效的，我们可以给一个很小的时间，]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)视音频编解码技术零基础学习方法]]></title>
    <url>%2F2015%2F07%2F17%2F2015%2F%E8%BD%AC-%E8%A7%86%E9%9F%B3%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8A%80%E6%9C%AF%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原文地址http://blog.csdn.net/leixiaohua1020/article/details/18893769 视频播放器原理视音频技术主要包含以下几点：封装技术，视频压缩编码技术以及音频压缩编码技术。如果考虑到网络传输的话，还包括流媒体协议技术。视频播放器的源代码详细解析（Media Player Classic - HC，Mplayer，FFplay，XBMC）可以参考系列文章：Media Player Classic：Media Player Classic - HC源代码分析 1：整体结构[系列文章]Mplayer：MPlayer源代码分析FFplay： FFplay源代码分析：整体流程图XBMC： XBMC源代码分析 1：整体结构以及编译方法[系列文章]在这里不细说了，仅简要说明一下视频播放器的原理。视频播放器播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。他们的过程如图所示。 解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。接下来的几节我们将会列出主要的流媒体协议，封装格式，以及视音频编码标准。更详细的比较可以参考：视频参数（流媒体系统，封装格式，视频编码，音频编码，播放器）对比有关本文中涉及到的协议数据、封装格式数据、视频编码数据、音频编码数据、视频像素数据、音频采样数 流媒体协议流媒体协议是服务器与客户端之间通信遵循的规定。当前网络上主要的流媒体协议如表所示。主要流媒体协议一览RTSP+RTP经常用于IPTV领域。因为其采用UDP传输视音频，支持组播，效率较高。但其缺点是网络不好的情况下可能会丢包，影响视频观看质量。因而围绕IPTV的视频质量的研究还是挺多的。RTSP规范可参考：RTSP协议学习笔记RTSP+RTP系统中衡量服务质量可参考：网络视频传输的服务质量（QoS）上海IPTV码流分析结果可参考：IPTV视频码流分析因为互联网网络环境的不稳定性，RTSP+RTP较少用于互联网视音频传输。互联网视频服务通常采用TCP作为其流媒体的传输层协议，因而像RTMP，MMS，HTTP这类的协议广泛用于互联网视音频服务之中。这类协议不会发生丢包，因而保证了视频的质量，但是传输的效率会相对低一些。此外RTMFP是一种比较新的流媒体协议，特点是支持P2P。RTMP我做的研究相对多一些：比如RTMP规范简单分析，或者RTMP流媒体播放过程相关工具的源代码分析：RTMPdump源代码分析 1： main()函数[系列文章]RTMP协议学习：RTMP流媒体技术零基础学习方法 封装格式封装格式的主要作用是把视频码流和音频码流按照一定的格式存储在一个文件中。现如今流行的封装格式如下表所示：由表可见，除了AVI之外，其他封装格式都支持流媒体，即可以“边下边播”。有些格式更“万能”一些，支持的视音频编码标准多一些，比如MKV。而有些格式则支持的相对比较少，比如说RMVB。这些封装格式都有相关的文档，在这里就不一一例举了。我自己也做过辅助学习的小项目：TS封装格式分析器FLV封装格式分析器 视频编码视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。视频编码是视音频技术中最重要的技术之一。视频码流的数据量占了视音频总数据量的绝大部分。高效率的视频编码在同等的码率下，可以获得更高的视频质量。视频编码的简单原理可以参考：视频压缩编码和音频压缩编码的基本原理注：视频编码技术在整个视音频技术中应该是最复杂的技术。如果没有基础的话，可以先买一些书看一下原理，比如说《现代电视原理》《数字电视广播原理与应用》（本科的课本）中的部分章节。 由表可见，有两种视频编码方案是最新推出的：VP9和HEVC。目前这两种方案都处于研发阶段，还没有到达实用的程度。当前使用最多的视频编码方案就是H.264。 4.1 主流编码标准H.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。基于H.264标准的编码器还是很多的，究竟孰优孰劣？可参考：MSU出品的 H.264编码器比较（2011.5）在学习视频编码的时候，可能会用到各种编码器（实际上就是一个exe文件），他们常用的编码命令可以参考：各种视频编码器的命令行格式学习H.264最标准的源代码，就是其官方标准JM了。但是要注意，JM速度非常的慢，是无法用于实际的：H.264参考软件JM12.2RC代码详细流程实际中使用最多的就是x264了，性能强悍（超过了很多商业编码器），而且开源。其基本教程网上极多，不再赘述。编码时候可参考：x264编码指南——码率控制。编码后统计值的含义：X264输出的统计值的含义（X264 Stats Output）Google推出的VP8属于和H.264同一时代的标准。总体而言，VP8比H.264要稍微差一点。有一篇写的很好的VP8的介绍文章：深入了解 VP8。除了在技术领域，VP8和H.264在专利等方面也是打的不可开交，可参考文章：WebM(VP8) vs H.264此外，我国还推出了自己的国产标准AVS，性能也不错，但目前比H.264还是要稍微逊色一点。不过感觉我国在视频编解码领域还算比较先进的，可参考：视频编码国家标准AVS与H.264的比较（节选）近期又推出了AVS新一代的版本AVS+，具体的性能测试还没看过。不过据说AVS+得到了国家政策上非常强力的支持。 4.2 下一代编码标准下一代的编解码标准就要数HEVC和VP9了。VP9是Google继VP8之后推出的新一代标准。VP9和HEVC相比，要稍微逊色一些。它们的对比可参考：（1）HEVC与VP9编码效率对比 （2）HEVC，VP9，x264性能对比HEVC在未来拥有很多大的优势，可参考：HEVC将会取代H.264的原因学习HEVC最标准的源代码，就是其官方标准HM了。其速度比H.264的官方标准代码又慢了一大截，使用可参考：HEVC学习—— HM的使用未来实际使用的HEVC开源编码器很有可能是x265，目前该项目还处于发展阶段，可参考：x265(HEVC编码器，基于x264)介绍。x265的使用可以参考：HEVC（H.265）标准的编码器（x265，DivX265）试用主流以及下一代编码标准之间的比较可以参考文章：视频编码方案之间的比较（HEVC，H.264，MPEG2等）此外，在码率一定的情况下，几种编码标准的比较可参考：限制码率的视频编码标准比较（包括MPEG-2，H.263， MPEG-4，以及 H.264）结果大致是这样的：HEVC &gt; VP9 &gt; H.264&gt; VP8 &gt; MPEG4 &gt; H.263 &gt; MPEG2。截了一些图，可以比较直观的了解各种编码标准：HEVC码流简析：HEVC码流简单分析H.264码流简析：H.264简单码流分析MPEG2码流简析：MPEG2简单码流分析以上简析使用的工具：视频码流分析工具我自己做的小工具： H.264码流分析器 音频编码音频编码的主要作用是将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量。音频编码也是互联网视音频技术中一个重要的技术。但是一般情况下音频的数据量要远小于视频的数据量，因而即使使用稍微落后的音频编码标准，而导致音频数据量有所增加，也不会对视音频的总数据量产生太大的影响。高效率的音频编码在同等的码率下，可以获得更高的音质。音频编码的简单原理可以参考：视频压缩编码和音频压缩编码的基本原理 由表可见，近年来并未推出全新的音频编码方案，可见音频编码技术已经基本可以满足人们的需要。音频编码技术近期绝大部分的改动都是在MP3的继任者——AAC的基础上完成的。这些编码标准之间的比较可以参考文章：音频编码方案之间音质比较（AAC，MP3，WMA等）结果大致是这样的：AAC+ &gt; MP3PRO &gt; AAC&gt; RealAudio &gt; WMA &gt; MP3AAC格式的介绍：AAC格式简介AAC几种不同版本之间的对比：AAC规格（LC，HE，HEv2）及性能对比AAC专利方面的介绍：AAC专利介绍此外杜比数字的编码标准也比较流行，但是貌似比最新的AAC稍为逊色：AC-3技术综述我自己做的小工具： AAC格式分析器 现有网络视音频平台对比现有的网络视音频服务主要包括两种方式：点播和直播。点播意即根据用户的需要播放相应的视频节目，这是互联网视音频服务最主要的方式。绝大部分视频网站都提供了点播服务。直播意即互联网视音频平台直接将视频内容实时发送给用户，目前还处于发展阶段。直播在网络电视台，社交视频网站较为常见。 直播平台参数对比主流互联网视音频平台直播服务的参数对比如表所示：现有网络视音频平台参数对比 可以看出，直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式。采用RTMP作为直播协议的好处在于其被Flash播放器支持。而Flash播放器如今已经安装在全球99%的电脑上，并且与浏览器结合的很好。因此这种流媒体直播平台可以实现“无插件直播”，极大的简化了客户端的操作。封装格式，视频编码，音频编码方面，无一例外的使用了FLV + H.264 + AAC的组合。FLV是RTMP使用的封装格式，H.264是当今实际应用中编码效率最高的视频编码标准，AAC则是当今实际应用中编码效率最高的音频编码标准。视频播放器方面，都使用了Flash播放器。 点播平台参数对比主流网络视音频平台点播服务的参数对比如表所示：现有互联网视音频平台参数对比 可以看出，点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式。采用HTTP作为点播协议有以下两点优势：一方面，HTTP是基于TCP协议的应用层协议，媒体传输过程中不会出现丢包等现象，从而保证了视频的质量；另一方面，HTTP被绝大部分的Web服务器支持，因而流媒体服务机构不必投资购买额外的流媒体服务器，从而节约了开支。点播服务采用的封装格式有多种：MP4，FLV，F4V等，它们之间的区别不是很大。视频编码标准和音频编码标准是H.264和AAC。这两种标准分别是当今实际应用中编码效率最高的视频标准和音频标准。视频播放器方面，无一例外的都使用了Flash播放器。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>流媒体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)音视频基础概念汇总]]></title>
    <url>%2F2015%2F07%2F17%2F2015%2F%E8%BD%AC-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[第一部分：基本概念讲解 媒体：是表示，传输，存储信息的载体，常人们见到的文字、声音、图像、图形等都是表示信息的媒体。 多媒体： 是声音、动画、文字、图像和录像等各种媒体的组合，以图文并茂，生动活泼的动态形式表现出来，给人以很强的视觉冲击力，留下深刻印象 多媒体技术：是将文字、声音、图形、静态图像、动态图像与计算集成在一起的技术。它要解决的问题是计算机进一步帮助人类按最自然的和最习惯的方式接受和处理信息。 流媒体 ：流媒体是指采用流式传输的方式在Internet播放的连续时基媒体格式，实际指的是一种新的媒体传送方式，而不是一种新的媒体格式（在网络上传输音/视频等多媒体信息现在主要有下载和流式传输两种方式）流式传输分两种方法：实时流式传输方式(Realtime streaming)和顺序流式传输方式(progressive streaming)。 多媒体文件：是既包括视频又包括音频，甚至还带有脚本的一个集合，也可以叫容器； 媒体编码：是文件当中的视频和音频所采用的压缩算法。也就是说一个avi的文件，当中的视频编码有可能是A，也可能是B，而其音频编码有可能是1，也有可能是2。 转码 ：指将一段多媒体包括音频、视频或者其他的内容从一种编码格式转换成为另外一种编码格式 视频：连续的图象变化每秒超过24帧（Frame）画面以上时，根据视觉暂留原理，人眼无法辨别单幅的静态画面，看上去是平滑连续的视觉效果，这样连续的画面叫做视频 音频 ：人类能听到的声音都成为音频，但是一般我们所说到的音频时存储在计算机里的声音 第二部分：视频文件格式 码率：码率就是数据传输时单位时间传送的数据位数,一般我们用的单位是kbps即千位每秒。 通俗一点的理解就是取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真。但是因为编码算法不一样，所以也不能用码率来统一衡量音质或者画质. 帧：帧就是一段数据的组合，它是数据传输的基本单位。就是影像动画中最小单位的单幅影像画面，相当于电影胶片上的每一格镜头。一帧就是一副静止的画面，连续的帧就形成动画，如电视图像等。 帧率：帧率即每秒显示帧数，帧率表示图形处理器处理场时每秒钟能够更新的次数。高的帧率可以得到更流畅、更逼真的动画。一般来说30fps就是可以接受的，但是将性能提升至60fps则可以明显提升交互感和逼真感，但是一般来说超过75fps一般就不容易察觉到有明显的流畅度提升了。如果帧率超过屏幕刷新率只会浪费图形处理的能力，因为监视器不能以这么快的速度更新，这样超过新率的帧率就浪费掉了。关键帧：相当于二维动画中的原画，指角色或者物体运动或变化中的关键动作所处的那一帧，它包含了图像的所有信息，后来帧仅包含了改变了的信息。如果你没有足够的关键帧，你的影片品质可能比较差，因为所有的帧从别的帧处产生。对于一般的用途，一个比较好的原则是每5秒设一个关键键。但如果时那种实时传输的流文件，那么要考虑传输网络的可靠度，所以要1到2秒增加一个关键帧。目前我们经常见的视频格式无非就是两大类：1、影像格式（Video）2、流媒体格式（Stream Video） 在影像格式中还可以根据出处划分为三大种：1、AVI格式：这是由微软（Microsoft）提出，具有“悠久历史”的一种视频格式2、MOV格式：这是由苹果（Apple）公司提出的一种视频格式3、MPEG/MPG/DAT：这是由国际标准化组织ISO(International Standards Organization)与IEC(International Electronic Committee)联合开发的一种编码视频格式。MPEG是运动图像压缩算法的国际标准，现已被几乎所有的计算机平台共同支持。 在流媒体格式中同样还可以划分为三种：1、RM格式：这是由Real Networks公司开发的一种新型流式视频文件格式。2、MOV/QT格式：MOV也可以作为一种流文件格式。QuickTime能够通过Internet提供实时的数字化信息流、工作流与文件回放功能，为了适应这一网络多媒体应用，QuickTime为多种流行的浏览器软件提供了相应的QuickTime Viewer插件（Plug－in），能够在浏览器中实现多媒体数据的实时回放。3、ASF格式：这是由微软公司开发的流媒体格式，是一个在Internet上实时传播多媒体的技术标准。4、FLV 具体视频文件格式详解： *. MPEG/.MPG/.DATMPEG也是Motion Picture Experts Group的缩写。这类格式包括了MPEG-1, MPEG-2和 MPEG-4在内的多种视频格式。MPEG-1相信是大家接触得最多的了，因为目前其正在被广泛地应用在VCD的制作和一些视频片段下载的网络应用上面，大部分的VCD都是用 MPEG1格式压缩的( 刻录软件自动将MPEG1转为.DAT格式)，使用 MPEG-1的压缩算法，可以把一部 120 分钟长的电影压缩到1.2 GB 左右大小。MPEG-2则是应用在DVD 的制作，同时在一些HDTV（高清晰电视广播）和一些高要求视频编辑、处理上面也有相当多的应用。使用MPEG-2的压缩算法压缩一部 120 分钟长的电影可以压缩到 5-8 GB的大小（MPEG2的图像质量MPEG-1与其无法比拟的）。 *.AVI 它的英文全称为Audio Video Interleaved，即音频视频交错格式。是将语音和影像同步组合在一起的文件格式。它对视频文件采用了一种有损压缩方式，但压缩比较高，因此尽管面面质量不是太好，但其应用范围仍然非常广泛。AVI支持256色和RLE压缩。AVI信息主要应用在多媒体光盘上，用来保存电视、电影等各种影像信息。它于1992年被Microsoft公司推出，随Windows3.1一起被人们所认识和熟知。所谓“音频视频交错”，就是可以将视频和音频交织在一起进行同步播放。这种视频格式的优点是图像质量好，可以跨多个平台使用，其缺点是体积过于庞大，而且更加糟糕的是压缩标准不统一，最普遍的现象就是高版本Windows媒体播放器播放不了采用早期编码编辑的AVI格式视频，而低版本Windows媒体播放器又播放不了采用最新编码编辑的AVI格式视频，所以我们在进行一些AVI格式的视频播放时常会出现由于视频编码问题而造成的视频不能播放或即使能够播放，但存在不能调节播放进度和播放时只有声音没有图像等一些莫名其妙的问题，如果用户在进行AVI格式的视频播放时遇到了这些问题，可以通过下载相应的解码器来解决。是目前视频文件的主流。 这种格式的文件随处可见，比如一些游戏、教育软件的片头，多媒体光盘中，都会有不少的 AVI 。现在，在WINDOWS 95或98里都能直接播放AVI，同一种格式的avi文件有可能采用不同的编码方式，最常见的有Intel Indeo（R）Video R3.2（像游戏过场动画等，是目前使用最广泛的一种avi编码技术）、Microsoft video 等。 .RA/RM/RAM .RM，Real Networks公司所制定的音频/视频压缩规范Real Media中的一种，Real Player能做的就是利用Internet资源对这些符合Real Media技术规范的音频/视频进行实况转播。在Real Media规范中主要包括三类文件：RealAudio、Real Video和Real Flash（Real Networks公司与Macromedia公司合作推出的新一代高压缩比动画格式）。REAL VIDEO（RA、RAM）格式由一开始就是定位就是在视频流应用方面的，也可以说是视频流技术的始创者。它可以在用56K MODEM 拨号上网的条件实现不间断的视频播放，从RealVideo的定位来看，就是牺牲画面质量来换取可连续观看性。其实RealVideo也可以实现不错的画面质量，由于RealVideo可以拥有非常高的压缩效率，很多人把VCD编码成RealVideo格式的，这样一来，一张光盘上可以存放好几部电影。REAL VIDEO存在颜色还原不准确的问题，RealVideo就不太适合专业的场合，但RealVideo出色的压缩效率和支持流式播放的特征，使得RealVideo在网络和娱乐场合占有不错的市场份额。 *.MOVMOV格式，美国Apple公司开发的一种视频格式，默认的播放器是苹果的QuickTimePlayer。具有较高的压缩比率和较完美的视频清晰度等特点，但是其最大的特点还是跨平台性，即不仅能支持MacOS，同样也能支持Windows系列,在所有视频格式当中，也许MOV格式是最不知名的。也许你会听说过QuickTime，MOV格式的文件正是由它来播放的。在PC几乎一统天下的今天，从Apple移植过来的MOV格式自然是受到排挤的。它具有跨平台、存储空间要求小的技术特点，而采用了有损压缩方式的MOV格式文件，画面效果较AVI格式要稍微好一些。到目前为止，它共有4个版本，其中以 4.0 版本的压缩率最好。这种编码支持16位图像深度的帧内压缩和帧间压缩，帧率每秒10帧以上。现在这种格式有些非编软件也可以对它时行处理，其中包括ADOBE公司的专业级多媒体视频处理软件AFTEREFFECT和PREMIERE。 *.ASF ASF (Advanced Streaming format高级流格式)。ASF是MICROSOFT 为了和现在的 Real player 竞争而发展出来的一种可以直接在网上观看视频节目的文件压缩格式。ASF使用了MPEG4的压缩算法，压缩率和图像的质量都很不错。因为ASF是以一个可以在网上即时观赏的视频“流”格式存在的，所以它的图像质量比VCD差一点点并不出奇，但比同是视频“流”格式的RAM格式要好。 ASF支持任意的压缩/解压缩编码方式，并可以使用任何一种底层网络传输协议，具有很大的灵活性。ASF流文件的数据速率可以在28.8Kbps到3Mbps之间变化。用户可以根据自己应用环境和网络条件选择一个合适的速率，实现VOD点播和直播。 *.WMV WMV是微软推出的一种流媒体格式，它是ASF的升级延伸，在同等视频质量下，WMV格式的体积非常小，因此很适合在网上播放和传输。微软希望用其取代QuickTime之类的技术标准以及WAV、AVI之类的文件扩展名。WMV的主要优点在于：可扩充的媒体类型、本地或网络回放、可伸缩的媒体类型、流的优先级化、多语言支持、扩展性等。 *. NAVI 如果你发现原来的播放软件突然打不开此类格式的AVI文件，那你就要考虑是不是碰到了n AVI。n AVI是New AVI 的缩写，是一个名为Shadow Realm的地下组织发展起来的一种新视频格式。它是由Microsoft ASF压缩算法的修改而来的（并不是想象中的AVI），视频格式追求的无非是压缩率和图像质量，所以NAVI为了追求这个目标，改善了原始的ASF格式的一些不足，让 NAVI 可以拥有更高的帧率。可以这样说，NAVI是一种去掉视频流特性的改良型ASF格式。 *.FLV FLV 是 FLASH VIDEO的简称，是由Macromedia公司开发的属于自己的流式视频格式。FLV也就是随着Flash MX的推出发展而来的视频格式，是在sorenson公司的压缩算法的基础上开发出来的。FLV格式不仅可以轻松的导入Flash中，速度极快，并且能其到保护版权的作用，并且可以不通过本地的微软或者REAL播放器播放视频。Flash MX 2004对其提供了完美的支持，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。 视频文件转换：比较常见的视频格式转化有： RM→ASF AVI→RMVB dat–&gt;divx mpg–&gt;divx vcd–&gt;rm dat–&gt;rm mpg,dat、avi、mov–&gt;rm *–&gt;FLV 最近视频博客的兴起，导致了flv的快速发展 AVI→MPEG(MPEG－1) 例如有纪念性的家庭录影带，可以事先转换成AVI格式，再用软件将它转换成MPEG－1格式，然后用刻录器将MPEG－1格式文件刻录光盘片，得到的就是普通的VCD光盘了，可以拿到任何VCD播放器上播放。 MPEG(MPEG－1)→AVI 从MPEG到AVI文件之间的转换，为磁盘节省空间。 MPEG(MPEG－1)→ASF 将vcd文件转码后实现VOD点播和直播。 ASF→MPEG(MPEG－1) 由于ASF视频格式的先天限制，一般来说它的图像质量往往比不上MPEG－1，所以转换之前，请三思而后行。 DVD(MPEG－2)→VCD (MPEG－1) 由于DVD驱动器尚未普及以及DVD光盘成本昂贵等客观原因，DVD影片一直未能像VCD一样流行。但我们可以将喜爱的DVD影片转换成MPEG－1格式的视频文件，留在硬盘上观看或是刻成VCD光盘。 dat/mpg-&gt;mp3 CD–&gt;wav,mp3,wma rm–&gt;mp3 mp3–&gt;wma 以上列举的视频格式转化都是比较常见的，当然了，说到底，是有这方面的实际应用需求才会出现这方面的视频转化需要。比如说，要把一部VCD（也就是MPEG1编码的视频文件）制作成可以在线观看的影片，最大的瓶颈就在于文件尺寸的改变，并且要能够适应网络的特点，这样原始的格式就不能满足需 要，必须要转化成互联网视频播放规范的流媒体格式才可以，比如说是RM或者ASF，这就是需要，所以针对影像格式转化为流媒体格式的软件也就应用而生了，还有现在非常流行的MPEG4视频压缩技术，它能够把一张DVD压缩到一张CD上去，并且视频效果也不会有太大的变化，至少在我们普通用户看来也是非常不错的，而文件体积则大大减小了，这就要求有能够把DVD转化成MPEG4文件的软件出现，但是如果有人想要把RM转化成MPEG1（VCD），就没有太大的实际意义了，因为这样并不能给视频效果带来太大的提升，反而文件尺寸大了许多，所以我们很少能够看到这样的转化软件，其他的也类似，所以，在视频转化领域，可以参照以下两个原则：1 有明确的应用方向：就是说一种视频格式转化成另一种视频格式，必须要有明确的应用方向，即目标格式能够有很广泛的应用价值，而不是说为了转化而转化，比如上文所说的VCD-&gt;RM，它的应用方向就是网络播放，因为现在在线电影是一个很大的市场和网络的应用方向。2 能够提升播放价值： 就是说一种视频格式转化成另一种视频格式除了有明确的应用方向外，还要考虑转化是不是有价值，如果说转化后的文件播放效果没有明显提升，但是文件尺寸却大了一倍，我想这样亏本的买卖是没有人会去做的，RM转化成VCD就没有实际的意义，原因如前文所述，而DVD转化成MPEG4价值就很大，不说转化后的播放效果，单说成本就降低了不少。 音视频压缩编码标准：多媒体编辑码方式就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式，现在主要的编码方式有： MPEG系列： 视频编码方面主要是Mpeg1、Mpeg2、Mpeg4、Mpeg4 AVC；音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3、MPEG-2 AAC、MPEG-4 AAC等等。 注意：DVD音频没有采用Mpeg的 H.26X系列：包括H261、H262、H263、H263+、H263++、H264 微软windows media系列：视频编码有Mpeg-4 v1/v2/v3、Windows Media Video 7/8/9/10；音频编码有Windows Media audeo v1/v2/7/8/9 Real Media系列： 视频编码有RealVideo G2、RealVideo 8/9/10；音频编码有RealAudio cook/sipro、RealAudio AAC/AACPlus等 QuickTime系列： 视频编码有Sorenson Video 3、Apple MPEG-4、Apple H.264；音频编码有QDesign Music 2、Apple MPEG-4 AAC 其它，如：Ogg、On2-vpx、flash vidio，以及M-JPEG视频压缩方式 各视频编码的应用场合简要：http://blog.csdn.net/luchy/archive/2007/03/27/1542478.aspx这里讲的挺详细的 Mpeg1较早的视频编码，质量比较差，主要用于 CD-ROM 存储视频，国内最为大家熟悉的就是 VCD（Video CD），他的视频编码就是采用 MPEG-1； 在 MPEG-1 的基础上开发的一种视频编码，它的质量远远好于 MPEG-1，所以被运用在了 DVD-Video 上面，MPEG-2 是 DVD-Video 唯一指定的视频编码。MPEG-2 不光运用于 DVD-Video ，现在大部分 HDTV（高清电视）也采用 MPEG-2 编码，分辨率达到了 1920x1080。 MPEG-3是MPEG组织制定的视频和音频压缩标准。本来的目标是为HDTV提供20-40Mbps视频压缩技术。在标准制定的过程中，委员会很快发现MPEG-2可以取得类似的效果。随后，MPEG-3项目停止了。 MPEG-4是为了适应网络的需求，采用一系列新技术，以最少的数据获得最佳的图像质量为目标的新一代编码方式。主要应用在数字电视、动态图像、互联网、实时多媒体监控、移动多媒体通信、Internet／intranet上的视频流与可视游戏、DVD上的交互多媒体应用等方面。Divx，xvid，ms mpeg4都是采用mpeg-4视频编码的。对于普通用户来说，MPEG-4在目前来说最有吸引力的地方还在于它能在普通CD-ROM上基本实现DVD的质量；用MPEG-4压缩算法的ASF(Advanced Streaming format，高级格式流)可以将120分钟的电影压缩为300MB左右的视频流；采用MPEG-4压缩算法的DIVX视频编码技术可以将120分钟的电影压缩600MB左右 Mpeg4 AVC和 MPEG-4 是两种不同的编码，主要是在极低码率下 MPEG-4 表现并不好，而 AVC 更加适合低带宽传输。在高码率上，AVC 的表现也要好过 MPEG-4，所以现在大有取代 MPEG-4 的趋势。下一代 HD DVD 和 Blue Ray Disc 已经正式接纳 AVC 为视频编码方案之一，相信 AVC 的发展前途会非常好。AVC/H.264极有可能成为下一代视频格式，（avs，中国标准） H.261是ITU-T为在综合业务数字网(ISDN)上开展双向声像业务(可视电话、视频会议)而制定的，它是最早的运动图像压缩标准，它详细制定了视频编码的各个部分，包括运动补偿的帧间预测、DCT变换、量化、熵编码，以及与固定速率的信道相适配的速率控制等部分。 H.262是由ITU-T的VCEG组织和ISO/IEC的MPEG组织联合制定的，所以制定完成后分别成为了两个组织的标准，正式名称是”ITU-T建议H.262”和”ISO/IEC 13818-2”。这两个标准在所有的文字叙述上都是相同的。 H.263是ITU-T为低于64kb/s的窄带通信信道制定的视频编码标准，它是在H.261基础上发展起来的 H263+是H.263 的第二个版本，加入了许多新技术来扩展 H.263 的应用范围。 10.H.263++是在 H.263+ 上增加了几个选项，来增强码流在恶劣信道上的抗误码性能，同时提高增强编码效率。 11.H.264也就是前面提到的 MPEG-4 AVC。H.264是由ISO/IEC与ITU-T组成的联合视频组(JVT)制定的新一代视频压缩编码标准。在ISO/IEC中该标准命名为AVC (Advanced Video Coding)，作为MPEG-4标准的第10个选项；在ITU-T中正式命名为H.264标准。 12.Microsoft MPEG-4 v1/v2/v3，最早的 ASF 采用的视频编码，基于 MPEG-4 技术开发，DivX3.11 就是基于 Microsoft MPEG-4 v3 破解出来的，后来才进行了重写。 13.Windows Media Video 7，Microsoft 正式开发的第一个 Windows Media Video，开始脱离了 MPEG-4，和 MPEG-4 不兼容，从这一点上可见微软的野心。可惜这个版本压缩效果非常烂，打破了微软一飞冲天的美梦，不过它在压缩速度上非常快，现在网络上有很多采用这种格式压缩的 WMV。 14.Windows Media Video 8，在 WMV7 基础上改进的版本，质量上面进不了不少 15.Windows Media Video 9，微软的重头戏，不光是这一个编码，V9 系列更是一个平台，让微软有足够的能力挑战 MPEG，ITU 等标准化组织。虽然这个版本并没有微软吹得那么厉害，特别是低码率下比较差，不过跟以前版本相比进步还是非常多的。特别是 WMV HD 的应用，让微软也跻身视频标准领域。 16.RealVideo G2，早期的 RealVideo 编码，质量比较糟糕，不过那时在网络上算是很先进了，毕竟当时能用网络看视频的人不多。 17.RealVideo 8，随着 RealPlayer 8 推出的视频格式，是现在主流的网络视频编码之一。编码速度较慢，质量也只能算一般。 18.RealVideo 9，RealNetworks 开发的新一代编码，质量进步了很多，特别是在底码率下，而且编码速度很快，做到了速与质的很好统一。 19.RealVideo 10，在 RealVideo 9 基础上加入了一些参数，如 EHQ 等，更加精确控制码率，和 RealVideo 9 兼容。 20.Sorenson Video 3，Sorenson Media 公司随 QuickTime 5 发布的编码器，质量很不错，已经成为 QuickTime 的标准视频编码，网络上大部分电影预告片都采用这种编码。 21.Apple MPEG-4，Apple 公司自己开发的 MPEG-4 编码器，随 QuickTime 6 发布，质量很差。 22.Apple H.264，Apple 公司自己开发的 H.264 编码器，随 QuickTime 7 发布，支持 HDTV。 23.Ogg 是 Xiph.org 基金会发起的一个开放源代码项目，包括视频音频，服务器，传输系统，客户端，硬件支持等，最为大家熟悉的就是音频 Ogg Vorbis，它被认为是迄今为止 128kbps 码率上最好的编码器。 24.On2 VPX系列，On2 公司开发了一系列优秀的视频编码，现在应用得最多的恐怕是 Nullsoft Video 的视频，它们就采用了 VP3，VP5，VP6 视频编码。 25.Flash Video，Macromedia 公司推出的多媒体格式，主要用于在 Flash 中压缩视频。视频采用 Sorenson 公司的 Spark 编码器，音频采用 MP3，质量比较差。传闻下一代 Flash Video 准备使用 On2 VP6 ，那将让视频质量得到一个量的提升。 26.M-JPEG（Motion-JoinPhotographicExpertsGroup）技术即运动静止图像（或逐帧）压缩技术，广泛应用于非线性编辑领域可精确到帧编辑和多层图像处理，把运动的视频序列作为连续的静止图像来处理，这种压缩方式单独完整地压缩每一帧，在编辑过程中可随机存储每一帧，可进行精确到帧的编辑，此外M-JPEG的压缩和解压缩是对称的，可由相同的硬件和软件实现。 各音频编码的应用场合简要： MPEG Audio Layer 1典型数据压缩率是1：4，即每个立体声信号为384 kbps MPEG Audio Layer 2典型数据压缩率是1：4—1：8，即每个立体声信号为256到192 kbps。MPEG Audio Layer1/2主要用于vcd，svcd的音频编码 MPEG Audio Layer 3，也就是大名鼎鼎的mp3，已经成为网络音频的主流格式，能在128kbps的码率下接近cd音质。典型数据压缩率是1：10—1：12，即每个立体声信号为128到112 kbps MPEG-2 AAC（Advanced Audio Coding）是在1997年由以Bosi、Brandenburg、Johnston等为首的音频编码研究提出的，它总结了MPEG-1、MPEG-2和AC-3等的长处，在MPEG 系统上进一步改进了很多新的功能，大大增强了编码的灵活度，在保证音质的同时更大限度地压缩了码率。它和传统的mpeg audio不兼容，在理论上质量要高于mp3，并且支持多声道，在96kbps的码率范围内能接近cd音质，比mp3更加适合低码率传输；同时，MPEG-2 AAC已经成为MPEG-4标准中高质量音频编码的核心，是下一代音频压缩标准。 MPEG-4 AAC：是MPEG-4标准音频编码标准的一部分，apple公司自己开发有这种 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布 杜比数字AC-3技术也就是5.1声道技术 Windows Media Audio v1/v2，微软最早的音频编码技术，用于 ASF 中，后来被破解也用在 DivX Audio 中，质量比较差。 Windows Media Audio 7/8/9，随着各种不同的 WMV 而推出的相应的音频编码，质量节节提升，不过还没有达到 64kbps CD音质的神化 Windows Media Audio 9 Professional，WMA9 中出现的新编码，主要用于多声道编码和高采样率音频的编码，质量不错。 RealAudio Cook，早期的音频编码，但是在现在看来，仍然质量不错，可惜最高码率 96kbps。应用到了两代音频编码中：RealAudio G2、RealAudio 8。 RealAudio Sipro，采用了 Sipro 语音编码技术，主要针对语音编码，应用在更早期的 RealAudio 4.0、RealAudio 5.0 中。 RealAudio AAC，AAC 音频编码，用于 RealAudio 10 中。 RealAudio aacPlus，aacPlus 音频编码，用于 RealAudio 10 中，不过并没有随 RealProducer 发行，需要单独购买。 QDesign Music 2，QDesign Music 的第二个版本，也是最后一个版本，在时下这些先进的音频编码面前，它已经没有生命力了，主要应用于网上的电影预告片。 Apple MPEG-4 AAC，Apple 公司自己开发的 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布。 四种主流的视频压缩编码标准：1、Windows Media Video 9 相比起其他三种图像压缩技术，WMV可能是使用率最高的视频编码格式。原因十分简单，如果想使自己的影片直接给网上其他用户观看到的话，利用微软自身的视频编码标准是最简单的做法。因为只要用户的电脑中有Windows Media Player(媒体播放器)，就能够播放WMV影片，而且不用额外安装Codec（编码），所以兼容性方面完全不用担心。借助Windows Media 9.0 Series的新技术，Windows Media Video 9.0比旧的8.0版有多达15-50%的压缩率提高。而且与MPEG-4画质相比时，其容量大小只需一半即可达到。加上配合Windows Media Service 9.0服务器，在Streaming media（流媒体）方面也有更佳的表现。 官方网站：http://www.microsoft.com 2、Real Video 9 玩电脑时间长的朋友都知道，Real Video是多年前市场上最普及的音乐、图像格式。不过随着MP3、WMV及WMV等的兴起，已经使Real Media格式的普及率大不如前。但现在全世界仍然有许多的电脑玩家是Real Video的支持者，网上供下载的影片很多也是RM或RMVB格式。 RealNetwork新推出了一套名为Helix Producer的工具（也就是Real Producer 9），其中的RealVideo 9在图像压缩编码技术方面作出重大优化，无论在下载或Streaming时都声称比Windows Media 9出色，能够以一半的比特速率（bitrate）达到MPEG-4级图像，在约500 Kbps时达到接近DVD的画质表现。同样地，配合服务器可获得更出色的效果。 官方网址：http://www.realnetworks.com 3、DivX 历史介绍： ISO公布了“超低比特率活动图像和语音压缩标准 ”，排序MPEG－4,1998年10月批准第一版，1994年4月又公布了第二版及其校验模型（VM），MPEG－4正式编号是ISO/IEC国际标准14496，它是一种新型的多媒体标准，它与前标准一个重要区别就在于，是一个基于对象的视编码压缩标准，所定义的码率控制的目标就是获得在给定码率下的最优质量，它为互联网上传输高质量的多媒体视频提供了很好的技术平台。 1998年微软开发了第一个在PC上使用的MPEG－4编码器，它包括MS MPEG4V1、MS MPEG4V2、MS MPEG4V3的系列编码内码，其中V1和V2用来制作AVI文件，一直到现在它都是作为Windows的默认组件，不过V1和V2的编码质量不是很好，一直到MS MPEG4V3才开始有好转，画质有了显著的进步，但是不知微软出于什么目的，却将这个MS MPEGV3的视频编码内核封闭，仅仅使其应用于Windows Media流媒体技术上，也就是我们熟悉的ASF流媒体文件中。ASF文件虽然有一些优势，但是由于过分的封闭不能被编辑，末得到广泛应用，这便惹怒了那些个不怕天不怕地的视频黑客和致力于钻研视频编码的高手，后来，这些小组不仅破解了微软的视频编码，而且经过他们的修改，一种新的视频编码诞生了：那就是广为流传的MPEG编码器－DivX3.11。 DivX采用了MS的MPEGV3，改良后并加入自己功能称之为DivX3.11，也是目前互联网上普通采用的MPEG－4编码器之一。很快，DivX被传得红得发紫，几乎成了业界的标准，但是，同样很快地出现了，DivX的基础技术是非法盗用微软的，微软声称将对所有推动DivX发展的人、企业进行追究，可是DivX技术的创造者之一罗达（Rota）正全面申请将DivX合法化，这是基于DivX虽然是从Window的发明出来的，但却没有用过任何微软的技术，更组建新公司DivXNetworks全力推广DivX，看来DivX（俗称压缩电影）蓬勃发展的大潮是势不可挡了。 看来任何吸引眼球的故事在关键时刻都会发生转折，DivX的发展竟也不能脱离这一俗套，就在DivX顺利发展时期，DivX的技术逐渐成熟，商机无限的时候，一台好戏上演了，DivXNetworks成立初衷就是摆脱微软的技术封闭，因而发起一个完全开放源码的项目，名为 “ Projet Mayo ”，目标是开发一套全新的、开放源码的MPEG4编码软件，由于它完全符合ISO MPEG标准，又是完全开放源代码，OpenDivXCODEC吸引了很多软件，视频高手参与，很快便开发出具有更高性能的编码器Encore2等等，就在DivX最辉煌的时期，DXN公司突然封闭了DivX的源代码，并在Encore2的基础上发布了自有产品DivX4，原来DXN早就给自己留了后门，DivX采取的是LGPL协议，而不是GPL协议，虽说它们都是公共许可证协议，保障自由使用和修改软件或源码的权利，但LGPL允许私有，DXN就是利用这一协议初其不备的耍出了大刀。 接着，很多被DXN公司狠狠涮了一回的软件、视频团体另起门户，逐渐重新聚拢开发力量，高举复仇大旗，在OpenDivX版本基础上，再次开发出一种新的MPEG－4编码–XviD，名字的顺序和DviX刚好相反，仅仅从名字就可以看出Xvid充满了复仇的力量。 DivX是近一两年来称霸网络视频的图像压缩编码标准。起初它是以微软MPEG 4视频编码标准为基础修改和开发的，并以免费方式发布。其特点是具有十分不错的压缩比率，可以将一整套DVD质量的影片压缩存放到一张CD-R光盘中。现在的DivX分为普通版和Pro版，其中后者还有收费版和Adware（广告）版两种，自带DivX Player程序进行播放。用户如果安装了免费的DivX Codec后，也可用Windows Media player观看DivX影片。 官方网站：http://www.divx.com 4、Koepi’s XviD Codec 相比起前三种视频编码标准来说，Xvid推出市场的时间最迟。从其名字就知道这种标准是针对DivX而来的。原来，DivX由免费转为收费编码后，使部份原有开发人员不满，继而离开并组成一个新的开发小组，设计免费且开放源代码的XviD Codec。当前，Koepi和Nic的XviD都是比较活跃和最多人使用的版本，虽然两者在编译上有所不同，但实际做出的效果相差无几。Xivd与DivX一样，在编译后都是一个.AVI文件，播放时只要安装Xvid codec就能用Windows媒体播放器中播放。 官方网站：http://roeder.goe.net/~koepi 视频压缩基本概念：一、有损和无损压缩：在视频压缩中有损（Lossy）和无损（Lossless）的概念与静态图像中基本类似。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息，而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩，这样才能达到低数据率的目标。丢失的数据率与压缩比有关，压缩比越小，丢失的数据越多，解压缩后的效果一般越差。此外，某些有损压缩算法采用多次重复压缩的方式，这样还会引起额外的数据丢失。 二、帧内和帧间压缩：帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩时各个帧之间没有相互关系，所以压缩后的视频数据仍可以以帧为单位进行编辑。帧内压缩一般达不到很高的压缩。 采用帧间（Interframe）压缩是基于许多视频或动画的连续前后两帧具有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息，根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。 三、对称和不对称编码：对称性（symmetric）是压缩编码的一个关键特征。对称意味着压缩和解压缩占用相同的计算处理能力和时间，对称算法适合于实时压缩和传送视频，如视频会议应用就以采用对称的压缩编码算法为好。而在电子出版和其它多媒体应用中，一般是把视频预先压缩处理好，尔后再播放，因此可以采用不对称（asymmetric）编码。不对称或非对称意味着压缩时需要花费大量的处理能力和时间，而解压缩时则能较好地实时回放，也即以不同的速度进行压缩和解压缩。一般地说，压缩一段视频的时间比回放（解压缩）该视频的时间要多得多。例如，压缩一段三分钟的视频片断可能需要10多分钟的时间，而该片断实时回放时间只有三分钟。 第三部分：音频文件格式 一些音视频的参数含义:声道：目前人们所使用的各种声场技术规范非常多，但最常见的几乎都来自三家公司，他们是Dolby（杜比）、HTX和DTS。声卡所支持的声道数是衡量声卡档次的重要指标之一，从单声道到最新的环绕立体声，下面一一详细介绍：1.单声道：单声道是比较原始的声音复制形式，早期的声卡采用的比较普遍。当通过两个扬声器回放单声道信息的时候，我们可以明显感觉到声音是从两个音箱中间传递到我们耳朵里的。这种缺乏位置感的录制方式用现在的眼光看自然是很落后的，但在声卡刚刚起步时，已经是非常先进的技术了。2.立体声：单声道缺乏对声音的位置定位，而立体声技术则彻底改变了这一状况。声音在录制过程中被分配到两个独立的声道，从而达到了很好的声音定位效果。这种技术在音乐欣赏中显得尤为有用，听众可以清晰地分辨出各种乐器来自的方向，从而使音乐更富想象力，更加接近于临场感受。立体声技术广泛运用于自Sound Blaster Pro以后的大量声卡，成为了影响深远的一个音频标准。时至今日，立体声依然是许多产品遵循的技术标准。3.准立体声：准立体声声卡的基本概念就是：在录制声音的时候采用单声道，而放音有时是立体声，有时是单声道。采用这种技术的声卡也曾在市面上流行过一段时间，但现在已经销声匿迹了。4.四声道环绕：人们的欲望是无止境的，立体声虽然满足了人们对左右声道位置感体验的要求，但是随着技术的进一步发展，大家逐渐发现双声道已经越来越不能满足我们的需求。由于PCI声卡的出现带来了许多新的技术，其中发展最为神速的当数三维音效。三维音效的主旨是为人们带来一个虚拟的声音环境，通过特殊的HRTF技术营造一个趋于真实的声场，从而获得更好的游戏听觉效果和声场定位。而要达到好的效果，仅仅依靠两个音箱是远远不够的，所以立体声技术在三维音效面前就显得捉襟见肘了，但四声道环绕音频技术则很好的解决了这一问题。四声道环绕规定了4个发音点：前左、前右，后左、后右，听众则被包围在这中间。同时还建议增加一个低音音箱，以加强对低频信号的回放处理(这也就是如今4.1声道音箱系统广泛流行的原因)。就整体效果而言，四声道系统可以为听众带来来自多个不同方向的声音环绕，可以获得身临各种不同环境的听觉感受，给用户以全新的体验。如今四声道技术已经广泛融入于各类中高档声卡的设计中，成为未来发展的主流趋势。5.5.1声道5.1声道已广泛运用于各类传统影院和家庭影院中，一些比较知名的声音录制压缩格式，譬如杜比AC-3（Dolby Digital）、DTS等都是以5.1声音系统为技术蓝本的。其实5.1声音系统来源于4.1环绕，不同之处在于它增加了一个中置单元。这个中置单元负责传送低于80Hz的声音信号，在欣赏影片时有利于加强人声，把对话集中在整个声场的中部，以增加整体效果。相信每一个真正体验过Dolby AC-3音效的朋友都会为5.1声道所折服。千万不要以为5.1已经是环绕立体声的顶峰了，更强大的7.1系统已经出现了。它在5.1的基础上又增加了中左和中右两个发音点，以求达到更加完美的境界。由于成本比较高，没有广泛普及。 一.WMA WMA的全称是Windows Media Audio，是微软力推的一种音频格式。WMA格式是以减少数据流量但保持音质的方法来达到更高的压缩率目的，其压缩率一般可以达到1:18，生成的文件大小只有相应MP3文件的一半。此外，WMA还可以通过DRM（Digital Rights Management）方案加入防止拷贝，或者加入限制播放时间和播放次数，甚至是播放机器的限制，可有力地防止盗版。 优点WMA 7之后的WMA支持证书加密，未经许可（即未获得许可证书），即使是非法拷贝到本地，也是无法收听的。同时，微软公司开始时宣称的：同文件比MP3体积小一倍而音质不变，也得到了兑现。事实上，这个说法，仅仅适用于低比特率的情况，另外，微软公司在WMA 9大幅改进了其引擎，实际上几乎可以在同文件同音质下比相同的MP3体积少1/3左右。缺点在高比率的渲染能力低下，同音源的一个320KBPS的MP3与比较192KBPS的WMA相比，音质和渲染力很容易分别出是前者较优。 二.VQF VQF即TwinVQ（Transform－domain Weighted Interleave Vector Quantization），是由NTT（Nippon Telegraph and Telephone）与Yamaha共同开发的一种音频压缩技术。VQF的音频压缩率比标准的MPEG音频压缩率高出近一倍，可以达到18:1左右甚至更高。也就是说把一首4分钟的歌曲（WAV文件）压成MP3，大约需要4MB左右的硬盘空间，而同一首歌曲，如果使用VQF音频压缩技术的话，那只需要2MB左右的硬盘空间。因此，在音频压缩率方面，MP3和RA都不是VQF的对手。 但是VQF不支持”流”，这可能也是为什么现在它完全被WMA压下去的一个主要原因. 三.MP3MP3的全称是Moving Picture Experts Group Audio Layer III。简单的说，MP3就是一种音频压缩技术，由于这种压缩方式的全称叫MPEG Audio Layer3，所以人们把它简称为MP3。MP3是利用MPEG Audio Layer 3的技术，将音乐以1:10甚至1:12 的压缩率，压缩成容量较小的file，换句话说，能够在音质丢失很小的情况下把文件压缩到更小的程度。而且还非常好的保持了原来的音质。正是因为MP3体积小，音质高的特点使得MP3格式几乎成为网上音乐的代名词。每分钟音乐的MP3格式只有1MB左右大小，这样每首歌的大小只有3-4兆字节。使用MP3播放器对MP3文件进行实时的解压缩(解码)，这样，高品质的MP3音乐就播放出来了。 MP3最受争议的就是音质问题(尤其是随着WMA的普及)，其高频损失很大，很多MP3编码器粗糙的编码算法不但导致高频丢失，还丢失了许多细节，类似吉他擦弦的感觉在MP3中是找不到的.在对MP3快要失望时，偶发现了Lame,它支持根据人耳遮蔽效应原理来分析波形，配合VBR技术，可以让音质达到令人吃惊的地步;其独创的心理音响模型技术保证了CD音频还原的真实性，配合VBR(动态比特率)和ABR(平均比特率)参数，编码出来的MP3音色纯厚、空间宽广、低音清晰、细节表现良好,音质几乎可以媲美CD音频，但文件体积却非常小.很多网友在使用LAME后的反映就是：立刻删除硬盘上所有的MP3和其他编码器，全部用Lame重新来过。Lame提供EXE和DLL，其中DLL是作为标准的动态运行库供其他程序调用.EXE是Command Line程序，象DOS程序一样工作，两者彼此独立，互不关联。但大家很快能发现两者编码的质量是不一样的,那是由于dll可控性差，与具备丰富调节参数的EXE版相比，其压缩出来的MP3效果稍逊一筹。但EXE是一个命令行工具，操作很麻烦，幸亏有了WinLAMEr或lameGUIxp这些Shell。只要学会使用这些Shell(是傻瓜型的,一看即会)，就可以用LAME压缩出最最精彩的MP3了。再说说APS,在LAME出现以前，APS就是最好的MP3编码器，它使用的Fraunhofer IIS编码算法，这比LAME使用的编码算法要先进，在192k Bitrate(CBR)下，甚至比LAME编码的曲子要优秀，细节明显要丰富一些，但APS本身不支持VBR，当Bitrate往上提高时，音质就要比LAME编码的要差了，大部分朋友的MP3的一般都是128-192K Bitrate的，因此APS仍旧有推荐的价值。特别是有很多MP3随身听不支持VBR和256K Bitrate以上的MP3，LAME就不一定合适这些朋友了，APS就成了不错的选择，由它编码的曲子，绝对不会辱没你昂贵的PLAYER. 四.MP3PRO MP3PRO完全是基于传统MP3编码技术的一种改良，本身最大的技术亮点就在于SBR(Spectral Band Replication频段复制),这是一种新的音频编码增强算法.它提供了改善低位率情况下音频和语音编码的性能的可能.这种方法可在指定的位率下增加音频的带宽或改善编码效率,SBR最大的优势就是在低数据速率下实现非常高效的编码.如果在高数据速率的情况下，SBR将如同虚设.当制作MP3PRO文件时，编码器将音频分为两部分。一部分是将音频数据中的低频段部分分离出来，通过传统的MP3技术而编码得出的正常的MP3音频流，此举可令到MP3编码器可以专注于低频段信号从而获得更好的压缩质量，而且原来的MP3播放器也可播放MP3PRO文件。另一部分则是将分离出来的高频段信号进行编码并嵌入到MP3流中，传统的MP3播放器会将其忽略掉，而新的MP3PRO播放器则可从中还原出高频信号，并将两者进行组合，得到高质量的全带宽的声音.官方宣称通过这样的技术，使得MP3PRO能在64kbps的编码率便可提供与128kbps的mp3相同的质量。低比特率下MP3PRO的性能很明显地比MP3要高,但是它与WMA谁胜谁负就很难说了,根据一些发烧友的评测, MP3PRO似乎略胜一些.高比特率下很少有人用到MP3PRO. 五.OGG OGG格式的全称应该是OGG Vobis。它是一种新的音频压缩格式，类似于MP3等现有的音乐格式。但有一点不同的是，它是完全免费、开放和没有专利限制的。OGG Vobis有一个很出众的特点，就是支持多声道，随着它的流行，以后用随身听来听DTS编码的多声道作品将不会是梦想。OGG Vobis在压缩技术上比MP3好，而且它的多声道，免费，开源这些特点，使它很有可能成为一个流行的趋势，这也正是一些MP3播放器对其支持的原因 在高音质要求下,有损音频编码世界中是三足项立，分别为MP3、MPC、OGG。 Ogg Vorbis中的主要算法还是利用MDCT（修饰离散余弦变换Modified Discrete Cosine Transform ）而不是用现在比较时兴的小波（wavelet）技术。Ogg的多通道编码技术，统称为立体声通道耦合Stereo Channel Coupling。而该技术实际又是由两种不同的技术组成的：channel interleaving 和 square polar mapping，而这也是Ogg能成为免费制式的一个必要条件，以往的“联合立体声Joint Stereo”的编码模式是有专利限制的。据官方声称，与其他会造成立体空间感减弱的编码模型相比，这两种技术都可以在保持编码器的灵活性的同时而不损害本来的立体声空间影像――相信配合iRiver的3d音效会有更好的表现力，而且实现的复杂程度比联合立体声方式要低。 OGG Vorbis这种编码也远比90年代开发成功的MP3先进，它可以在相对较低的数据速率下实现比MP3更好的音质！――我认为Ogg很象MD的atrac格式，特别象新的lp2编码，它能在低别特率下有着很要的音质。此外，在编码上，Ogg Vorbis是使用了VBR（可变比特率）和ABR（平均比特率）方式进行编码，所以理论上，Ogg Vorbis带来的音乐可以比采用CBR文件有更好的声音表现，当然前提是两者使用同样比特率(Bit Rate)的压缩模式――这里可以知道。Ogg Vorbis的比特率缩放功能可以在不用重新编码的情况下调节文件的相关压缩率，与此同时，Ogg文件的单位编辑能力和超越左右声道的音频流技术可以带来更为奇妙的音乐享受。Vorbis还具有比特率缩放功能，可以不用重新编码便可调节文件的比特率。 Vorbis文件可以被分成小块并以样本粒度（granularity，专业术语，指数据可以被分割的最小尺寸）进行编辑；Vorbis支持多通道（大于2）音频流并使用了独创性的处理技术；这意味着什么？这意味着Ogg Vorbis在SACD、DTSCD、DVD AUDIO抓轨软件（目前这种软件还没有）的支持下，可以对所有的声道进行编码，而不是MP3只能编码2个声道。多声道音乐的兴起，给音乐欣赏带来了革命性的变化，尤其在欣赏交响时，会带来更多临场感。这场革命性的变化是MP3无法适应的。在以后的播放技术不断提高以后，而且人们对音质要求不断提高，Ogg的优势将更加明显。 六. MPC MusePaCk是由德国人Andree Buschmann开发的一种完全免费的高品质音频格式。在其问世之前，Lame MP3是公认音质最好的有损压缩方案，追求音质的人对它趋之若鹜。但现在这个桂冠无疑该让给MPC了，在中高码率下，MPC可以做到比MP3更好音质。在高码率下，MPC的高频要比MP3细腻不少，可以在节省大量空间的前提下获得最佳音质的音乐欣赏，是目前最适合用于音乐欣赏的有损编码。 MPC的编码方案是在MP2的基础上改进而来。它同样采用子带编码技术，但相比MP2，它所采用的心理声学模型要优秀得多，并加入了像ANS（Adaptive Noise Shaping）、CVD(ClearVoiceDetection)等技术，甚至改变了压缩时所用的Huffman（哈夫曼）编码，以得到更大的压缩率。另外，MPC采用的是可变码率进行编码。毫无疑问，可变码率的编码效率要高于固定码率，因为前者可以合理地分配数据量，在信号复杂（微弱）时提高（降低）比特率，在得到满意的效果又能确保不错的压缩率。为了保证高音质，MPC的瞬间最大码率甚至高达1.32Mbps，这已经快接近CD的1.41Mbps了 较高比特率下(250kbps左右),MPC表现非常的出众,甚至超过了MP3，很难分辨它和原始信号有多少区别，无论从频率保留还是细节保留，以及信号强度失真来说，MPC太优秀了.但MPC并非万能的，它无法编码48khz采样率的曲子，所幸的是，这样的曲子来源很少.可惜这种格式并没有像MP3或WMA那样流行. 七.ATRAC ATRAC（Adaptive TRansform Acoustic Coding自适应声学转换编码技术）：是Sony的原创音乐压缩技术，主要用于MD Walkman的录音及播放方面。是一项基于听觉心理学领域的研究和不损伤可闻声质量的数码音频译码压缩技术，对音乐资讯有效的进行压缩，压缩的比率为原来的五分之一，因为MD使用了ATRAC压缩技术，这样的压缩大大节省了许多空间，所以 CD的碟片要120mm大小，而MD只需64mm就可以录下74分钟的音乐。 ATRAC压缩技术主要是利用了人耳的蔽遮效应，在心理声学原理上，在进行音频录入的同时，有许多外部的频段同时也会被录入，当人耳同时听到两个不同频率、不同音量的声音时，音量较小的低频及音量较小的高频连同不为人耳所察觉的频段信号都会被自动减弱或忽略不予记录，因此又可以称为适应性变换声码技术，由于近年來编码压缩技术（ATRAC的版本）越來越成熟，所以经过编码解码过程后的声音仍直逼CD，大家就不必担心音质差啦。 ATRAC将16比特44.1KHz的数字信号以频率响应轴分成52个区段（在低频时分割较细而在高频时分割较粗），根据声音心理学的原理，将声音信号中人耳听不到和对人的听力影响不大的信息给剔除出去而达到缩小声音文件的目的。利用这种原理，ATRAC可以将录音的资料量压缩为原来的五分之一（即压缩比为1：5）。 . 八. APE APE的本质，其实它是一种无损压缩音频格式。庞大的WAV音频文件可以通过Monkey’’s Audio这个软件进行“瘦身”压缩为APE。很时候它被用做网络音频文件传输，因为被压缩后的APE文件容量要比WAV源文件小一半多，可以节约传输所用的时间。更重要的是，通过Monkey’’s Audio解压缩还原以后得到的WAV文件可以做到与压缩前的源文件完全一致。所以APE被誉为“无损音频压缩格式”，Monkey’’s Audio被誉为“无损音频压缩软件”。与采用WinZip或者WinRAR这类专业数据压缩软件来压缩音频文件不同，压缩之后的APE音频文件是可以直接被播放的。 Monkey’’s Audio会向Winamp中安装一个“in_APE.dll”插件，从而使Winamp也具备播放APE文件的能力。 和上面介绍的几款编码不同的是，这个编码提供了最好的音质保证(无损压缩)！还提供了Winamp的插件支持,可以直接用Winamp来播放.所谓无损就是指压缩后的格式和源文件在音质上并无差异，而Mp3、WMA等的编码方案是基于有损的，在损失部分音质的前提下节约存贮空间，所以说音质再好的Mp3、WMA也只能是无限接近源文件的音质。APE非常适合来编码讲究细节的独奏曲目和大动态的交响曲。向各位音乐迷们(不是歌迷)作最强烈的推荐！它的压缩比约为2:1. 九. WAV WAV是录音时用的标准的windows文件格式，文件的扩展名为“.wav”，WAVE文件作为最经典的Windows多媒体音频格式，应用非常广泛。声道有单声道和立体声之分，采样频率一般有11kHz、22kHz和44kHz三种。 WAVE文件所占容量=（采样频率×采样位数×声道）×时间/8（1字节=8bit）。 WAV文件与MIDIMP3这类多媒体声音文件比较起来，所占的硬盘空间要大得多，但WAV文件的回放效果是最好的，WAV文件直接反映了一个声音在每个时刻的大小值，1分钟44khz采样率的WAV文件就会占用10M硬盘空间！ 它通常作为制作高质量音乐的中间体 十.RM Real Networks公司所制定的音频视频压缩规范称为Real Media，用户可以使用RealPlayer或RealOne Player对符合RealMedia技术规范的网络音频/视频资源进行实况转播并且RealMedia可以根据不同的网络传输速率制定出不同的压缩比率，从而实现在低速率的网络上进行影像数据实时传送和播放。这种格式的另一个特点是用户使用RealPlayer或RealOne Player播放器可以在不下载音频/视频内容的条件下实现在线播放。另外，RM作为目前主流网络视频格式，它还可以通过其Real Server服务器将其它格式的视频转换成RM视频并由Real Server服务器负责对外发布和播放。RM和ASF格式可以说各有千秋，通常RM视频更柔和一些，而ASF视频则相对清晰一些。 RM格式一开始就定位在视频流应用方面，也可以说是视频流技术的始创者。它可以在用56 K Modem拨号上网的条件下实现不间断的视频播放，当然，其图像质量和MPEG2，DIVX等相比有一定差距，毕竟要实现在网上传输不间断的视频是需要很大带宽的。 RM已经是昨日黄花，没有任何新意，低Bitrate比不过WMA，高Bitrate比不过MP3，虽然新的RM导入了ATRAC3算法，但颓势已定，很难东山再起了。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>流媒体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC语言基础/runtime]]></title>
    <url>%2F2015%2F07%2F17%2F2015%2FOC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%3Aruntime%2F</url>
    <content type="text"><![CDATA[OC语言基础关于SEL的理解1234567NSLog(@&quot;%d&quot;, @selector(testView));NSLog(@&quot;%d&quot;, @selector(testView1)); NSLog(@&quot;%d&quot;, NSSelectorFromString(@&quot;testView&quot;)); NSLog(@&quot;%p&quot;,@&quot;testView&quot;); 输出 123452018-07-10 17:28:37.378285+0800 Ceshi[18642:3374809] 1650343472018-07-10 17:28:37.378342+0800 Ceshi[18642:3374809] 1650344102018-07-10 17:28:37.378411+0800 Ceshi[18642:3374809] 1650343472018-07-10 17:28:37.378494+0800 Ceshi[18642:3374809] 0x109d65128 这里是一个数字到字符串的映射关系，但也不是简单的地址的映射 self与superself/super objc_msgSend(id,sel) objc_msgSendSuper(struct,sel) 分类做哪些事 声明私有方法 分解庞大的类文件 把framework私有方法公开 为系统类或者老的类进行扩展 分类特点 运行时决议(编译时，分类和宿主没有一毛钱关系) 可以为系统添加分类 最后编译的分类的方法，最先被搜索到，同时在宿主之前，这也就是我们怎么替换宿主的方法的原理 最终分类中的方法是拼接到宿主类中得以被调用的，这也就是为什么分类是运行时决议，这个时候注意，在类的方法列表中我们是正向遍历的，但是拼接的时候是反向遍历拼接的，那么为什么分类可以覆盖宿主方法呢，是因为在进行拼接的时候会讲宿主方法挪到分类方法的后边。 注意:分类中可以直接访问主类中的属性。 但是如果分类中要单独定义属性那么只能依赖runtime，其实主要是成员变量的添加。 但是分类中可以直接添加一个属性，不过它只是一个声明，假如我把主类的属性声明在.m中，这个时候我就可以在分类中再定义一次，这样就可以直接用，这里要注意的是如果我们声明一个扩展是不能被分类所使用的。 分类中都能添加什么内容 实例方法 类方法 协议 属性(定义了一个属性，只声明set和get方法，并没有添加实例变量，变量需要通过关联对象) 分类数据结构 多个分类文件的编译顺序 编译顺序按照这个顺序来的，规则如下: 分类最后编译，其他的类按照这个顺序 分类之间的编译顺序也是按照这个类的 分类中的类方法本质上添加到哪里？未解答关联对象关联对象是否被添加到了宿主类？ 关联对象本质 策略:retain或者copy 用扩展来做什么 声明私有属性 声明私有方法 声明私有变量 声明私有属性 扩展和分类的区别 这个是编译的时候决议 不能为系统类添加扩展 只是以声明的形式存在 代理 代理是一种设计模式 与通知的区别是代理一对一，通知一对多 委托方以weak声明，防止循环引用，代理方用strong声明 通知 用观察者设计模式实现的 一对多 observer中包含观察者对象，和回调的方法 KVOkey-value-observing 观察者模式的实现 使用isa混写技术来实现kvo 通过kvc设置value，kvo能否生效？可以，因为调用了setter方法那么通过成员变量直接赋值能否生效？不能，没有调用setter方法 手动kvo是什么？ kvo能否使用成员变量作为k？可以的，在底层会为其创建setter方法，在其他地方调用或者进行kvc的时候就会调用 kvo使用中的坑 1234-(void)printInfo&#123; NSLog(@&quot;isa:%@, supper class:%@&quot;, NSStringFromClass(object_getClass(self)), class_getSuperclass(object_getClass(self))); 当keyPath是成员变量的时候，确实会调用成功，但是具体的方式却并不是重写set方法，具体是啥有待探究。 123456789- (void)viewDidLoad&#123; [super viewDidLoad]; // “手动触发self.now的KVO”，必写。 [self willChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。 [self didChangeValueForKey:@&quot;now&quot;];&#125; KVO和通知一样，都是同步操作，所以使用的时候要注意 KVCkey-value-coding 是否破坏面向对象编程思想？是的 valueForKey: 有没有get方法，有的话直接返回，如果没有的话，那么去看看有没有相同或者相似的变量存在？这里有一个方法可以禁止这个流程。 Accessor Method: getKey key isKey Instance Var: _key _isKey key isKey setvalueForKey一样的流程和道理 kvc集合运算符 KVC集合运算符号如何使用 必须用在集合对象上活着普通对象的集合属性上 鸡蛋集合运算符号有@avg,@count,@max,@min,@sum 格式@”@sum.age”或者@”集合属性.@max.age” 属性关键字读写 readonly,readwrite 原子性 atomic,nonatomic 引用计数 retain/strong assign/unsafe_unretained weak copy assign/weak区别 assign可以修饰int，bool，也可以修饰对象，weak只能修饰对象 assign修饰的对象被释放后，会导致悬垂指针，weak指针会被置为nil 都不改变引用计数 @property (copy) NSMutableArray *arr;这样声明有啥问题？经过copy修饰都是不可变对象，这是一个深拷贝，只有copy修饰不可变对象才是浅拷贝 浅拷贝增加对象的引用计数，因为多了一个指针指向，深拷贝是产生了一个内存空间，不会影响引用计数。 深拷贝vs浅拷贝区别: 是否开辟新地址，是否影响引用计数 对于可变对象(NSMutableArray/NSMutableDictionay/NSMutableString)这些到底是使用strong还是copy，要看具体场景，比如说A控制跳转到B控制器，传入了一个string，我们里边要单独使用，这个时候就最好使用copy，外边改变不影响里边，里边改变也不影响外边，当然如果本身就是NSString类型就无所谓了，因为这块地址本身就不能改变了，如果传入的是NSMutableString你就不好去控制实际的情况了。但是如果我本身就需要两边数据进行同步，那么肯定我就要用strong来修饰了。 atomic实现在 objc4-723 的 Objective-C runtime 实现中，property 的 atomic 是采用 spinlock_t 也就是俗称的自旋锁实现的。具体代码可以看 objc_accessors.mm，// getter 12345678910111213141516171819202122232425262728id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123; // ... if (!atomic) return *slot; // Atomic retain release world spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); id value = objc_retain(*slot); slotlock.unlock(); // ...&#125;// setterstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; // ... if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; // ...&#125; 面试题 NSCopying协议实现12345678910111213141516171819202122232425262728293031323334353637#import &quot;KaoBei.h&quot;@implementation KaoBei- (id)init &#123; self = [super init]; if (self) &#123; &#125; return self;&#125;- (id)copyWithZone:(NSZone *)zone &#123; KaoBei *instance = [[KaoBei alloc] init]; if (instance) &#123; instance.chanPInName = self.chanPInName; instance.icon = [self.icon copyWithZone:zone]; instance.isParent = [self.isParent copyWithZone:zone]; instance.theSelected = [self.theSelected copyWithZone:zone]; instance.ids = [self.ids copyWithZone:zone]; instance.name = [self.name copyWithZone:zone]; instance.imageUrlStr = [self.imageUrlStr copyWithZone:zone]; &#125; return instance;&#125;- (id)mutableCopyWithZone:(NSZone *)zone &#123; KaoBei *instance = [[KaoBei alloc] init]; if (instance) &#123; instance.chanPInName = self.chanPInName; instance.icon = [self.icon copyWithZone:zone]; instance.isParent = [self.isParent copyWithZone:zone]; instance.theSelected = [self.theSelected copyWithZone:zone]; instance.ids = [self.ids copyWithZone:zone]; instance.name = [self.name copyWithZone:zone]; instance.imageUrlStr = [self.imageUrlStr copyWithZone:zone]; &#125; return instance;&#125; instancetype和id的异同1、相同点都可以作为方法的返回类型 2、不同点①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象； ②instancetype只能作为返回值，不能像id那样作为参数，比如下面的写法： [objc] view plaincopy在CODE上查看代码片派生到我的代码片 123456789101112//err,expected a type - (void)setValue:(instancetype)value &#123; //do something &#125; 就是错的，应该写成：[objc] view plaincopy在CODE上查看代码片派生到我的代码片- (void)setValue:(id)value &#123; //do something &#125; runtime(重点)先了解这四种结构: objc_object objc_class isa指针 method_t objc_objectid == objc_object 包括 isa_t isa相关操作 弱引用相关 关联对象相关 内存管理相关 objc_classClass == objc_class 继承自objc_objct 包括 Class superClass cache_t cache 方法缓存 class_data_bits_t bits 变量，属性和方法都在这 关于Class说明:当我们调用实例方法，实际是通过isa去Class对象中查找的，当我们调用类方法，实际是通过类对象的isa去元类中查找的。 关于cache_t 说明cache_t是一个数组，然后里边每个元素里都有一个key，也即是SEL，还有一个IMP，当我们传入一个SEL的时候，通过hash算法获取这个对象的索引，然后快速的获取到这个bucket_t，然后获取IMP进行调用 关于class_data_bits_t这个是对class_rw_t的封装 methods里边每一个元素又是一个数组，然后每个数组代表的是一个分类中的添加的所有的方法，最终都会被汇总到这里，进行方法查找的时候就是在这里进行的查找，遍历methods，从前到后，现在第一个数组里查找，再到第二个数组里查找，以此类推 分类中添加的东西都在上边这个结构中，class_rw_t，宿体本身的内容在下边这个结构当中 method_t 一个函数只有一个返回值，多个参数，这里是类型的表示 总体结构图 动态添加方法和分类有啥关系？他们走的是同一套逻辑，都是将方法加在了可变数组那里，我们本身的类里边的内容是不可变的，具体逻辑如下图 123456789101112131415161718192021222324252627282930313233343536373839404142static IMP addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)&#123; IMP result = nil; runtimeLock.assertWriting(); assert(types); assert(cls-&gt;isRealized()); method_t *m; if ((m = getMethodNoSuper_nolock(cls, name))) &#123; // already exists if (!replace) &#123; result = m-&gt;imp; &#125; else &#123; result = _method_setImplementation(cls, m, imp); &#125; &#125; else &#123; // fixme optimize method_list_t *newlist; newlist = (method_list_t *)calloc(sizeof(*newlist), 1); newlist-&gt;entsizeAndFlags = (uint32_t)sizeof(method_t) | fixed_up_method_list; newlist-&gt;count = 1; newlist-&gt;first.name = name; newlist-&gt;first.types = strdup(types); if (!ignoreSelector(name)) &#123; newlist-&gt;first.imp = imp; &#125; else &#123; newlist-&gt;first.imp = (IMP)&amp;_objc_ignored_method; &#125; prepareMethodLists(cls, &amp;newlist, 1, NO, NO); cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, 1);//这是最核心的一句，将newlist给了data的methods，这是那个存放分类方法的二维数组 flushCaches(cls); result = nil; &#125; return result;&#125; 那么问题来了，addIvars是咋实现的，因为可变的对象中没有ivars，这里要体现苹果的变通了，直接将不可变的变成可变的.. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *type)&#123; if (!cls) return NO; if (!type) type = &quot;&quot;; if (name &amp;&amp; 0 == strcmp(name, &quot;&quot;)) name = nil; rwlock_writer_t lock(runtimeLock); assert(cls-&gt;isRealized()); // No class variables if (cls-&gt;isMetaClass()) &#123; return NO; &#125; // Can only add ivars to in-construction classes. if (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) &#123; return NO; &#125; // Check for existing ivar with this name, unless it&apos;s anonymous. // Check for too-big ivar. // fixme check for superclass ivar too? if ((name &amp;&amp; getIvar(cls, name)) || size &gt; UINT32_MAX) &#123; return NO; &#125; class_ro_t *ro_w = make_ro_writeable(cls-&gt;data());//我想把ro变成可变再说... // fixme allocate less memory here ivar_list_t *oldlist, *newlist; if ((oldlist = (ivar_list_t *)cls-&gt;data()-&gt;ro-&gt;ivars)) &#123; size_t oldsize = oldlist-&gt;byteSize(); newlist = (ivar_list_t *)calloc(oldsize + oldlist-&gt;entsize(), 1); memcpy(newlist, oldlist, oldsize); free(oldlist); &#125; else &#123; newlist = (ivar_list_t *)calloc(sizeof(ivar_list_t), 1); newlist-&gt;entsizeAndFlags = (uint32_t)sizeof(ivar_t); &#125; uint32_t offset = cls-&gt;unalignedInstanceSize(); uint32_t alignMask = (1&lt;&lt;alignment)-1; offset = (offset + alignMask) &amp; ~alignMask; ivar_t&amp; ivar = newlist-&gt;get(newlist-&gt;count++);#if __x86_64__ // Deliberately over-allocate the ivar offset variable. // Use calloc() to clear all 64 bits. See the note in struct ivar_t. ivar.offset = (int32_t *)(int64_t *)calloc(sizeof(int64_t), 1);#else ivar.offset = (int32_t *)malloc(sizeof(int32_t));#endif *ivar.offset = offset; ivar.name = name ? strdup(name) : nil; ivar.type = strdup(type); ivar.alignment_raw = alignment; ivar.size = (uint32_t)size; ro_w-&gt;ivars = newlist; cls-&gt;setInstanceSize((uint32_t)(offset + size)); // Ivar layout updated in registerClass. return YES;&#125; 下一个问题就是，元类对象又是什么？ 仍然是objc_class_t这么一个类型，只不过在data中有一个flag有一位标记了，是否为metaclass，如果是的话就去其中查找类方法，否则只能查找实例方法。 一个实例对象的内存分布是什么样的？OC对象内存分布 可以用x/16xg这个命令，查看一个对象的内存分布。 可以用p *objcname进行验证 可以用 po 0x12434524地址对应是不是对象，以及类型 这里说结论，一个对象的内存包含两大部分，一个是isa指针，另外一部分是所有的成员变量的值，那么问题来了，系统怎么知道哪个地址存的是哪个成员变量呢？这要根据_class_ro_t中的_ivars进行查询，依据是与变量在ivars中的顺序一致。 这也解释了，为什么一个对象被释放后，它所引用的对象和变量也会释放。 12345#import &lt;malloc/malloc.h&gt;p malloc_size((__bridge const void *) myObject) / 16//这里得到的是我占用了多少行的内存//比如这里得到的是32，那么就决定了要使用x/64xg来查看内存分布才能看到所有的内存分布，因为所有类中的ivars都要在当前实例中分配空间存储相应的值，所以这里分配的值有可能还是比较大的。 NSObject这个对象只有isa和super两个指针，其他的继承自它的类的实例都是在这个基础上增加的，所以分配的空间地址除以8得到的数减去2也就是增加的成员变量的数量。 我们来看一下一个UIView和CALyaer的创建内存差多少 123456NSLog(@&quot;++++%ld&quot;, (malloc_size((__bridge const void *) [UIView new])));NSLog(@&quot;++++%ld&quot;, (malloc_size((__bridge const void *) [CALayer new])));++++480++++32 因为CALyaer直接继承自NSObject，所以成员变量是比较少的，但是这个差的也太多了。我们查看CALayer的ivars发现几乎没有，那么问题来了，frame等这些是怎么实现的，答案是关联对象，那么系统为什么要这样来实现Layer呢？ 对象，类对象，元类对象方法调用的时候的查找路径图 根元类对象的superclass指向了NSObject，那么就意味着一个调用一个类方法，如果NSObject中有同名的实例方法，那么这个时候会执行这个实例方法，而不会发生崩溃 实际例子 这个题目的结果两个都打印，Phone，这里要理解调用super的意思是说，跳过self这个类，直接从super这个类对象来查找，但是消息的接受者仍然是self，所以这里都打印Phone 查找过程 缓存查找 当前类查找 关键点在于通过hash查找，找到对应的bucket_t 当前类查找 父类逐级查找 总流程 消息转发流程 一个应用就是用来实现多重代理多重代理 NSPointerArray防止循环引用 再一个应用就是实现@dynamic的属性 方法交换动态添加方法performSeletor: 动态方法解析@dynamic 动态运行时语言将函数决议推迟到运行时 编译语言编译时决议，无法修改 [obj foo]和obj_msgSend()函数关系？runtime图和通过Selector找到对应的IMP地址的？ 能否向编译后的类中添加实例变量？不能，为啥？ 答：从runtime实现原理来说，本来是可以的，但是苹果做了禁止，就像下边这样通过flag去标记这个类是已经建设完成了，还是正在建设中，编译完成的就是建设完成的，动态添加的就是正在建设中 class_addIvar实现 // Can only add ivars to in-construction classes. if (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) { return NO; } 谈谈load和initialize的区别 程序运行后立即执行vs类的方法第一次被调用执行 不会沿用父类方法vs会沿用父类方法 分类中如果有定义，全部执行但后于类中的，也就是先执行类本身中的vs覆盖类中的方法，只执行一个 app启动流程头条启动优化 可以简单分为main之前喝main之后 main之前 load dylibs image 读取库镜像文件，减少系统依赖，合并自己的 Rebase image Bind image 减少Objc类数量， 减少selector数量，减少c++虚函数 Objc setup 类，分类，SEL注册 initializers main之后main()调用之后的加载时间 在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。而我们的优化也是围绕如何能够快速展现首页来开展。 App通常在AppDelegate类中的- (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法中创建首页需要展示的view，然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。而视图的渲染主要涉及三个阶段： 准备阶段 这里主要是图片的解码布局阶段 首页所有UIView的- (void)layoutSubViews()运行绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方因此，对于main()函数调用之前我们可以优化的点有： 不使用xib，直接视用代码加载首页视图NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app生命周期]]></title>
    <url>%2F2015%2F07%2F12%2F2015%2Fapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[具体执行流程12345678910111213141516171819202122- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSLog(@&quot;--- %s ---&quot;,__func__);//__func__打印方法名 return YES;&#125;- (void)applicationWillResignActive:(UIApplication *)application &#123; NSLog(@&quot;--- %s ---&quot;,__func__);&#125;- (void)applicationDidEnterBackground:(UIApplication *)application &#123; NSLog(@&quot;--- %s ---&quot;,__func__);&#125;- (void)applicationWillEnterForeground:(UIApplication *)application &#123; NSLog(@&quot;--- %s ---&quot;,__func__);&#125;- (void)applicationDidBecomeActive:(UIApplication *)application &#123; NSLog(@&quot;--- %s ---&quot;,__func__);&#125;- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application &#123; NSLog(@&quot;--- %s ---&quot;,__func__);&#125;- (void)applicationWillTerminate:(UIApplication *)application &#123; NSLog(@&quot;--- %s ---&quot;,__func__);&#125; 启动程序 12345678910111213-[AppDelegate application:didFinishLaunchingWithOptions:] -[AppDelegate applicationDidBecomeActive:]按下 Command + H + SHIFT-[AppDelegate applicationWillResignActive:]-[AppDelegate applicationDidEnterBackground:]重新点击 进入程序-[AppDelegate applicationWillEnterForeground:]-[AppDelegate applicationDidBecomeActive:]内存警告-[AppDelegate applicationDidReceiveMemoryWarning:] UIViewController 的生命周期123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 非storyBoard(xib或非xib)都走这个方法- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); if (self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) &#123; &#125; return self;&#125;// storyBoard走这个方法- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); if (self = [super initWithCoder:aDecoder]) &#123; &#125; return self;&#125;// xib 加载 完成- (void)awakeFromNib &#123; [super awakeFromNib]; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;// 加载视图(默认从nib)- (void)loadView &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); self.view = [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.view.backgroundColor = [UIColor redColor];&#125;// 视图控制器中的视图加载完成，viewController自带的view加载完成- (void)viewDidLoad &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); [super viewDidLoad];&#125;// 视图将要出现- (void)viewWillAppear:(BOOL)animated &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); [super viewWillAppear:animated];&#125;// view 即将布局其 Subviews- (void)viewWillLayoutSubviews &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); [super viewWillLayoutSubviews];&#125;// view 已经布局其 Subviews- (void)viewDidLayoutSubviews &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); [super viewDidLayoutSubviews];&#125;// 视图已经出现- (void)viewDidAppear:(BOOL)animated &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); [super viewDidAppear:animated];&#125;// 视图将要消失- (void)viewWillDisappear:(BOOL)animated &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); [super viewWillDisappear:animated];&#125;// 视图已经消失- (void)viewDidDisappear:(BOOL)animated &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); [super viewDidDisappear:animated];&#125;// 出现内存警告 - (void)didReceiveMemoryWarning &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); [super didReceiveMemoryWarning];&#125;// 视图被销毁- (void)dealloc &#123; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125; 分析 initWithNibName:bundle:初始化UIViewController，执行关键数据初始化操作，非StoryBoard创建UIViewController都会调用这个方法。 注意: 不要在这里做View相关操作，View在loadView方法中才初始化。 initWithCoder:如果使用StoryBoard进行视图管理，程序不会直接初始化一个UIViewController，StoryBoard会自动初始化或在segue被触发时自动初始化，因此方法initWithNibName:bundle不会被调用，但是initWithCoder会被调用。 awakeFromNib当awakeFromNib方法被调用时，所有视图的outlet和action已经连接，但还没有被确定，这个方法可以算作适合视图控制器的实例化配合一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在storyBoard或xib中，所以可以在awakeFromNib方法中被加载进来。 loadView当执行到loadView方法时，如果视图控制器是通过nib创建，那么视图控制器已经从nib文件中被解档并创建好了，接下来任务就是对view进行初始化。 loadView方法在UIViewController对象的view被访问且为空的时候调用。这是它与awakeFromNib方法的一个区别。 假设我们在处理内存警告时释放view属性：self.view = nil。因此loadView方法在视图控制器的生命周期内可能被调用多次。 loadView方法不应该直接被调用，而是由系统调用，它会加载或创建一个view并把它赋值给UIViewController的view属性。 在创建view的过程中，首先会根据nibName去找对应的nib文件然后加载。如果nibName为空或找不到对应的nib文件，则会创建一个空视图(这种情况一般是纯代码) 注意:在重写loadView方法的时候，不要调用父类的方法。 viewDidLoad当loadView将view载入内存中，会进一步调用viewDidLoad方法来进行进一步设置。此时，视图层次已经放到内存中，通常，我们对于各种初始化数据的载入，初始设定、修改约束、移除视图等很多操作都可以这个方法中实现。 viewWillAppear系统在载入所有的数据后，将会在屏幕上显示视图，这时会先调用这个方法，通常我们会在这个方法对即将显示的视图做进一步的设置。比如，设置设备不同方向时该如何显示；设置状态栏方向、设置视图显示样式等。 另一方面，当APP有多个视图时，上下级视图切换是也会调用这个方法，如果在调入视图时，需要对数据做更新，就只能在这个方法内实现。 viewWillLayoutSubviewsview即将布局其Subviews。 比如view的bounds改变了(例如:状态栏从不显示到显示,视图方向变化)，要调整Subviews的位置，在调整之前要做的工作可以放在该方法中实现 viewDidLayoutSubviewsview已经布局其Subviews，这里可以放置调整完成之后需要做的工作。 viewDidAppear在view被添加到视图层级中以及多视图，上下级视图切换时调用这个方法，在这里可以对正在显示的视图做进一步的设置。 viewWillDisappear在视图切换时，当前视图在即将被移除、或被覆盖是，会调用该方法，此时还没有调用removeFromSuperview。 viewDidDisappearview已经消失或被覆盖，此时已经调用removeFromSuperView; dealloc视图被销毁，此次需要对你在init和viewDidLoad中创建的对象进行释放。 didReceiveMemoryWarning在内存足够的情况下，app的视图通常会一直保存在内存中，但是如果内存不够，一些没有正在显示的viewController就会收到内存不足的警告，然后就会释放自己拥有的视图，以达到释放内存的目的。但是系统只会释放内存，并不会释放对象的所有权，所以通常我们需要在这里将不需要显示在内存中保留的对象释放它的所有权，将其指针置nil。]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c/c++指针问题汇总]]></title>
    <url>%2F2015%2F07%2F09%2F2015%2Fc-c-%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1char const p;char const pconst char *p 上述三个有什么区别？char const p; //常量指针，p的值不可以修改char const p；//指向常量的指针，指向的常量值不可以改const char p； //和char const p 21234567891011121314151617char str1[] = “abc”;char str2[] = “abc”;const char str3[] = “abc”;const char str4[] = “abc”;const char *str5 = “abc”;const char *str6 = “abc”;char *str7 = “abc”;char *str8 = “abc”;cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl; 打印结果是什么？ 12解答：结果是：0 0 1 1str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域 ###3 以下代码中的两个sizeof用法有问题吗？ 1234567891011void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母&#123;for( size_t i=0; i&lt;sizeof(str)/sizeof(str[0]); ++i )if( ‘a’&lt;=str[i] &amp;&amp; str[i]&lt;=’z’ )str[i] -= (‘a’-&apos;A’ );&#125;char str[] = “aBcDe”;cout &lt;&lt; “str字符长度为: ” &lt;&lt; sizeof(str)/sizeof(str[0]) &lt;&lt; endl;UpperCase( str );cout &lt;&lt; str &lt;&lt; endl; 答：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。 4123456main()&#123;int a[5]=&#123;1,2,3,4,5&#125;;int *ptr=(int *)(&amp;a+1);printf(“%d,%d”,*(a+1),*(ptr-1));&#125; 输出结果是什么？ 答案：输出：2,5 1234567891011121314151617*(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5&amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）int *ptr=(int *)(&amp;a+1);则ptr实际是&amp;(a[5]),也就是a+5原因如下：&amp;a是数组指针，其类型为 int (*)[5];而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同。a是长度为5的int数组指针，所以要加 5*sizeof(int)所以ptr实际是a[5]但是prt与(&amp;a+1)类型是不一样的(这点很重要)所以prt-1只会减去sizeof(int*)a,&amp;a的地址是一样的，但意思不一样a是数组首地址，也就是a[0]的地址，&amp;a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&amp;a+1是下一个对象的地址，即a[5]. 5请问以下代码有什么问题： 12345678int main()&#123;char a;char *str=&amp;a;strcpy(str,”hello”);printf(str);return 0;&#125; 答案：没有为str分配内存空间，将会发生异常。问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。 61234char* s=”AAA”;printf(“%s”,s);s[0]=’B&apos;;printf(“%s”,s); 有什么错？ 答案：“AAA”是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。cosnt char* s=”AAA”;然后又因为是常量，所以对是s[0]的赋值操作是不合法的。 7123int (*s[10])(int) 表示的是什么？答案：int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 8有以下表达式： 12345int a=248; b=4;int const c=21;const int *d=&amp;a;int *const e=&amp;b;int const *f const =&amp;a; 请问下列表达式哪些会被编译器禁止？为什么？c=32;d=&b;d=43;e=34;e=&a;f=0x321f; 答案：c 这是个什么东东，禁止 d 说了是const， 禁止e = &amp;a 说了是const 禁止const *f const =&a; 禁止—————————————— 91234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void getmemory(char *p)&#123; p=(char *) malloc(100);strcpy(p,”hello world”);&#125; int main( )&#123;char *str=NULL;getmemory(str);printf(“%s/n”,str);free(str);return 0;&#125; 分析一下这段代码 答案：程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险 博主：getmemory中p是形参，是一个指针变量，getmemory(str)调用后，传入的是指针变量保存的对象地址，p=(char ) malloc(100)实际上是把申请的动态内存空间的首地址付给p指向的地址（即str指向的地址null），这个是错误的。应该修改成指向指针的指针void getmemory(char **p)，这样malloc返回的地址付给p（即str变量本身）。 1012char szstr[10];strcpy(szstr,”0123456789″); 产生什么结果？为什么？ 答案：长度不一样，会造成非法的OS，字符串最后一个是’\0’所以上边应该是11 11要对绝对地址0×100000赋值，我们可以用(unsigned int*)0×100000 = 1234;那么要是想让程序跳转到绝对地址是0×100000去执行，应该怎么做？ 答案：((void ()( ))0×100000 ) ( );首先要将0×100000强制转换成函数指针,即:(void ()())0×100000然后再调用它: ((void ()())0×100000)();用typedef可以看得更直观些:typedef void()() voidFuncPtr;*((voidFuncPtr)0×100000)();—————————————— 12分析下面的程序： 123456789101112131415161718192021void GetMemory(char **p,int num)&#123; //p，指向指针的指针，*p，p指向的指针(即str)，**p，最终的对象，str指向的单元*p=(char *)malloc(num); //申请空间首地址付给传入的被p指向的指针，即str&#125; int main()&#123;char *str=NULL;GetMemory(&amp;str,100); //传入指针变量本身的地址strcpy(str,”hello”);free(str);if(str!=NULL)&#123;strcpy(str,”world”);&#125; printf(“\n str is %s”,str); 软件开发网 www.mscto.comgetchar();&#125; 问输出结果是什么？ 答案：输出str is world。 free 只是释放的str指向的内存空间,它本身的值还是存在的.所以free之后，有一个好的习惯就是将str=NULL.此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的,尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。 当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存 前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的。 13123456789101112char a[10]；strlen(a)为什么等于15？#include “stdio.h”#include “string.h”void main()&#123;char aa[10];printf(“%d”,strlen(aa));&#125; 答案：sizeof()和初不初始化，没有关系；strlen()和初始化有关。 1412char (*str)[20];/*str是一个数组指针，即指向数组的指针．*/char *str[20];/*str是一个指针数组，其元素为指针型数据．*/ 1512345678910111213141516171819202122#include&lt;iostream.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;typedef struct AA&#123;int b1:5;int b2:2;&#125;AA;void main()&#123;AA aa;char cc[100];strcpy(cc,”0123456789abcdefghijklmnopqrstuvwxyz”);memcpy(&amp;aa,cc,sizeof(AA));cout &lt;&lt; aa.b1 &lt;&lt;endl;cout &lt;&lt; aa.b2 &lt;&lt;endl;&#125; 输出结果是多少？ 答案：-16和１ 首先sizeof(AA)的大小为4,b1和b2分别占5bit和2bit.经过strcpy和memcpy后,aa的4个字节所存放的值是: 0,1,2,3的ASC码，即00110000,00110001,00110010,00110011所以，最后一步：显示的是这４个字节的前５位，和 之后的２位分别为：10000,和01，因为int是有正负之分 16试题三： 以下代码有哪些错误或不足之处 1234567891011121314151617181920212223void GetMemory( char **p, int num )&#123; *p = (char *) malloc( num );&#125; void Test( void )&#123; char *str = NULL; GetMemory( &amp;str, 100 ); strcpy( str, &quot;hello&quot; ); printf( str );&#125; 解答： 存在2处问题： 本题中的Test函数中未对malloc的内存进行释放。 本题中的GetMemory避免了试题一的问题，传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句 p = (char ) malloc( num ); 后未判断内存是否申请成功，应加上： if ( *p == NULL ) { …//进行申请内存失败处理 } 17试题四：找出下面代码的不足或错误之处12345678910111213void Test( void )&#123; char *str = (char *) malloc( 100 ); strcpy( str, &quot;hello&quot; ); free( str ); ... //省略的其它语句&#125; 解答： 存在2处问题： 试题四存在与试题三同样的问题，在执行char str = (char ) malloc(100); 后未进行内存是否申请成功的判断； 另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上： str = NULL; 18 判断输出是乱码 还是字符或是字符串 还是表示地址值 ？ 如果是地址值就用0xF1247000代表 .char类型指针的输出 标准库cout输出时，无法判断指针的类型，如下面程序所示：char ch = ‘a’;int num = 1;char pch = &ch;int pnum = &num;std::cout&lt;&lt;pch&lt;&lt;std::endl; //输出：乱码std::cout&lt;&lt;(void)pch&lt;&lt;std::endl; //输出：0xF1247000std::cout&lt;&lt;pnum&lt;&lt;std::endl;//输出：0xF1247004std::cout&lt;&lt;(void)pnum&lt;&lt;std::endl; //输出：0xF12470004 char pch2=”Hello”;std::cout&lt;&lt;pch2&lt;&lt;std::endl;//输出：Hellostd::cout&lt;&lt;(void)pch2&lt;&lt;std::endl;//输出：16进制地址 对于字符型指针，要用void*进行类型转换后，才能输出其地址，地址以16进制数的格式显示32位地址值。若不进行转换，cout会按照char类型解析指针内容。若是一个字符，没有’\0’结束符，输出乱码；若是字符串，则输出字符串内容。 除了字符指针，其他指针都可以直接用cout语句来输出地址值。无须进行指针类型转换。 19 指针与引用的区别？ 答案： （1）非空区别。在任何情况下都不能使用指向空值的引用。因此如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时你应该把变量声明为指针，因为这样你可以赋空值给该变量。相反，如果变量肯定指向一个对象，例如你的设计不允许变量为空，这时你就可以把变量声明为引用。不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针要高。 （2）合法性区别。在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。 （3）可修改区别。指针与引用的另一个重要的区别是指针可以被重新赋值以指向另一个不同对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变。 思路： 遇到次类型的题目 一定要想想他们的特点是什么 抓住特点进行分析 想想他们的功能是什么 进行比较 20： 下面5个函数哪个能成功进行两个数的交换？ #includeusing namespace std; void swap1(int p,int q){ int temp; temp=p; p=q; q=temp;} void swap2(int p,int q){ int temp; temp=p; p=q; q=*temp;} void swap3(int p,int q){ int *temp; temp=p; p=q; q=temp;} void swap4(int p,int q){ int temp; temp=p; p=q; q=temp;} void swap5(int &amp;p,int &amp;q){ int temp; temp=p; p=q; q=temp;} int main (){ int a=1,b=2; //swap1(a,b); //swap2(&amp;a,&amp;b); //swap3(&amp;a,&amp;b); //swap4(&amp;a,&amp;b); //swap5(a,b); cout &lt;&lt; “a:”&lt;&lt; a &lt;&lt;endl; cout &lt;&lt; “b:”&lt;&lt; b &lt;&lt;endl; return 0; } 解析：这道题考察的是参数传递、值传递、指针传递（地址传递）和引用传递。 swap1传递的是值的副本，在函数中只是修改了形参p、q（实际是a、b的一个拷贝），p、q的值确实交换了，但是它们是局部变量，不会影响到主函数a和 b 。当函数swap1生命周期结束时，p、q所在的栈也就被删除了。 swap2传递的是一个地址进去，在函数体内的形参*p、*q是指向实际的参数a、b地址的两个指针。 这里要注意： int *temp; *temp=*p; 是不符合逻辑的，int *temp新建了一个指针（但是没分配内存）。*temp=*p不是指向而是拷贝。把*p所指向的内存的值（也就是a 的值）拷贝到*temp所指向内存里了。但是int *temp不是不分配内存吗？的确不分配，于是系统在拷贝时临时给了一个随机地址，让它存值。分配的随机地址是个“意外”，且函数结束后不回收，造成内存泄漏。 swap3传递的是一个地址，在函数体内的参数*p、*q是指向实际参数a、b地址的两个指针。 这里要注意： int *temp; temp=p; int *temp新建了一个指针（但是没分配内存）。temp=p是指向而不是拷贝。temp指向了*p所指向的地址（也就是a ）。而代码： int *temp; q=temp; 但是函数swap3不能实现两数的交换，这是因为函数体内只是指针的变化，而对地址中的值却没有变化。 swap4可以实现两数的交换，因为它修改的是指针所指向地址中的值。 swap5函数与swap4相似，是一个引用传递，修改的结果直接影响实参。 答案： swap4 函数和 swap5 函数。 21、这个函数有什么问题？该如何修改？ char *strA(){ charstr[] =”hello world”; returnstr;} 解析：这个str里存在的地址是函数strA栈里“hello world”的首地址。函数调用完成，栈帧恢复调用strA之前的状态，临时空间被重置，堆栈“回缩”，strA栈帧不再属于应该访问的范围。这段程序可以正确输出结果，但是这种访问方法违背了函数的栈帧机制。 但是只要另外一个函数调用的话，你就会发现，这种方式的不合理及危险性。 如果想获得正确的函数，改成下面这样就可以： char strA(){ charstr =”hello world”; returnstr;} 首先要搞清楚char *str 和 char str[] ： 1char str[] = “hello world”;是分配一个局部数组。局部数组是局部变量，它所对应的是内存中的栈。局部变量的生命周期结束后该变量不存在了。 1char *str = “hello world”; 是指向了常量区的字符串，位于静态存储区，它在程序生命期内恒定不变，所以字符串还在。无论什么时候调用 strA，它返回的始终是同一个“只读”的内存块。 另外想要修改，也可以这样： char *strA(){ staticcharstr[] =”hello world”; returnstr;} 通过static开辟一段静态存贮空间。 答案： 因为这个函数返回的是局部变量的地址，当调用这个函数后，这个局部变量str就释放了，所以返回的结果是不确定的且不安全，随时都有被收回的可能。 22 int arr[] = {1,2,3,4,5,6,7,8};int p=arr; (p++)+=123;printf(“%d,%d\n”, p,(++p));第一行，定义数组arr，元素共八个第二行，定义指针p指向arr数组此时的p还是等于arr数组的第0个元素，也就是1第三行，p++里的++是最后才运算，所以先执行p+=123，也就是arr的第0个元素被赋值为123此时arr变成{123,2,3,4,5,6,7,8} ，然后是p++，此时p已经是等于arr的第1个元素了，也就是2第四行，在执行printf时，括号里的参数是从右往左的顺序进行读取的，也就是说先执行 (++p)，也就是p先加一再指针，指向的是arr第2个元素3，然后在执行*p，还是3最后显示的内容就是3,3]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法题收集]]></title>
    <url>%2F2015%2F07%2F06%2F2015%2F%E7%AE%97%E6%B3%95%E9%A2%98%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[在线运行代码测试 测试1 测试2 测试3 字符串反转 链表反转 有序数组合并 Hash算法 查找两个子视图 中位数 字符串字符串反转12345678string reverseString(string s) &#123;//反转字符串 for (int i = 0;i &lt; (s.size() + 1) / 2;i++) &#123; char temp = s[i]; s[i] = s[s.size()-i-1]; s[s.size()-i-1] = temp; &#125; return s;&#125; 字符串唯一字符，假设只有小写字母1234567891011121314151617int firstUniqChar(string s) &#123;//字符串唯一字符，假设只有小写字母 int code[26] = &#123;0&#125;; for (int i = 0;i &lt; s.size();i++) &#123; char letter = s[i]; code[letter - &apos;a&apos;] ++; // cout &lt;&lt; code[0] &lt;&lt; &quot;++++&quot; &lt;&lt; code[letter - &apos;a&apos;] &lt;&lt; &quot;***&quot; &lt;&lt; letter - &apos;a&apos; &lt;&lt; letter &lt;&lt; endl; &#125; for (int i = 0;i &lt; s.size();i++) &#123; char letter = s[i]; // cout &lt;&lt; code[letter - &apos;a&apos;] &lt;&lt; &quot; code &quot; &lt;&lt; letter &lt;&lt; endl; if (code[letter - &apos;a&apos;] == 1) &#123; return i; &#125; &#125; return -1;&#125; 字符串唯一字符，啥字母都有123456789101112131415161718192021222324252627282930313233char findFirstChar(char* cha)&#123; char result = &apos;\0&apos;; // 定义一个数组 用来存储各个字母出现次数 int array[256]; // 对数组进行初始化操作 for (int i=0; i&lt;256; i++) &#123; array[i] =0; &#125; // 定义一个指针 指向当前字符串头部 char* p = cha; // 遍历每个字符 while (*p != &apos;\0&apos;) &#123; // 在字母对应存储位置 进行出现次数+1操作 array[*(p++)]++; &#125; // 将P指针重新指向字符串头部 p = cha; // 遍历每个字母的出现次数 while (*p != &apos;\0&apos;) &#123; // 遇到第一个出现次数为1的字符，打印结果 if (array[*p] == 1) &#123; result = *p; break; &#125; // 反之继续向后遍历 p++; &#125; return result;&#125; 链表增加节点123456void insertNode(Node *p,int i) &#123; //增加节点 Node *node = new Node; p-&gt;next = node; node-&gt;value = i; node-&gt;next = p-&gt;next;&#125; 删除节点1234void deleteNode(Node *p) &#123; //删除节点，因为不知道上一个节点，所以只能用下一个节点覆盖自己 p-&gt;next = p-&gt;next-&gt;next; p-&gt;value = p-&gt;next-&gt;value;&#125; 寻找中间节点用slow和fast指针标记，slow每次走一步，fast每次走两步，当fast到尾节点时，slow就相当于总长度的一半，即在中间节点。 123456789Node* findMidNode(Node* head)&#123;//找出中间节点 Node* slow = head; Node* fast = head; while (fast-&gt;next != 0&amp;&amp;fast-&gt;next-&gt;next!=0) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125; 找出倒数第k个节点//用slow和fast指针标记,fast指针事先走k步，然后slow和fast同时走，当fast到达末节点时，slow在fast的前k个节点，即为倒数第k个节点。 123456789101112131415161718192021222324252627282930ListNode* FindKthFromTail(ListNode* pListHead,int k)&#123; if (pListHead == NULL || k == 0) //防止空的链表 和 k值 等于 0 的情况 &#123; return NULL; &#125; ListNode* pAhead = pListHead; ListNode* pBehind = NULL; for (int i = 0; i &lt; k-1; i++) &#123; if (pAhead-&gt;next != NULL) &#123; pAhead = pAhead-&gt;next; &#125; else &#123; return NULL; &#125; &#125; pBehind = pListHead; while(pAhead-&gt;next != NULL) &#123; pAhead = pAhead-&gt;next; pBehind = pBehind-&gt;next; &#125; return pBehind;&#125; 链表反转12345678910111213141516171819ListNode* reverseLinkedList3(ListNode* head)&#123; if(NULL==head|| NULL==head-&gt;next) return head; //少于两个节点没有反转的必要。 ListNode* p; ListNode* q; ListNode* r; p = head; q = head-&gt;next; head-&gt;next = NULL; //旧的头指针是新的尾指针，next需要指向NULL while(q)&#123; r = q-&gt;next; //先保留下一个step要处理的指针 q-&gt;next = p; //然后p q交替工作进行反向 p = q; q = r; &#125; head=p; // 最后q必然指向NULL，所以返回了p作为新的头指针 return head;&#125; 有序单链表合并数组有序数组合并123456789101112131415161718192021222324252627282930313233343536373839void mergeList(int a[], int aLen, int b[], int bLen, int result[])//有序数组合并&#123; int p = 0; // 遍历数组a的指针 int q = 0; // 遍历数组b的指针 int i = 0; // 记录当前存储位置 // 任一数组没有到达边界则进行遍历 while (p &lt; aLen &amp;&amp; q &lt; bLen) &#123; // 如果a数组对应位置的值小于b数组对应位置的值 if (a[p] &lt;= b[q]) &#123; // 存储a数组的值 result[i] = a[p]; // 移动a数组的遍历指针 p++; &#125; else&#123; // 存储b数组的值 result[i] = b[q]; // 移动b数组的遍历指针 q++; &#125; // 指向合并结果的下一个存储位置 i++; &#125; // 如果a数组有剩余 while (p &lt; aLen) &#123; // 将a数组剩余部分拼接到合并结果的后面 result[i] = a[p++]; i++; &#125; // 如果b数组有剩余 while (q &lt; bLen) &#123; // 将b数组剩余部分拼接到合并结果的后面 result[i] = b[q++]; i++; &#125;&#125; 无序数组中位数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//求一个无序数组的中位数int PartSort(int a[], int start, int end)&#123; int low = start; int high = end; //选取关键字 int key = a[end]; while (low &lt; high) &#123; //左边找比key大的值 while (low &lt; high &amp;&amp; a[low] &lt;= key) &#123; ++low; &#125; //右边找比key小的值 while (low &lt; high &amp;&amp; a[high] &gt;= key) &#123; --high; &#125; if (low &lt; high) &#123; //找到之后交换左右的值 int temp = a[low]; a[low] = a[high]; a[high] = temp; &#125; &#125; int temp = a[high]; a[high] = a[end]; a[end] = temp; return low;&#125;int findMedian(int a[], int aLen)&#123; int low = 0; int high = aLen - 1; int mid = (aLen - 1) / 2; int div = PartSort(a, low, high); while (div != mid) &#123; if (mid &lt; div) &#123; //左半区间找 div = PartSort(a, low, div - 1); &#125; else &#123; //右半区间找 div = PartSort(a, div + 1, high); &#125; &#125; //找到了 return a[mid];&#125; 大数求和1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; /************************************************************************//* 功能：实现两个超大数相加/* 参数：source1 -- 被加数，字符型数组,如12/* source2 -- 加数，字符型数组,/* result -- 存放和，字符型数组/************************************************************************/void Add(char *source1, char *source2, char *result)&#123; int len1 = strlen(source1); int len2 = strlen(source2); int len = len1 &gt;= len2 ? len1 : len2; int i = len1 - 1, j = len2 - 1, k = 0; char *temp = (char *)malloc(sizeof(char) * (len + 2)); char x, y, z; int carryBit = 0; while (i &gt;= 0 || j &gt;= 0) &#123; if (i &lt; 0) x = &apos;0&apos;; else x = source1[i]; if (j &lt; 0) y = &apos;0&apos;; else y = source2[j]; z = x + y - &apos;0&apos; - &apos;0&apos; + carryBit; temp[k++] = z % 10 + &apos;0&apos;; carryBit = z / 10; i--; j--; &#125; while (carryBit) &#123; temp[k++] = carryBit % 10 + &apos;0&apos;; carryBit /= 10; &#125; for (--k, i = 0; k &gt;= 0; k--, i++) &#123; result[i] = temp[k]; &#125; result[i] = &apos;\0&apos;; free(temp);// 释放内存&#125; int main()&#123; char source1[1000]; char source2[1000]; char result[1100]; scanf(&quot;%s%s&quot;, source1, source2); Add(source1, source2, result); printf(&quot;%s\n&quot;, result); return 0; TopK问题TopK问题最小堆 思路 罗列反转链表 二分查找法 冒泡排序 二分法 数据结构（链表、二叉树、算法时间复杂度、空间复杂度） 什么是二叉搜索树？时间复杂度是什么？ 采用二叉树链表作为存储结构，每个左节点均小于父节点，每个右节点均大于父节点 O(log2(n)) T9算法如何实现, 全拼算法 最短路径算法 强连通量算法 实现连连看算法 如何实现一个数组每个元素依次向右移动k位。(后头的往前面补) 比如: [1, 2, 3, 4, 5] 挪两位变成[4, 5, 1, 2, 3] 求两个整数的最大公约数 微信用户都是双向的好友，a是b的好友，那么b一定是a的。给定一个用户列表，有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，每组内的用 户，互相都不是好友。如果能，请给出这个划分 算法题：说 预约会议室，会有n个团队预约当天会议室，时间各不相同，求最少需要几个会议室。比如：1预约的时间是[9-11], 2预约的时间是[10-12], 3预约的时间是[12-14], 此时会议最小个数是2个 1、就n的阶乘。（这里只是用于小数，大数会越界） 思路：这里面用递归实现 #include int getNJ(int n) { || n==) { ; } );}int main() { printf()); ;}运行结果如下： 2、判断一个字符串是否是ip。 思路：先将字符串分割到两个数组里面（一个数字数组，一个字符数组），然后判断数字数组内容是否满足ip条件，字符数组里面是否是”.”。这里面主要用了sscanf函数。代码如下： #include int checkIP(const char *p) { ]; ]; ],&amp;c[],&amp;n[],&amp;c[],&amp;n[],&amp;c[],&amp;n[],&amp;c[])==) { int i; ;i&lt;;i++) { if(c[i]!=’.’) { ; } } ;i&lt;;i++) { ||n[i]&lt;) { ; } } ; }else { ; } } int main() { const char x[] = { “132.168.1.1”, “10.0.0.1.”, “127.256.0.1”, “iudfdsfdasfdaf”, “172.16,2.1” }; const char m[] = { “不是合法的IP地址”, “是合法的IP地址” }; ; ) { printf(“%s %s\n”,x[i],m[checkIP(x[i])]); i++; } ; ;}运行结果如下： 132.168.1.1 是合法的IP地址10.0.0.1. 不是合法的IP地址127.256.0.1 不是合法的IP地址iudfdsfdasfdaf 不是合法的IP地址172.16,2.1 不是合法的IP地址3、二分查找 思路：二分查找又称折半查找，前提是待查找表为有序表。将查找目标与数组中间的数对比，如果大于中间的数就在中间数和最大数之间查找，如果小于中间数就在小数和中间数之间查找。 1234567891011121314151617181920#include &lt;stdio.h&gt;int bsearchMethod(int arr[],int low,int high,int target) &#123; while (low&lt;high) &#123; ; if (arr[mid]&gt;target) &#123; high = mid-; &#125;else if(arr[mid]&lt;target)&#123; low = mid+; &#125;else &#123; return mid; &#125; &#125; ;&#125;int main(void) &#123; ,,,,,,,,,,&#125;; printf(,,)); ;&#125; 运行结果为： 查找数在数组第5位其中-1为查找失败 冒泡排序 123456789101112131415冒泡排序 θ(n^2)void bubble_sort(int a[], int n)&#123; int i, j, temp; for (j = 0; j &lt; n - 1; j++) for (i = 0; i &lt; n - 1 - j; i++) //外层循环每循环一次就能确定出一个泡泡（最大或者最小），所以内层循环不用再计算已经排好的部分 &#123; if(a[i] &gt; a[i + 1]) &#123; temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; &#125; &#125;&#125; 快速排序 调用方法 quickSort(a,0,n); θ(nlogn) 123456789101112131415161718192021222324252627282930313233343536void quickSort (int a[] , int low , int high)&#123; if (high &lt; low + 2) return; int start = low; int end = high; int temp; while (start &lt; end) &#123; while ( ++start &lt; high &amp;&amp; a[start] &lt;= a[low]);//找到第一个比a[low]数值大的位子start while ( --end &gt; low &amp;&amp; a[end] &gt;= a[low]);//找到第一个比a[low]数值小的位子end //进行到此，a[end] &lt; a[low] &lt; a[start],但是物理位置上还是low &lt; start &lt; end，因此接下来交换a[start]和a[end],于是[low,start]这个区间里面全部比a[low]小的，[end,hight]这个区间里面全部都是比a[low]大的 if (start &lt; end) &#123; temp = a[start]; a[start]=a[end]; a[end]=temp; &#125; //在GCC编译器下，该写法无法达到交换的目的，a[start] ^= a[end] ^= a[start] ^= a[end];编译器的问题 &#125; //进行到此，[low,end]区间里面的数都比a[low]小的,[end,higt]区间里面都是比a[low]大的，把a[low]放到中间即可 //在GCC编译器下，该写法无法达到交换的目的，a[low] ^= a[end] ^= a[low] ^= a[end];编译器的问题 temp = a[low]; a[low]=a[end]; a[end]=temp; //现在就分成了3段了，由最初的a[low]枢纽分开的 quickSort(a, low, end); quickSort(a, start, high);&#125; 4、100层楼2个鸡蛋问题？ 换个角度，把问题转化为两个鸡蛋尝试x次，能测出的最高临界层是哪层？为了保证用x次测出临界层，第一个鸡蛋最高只能扔在x层，如果没碎下次上升x-1层，还没碎再上升x-2层，一直没碎的话最后上升1层。即尝试x次，最多测x+(x-1)+(x-2)+…+1=(x+1)x/2。再来考虑原题，为了测到100层，就要使(x+1)x/2&gt;=100，即x&gt;=14。这就证明了这种方法是最优解。 5、字符串反转输出问题？ 6、红黑树？ 7、河左边有：狼、羊、白菜，一个人过河，一次只能带走一件东西，怎么做能够保证三物都到河右边?规则（狼吃羊、羊吃白菜） 答：先把羊带到对面，然后把白菜带到对面，这个时候把羊带走，把狼带回对面，回去再把羊带回对面。 8、有一张圆形的桌子,两个人轮流往桌子上放硬币,假设两人有无限多的大小相同的硬币且不考虑桌子的大小,规定硬币之间不可以重叠,但可以相互碰着边,谁最后一个放硬币谁就赢,问谁会赢,第一给放硬币的人还是第二个? 答：第一个出的赢，但是第一个首先的做法是：把第一个放在中心，然后当第二个人出的时候，第一个人就对称着放硬币，第一个人就赢了。 不用中间变量,用两种方法交换A和B的值12345678910111213141516171819202122232425262728293031323334353637383940// 1.中间变量void swap(int a, int b) &#123;int temp = a;a = b;b = temp;&#125;// 2.加法void swap(int a, int b) &#123;a = a + b;b = a - b;a = a - b;&#125;// 3.异或（相同为0，不同为1. 可以理解为不进位加法）void swap(int a, int b) &#123;a = a ^ b;b = a ^ b;a = a ^ b;&#125; 求最大公约数1234567891011121314151617181920212223242526272829303132333435363738394041424344/** 1.直接遍历法 */int maxCommonDivisor(int a, int b) &#123;int max = 0;for (int i = 1; i &lt;=b; i++) &#123;if (a % i == 0 &amp;&amp; b % i == 0) &#123;max = i;&#125;&#125;return max;&#125;/** 2.辗转相除法 */int maxCommonDivisor(int a, int b) &#123;int r;while(a % b &gt; 0) &#123;r = a % b;a = b;b = r;&#125;return b;&#125;// 扩展：最小公倍数 = (a * b)/最大公约数 一个数组，里边有各种字符，如何找到第一个只出现一次的那个？思路: 首先利用acci码对字符做hash的索引，value就是出现的次数，然后维护一个数组，这个数组记录出现过的字母，如果已经添加过就不再添加，然后这个过程的时间复杂度是O(n)，然后下一次不遍历字符串，直接遍历这个新数组。 大数求和的问题，你如何去调度？考虑的点 机器的内存占用 机器的cpu情况 任务调度的优先级 然后综合考虑得出来一个公式，用来快速得出来哪一个能用，哪一个不能用，再深入一些可能还要考虑哪些机器要载入多少进行计算，根据最后的值进行这样的一个区分。 然后是这些机器处理完之后，汇总的时候内存的占用问题，会不会有内存溢出，有溢出的话怎么办？ RN这种框架如果让你设计你要考虑哪些点？RN的实现原理？多读多写的情况下你如何提高效率？重要的是将读和写进行一个并发，方法就是将写入的文件进行切分，然后读提供一个接口类，写也提供一个接口类，写只操作最后一个文件，读可以操作前边的文件，当遇到最后一个文件在进行写的时候进行一个等待，当写结束了，再进行读。这样就可以实现外界看来的读写并发。 异或类题一个整型数组里除了一个数字之外，其它的数字都出现了两次。请写程序找出这个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)1234567891011121314151617181920212223242526void weiyuansuantest() &#123;// int findUniq(int arr[],int length); int arr[7] = &#123;2,3,7,2,3,5,5&#125;; int length = sizeof(arr) / sizeof(int); int out = findUniq(arr, length); cout &lt;&lt; &quot;++++&quot; &lt;&lt; out &lt;&lt; &quot;----&quot; &lt;&lt; endl; &#125;using namespace std;int findUniq(int arr[],int length) &#123; if (length &lt; 2) &#123; return -1; &#125; int temp = 0; for (int i = 0;i &lt; length;i++) &#123; int k = arr[i]; temp = temp ^ k; cout &lt;&lt; &quot;---&quot; &lt;&lt; temp &lt;&lt; endl; &#125; return temp;&#125; 现在问题升级了，变成两个出现一次的，怎么找出来？数组里包含了两个只出现一次的数字，那么所有数字依次异或的结果就是这两个只出现一次的数字的异或结果。我们要想办法利用这个异或结果，把数组分为两个子数组，一个子数组包含一个只出现一次的数字，另一个数组包含另一个只出现一次的数字。由于这两个只出现一次的数字肯定不相等，那么这个异或结果肯定不为0，也就是说在这个结果数字的二进制表示中至少就有一位为1。我们在结果数字中找到第一个为1的位的位置，记为第N位。现在我们以第N位是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N位都为1，而第二个子数组的每个数字的第N位都为0 12345678910111213141516171819202122232425262728293031323334353637383940414243//1.找到唯一值//2.利用唯一值的第一个1位置，将数字分成两拨//3.对两组分别求解void findTwoUniqe(int arr[],int length,int &amp;m1,int &amp;m2) &#123; if (length &lt; 2) &#123; return; &#125; int temp = 0; for (int i = 0; i &lt; length;i++) &#123; int k = arr[i]; temp = temp ^ k; &#125; int indexN = findIndex1(temp); m1 = m2 = 0; for (int j = 0;j &lt; length;j++) &#123; int p = arr[j]; if (isBit1(p, indexN)) &#123; m1 = m1 ^ p; &#125;else &#123; m2 = m2 ^ p; &#125; &#125;&#125;bool isBit1(int num,unsigned int index) &#123; num = num &gt;&gt; index; return (num &amp; 1);&#125;int findIndex1(int temp) &#123; int index = 0; while ((temp &amp; 1) != 1 &amp;&amp; index &lt; 32) &#123; temp = temp &gt;&gt; 1; index ++; &#125; return index;&#125; 题目为：给你1-1000个连续自然数，然后从中随机去掉两个，再打乱顺序，要求只遍历一次，求出被去掉的两个数。（基本跟上面的题一样） 解法1：使用异或。 说说异或的两个特性：顺序无关 / 对一个数异或两次等于没有异或。顺序无关就是说异或的元素可以随意交换顺序，而不会影响结果。异或两次可以理解为+x和-x。 首先，这两个数组(打乱前和打乱后)各自异或，也就是1^2^…^1000，得到两个异或值。再对这两个异或值进行一次异或，这样就得到了x^y的指(重复部分互相抵消了) 给一组数字，这些数字里面每一个都重复出现了三次，只有一个数字只出现了一个，要求在时间O（n）空间O（1）内解出来]]></content>
  </entry>
  <entry>
    <title><![CDATA[第三方库相关]]></title>
    <url>%2F2015%2F07%2F05%2F2015%2F%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[AFNetworking SDWebImage ReactiveCocoa 信号 订阅 RACSignal–&gt;RACStream AsyncDisplayKitASNode线程安全，可以放在子线程 针对ASNode的修改和提交，会对其进行封装并且提交到一个全局容器中，ASKD也在runloop中注册了一个Observer，当Runloop进入休眠前，ASDK执行该loop内提交所有的任务。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构与框架]]></title>
    <url>%2F2015%2F07%2F05%2F2015%2F%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[图片缓存 内存设计的问题？ Size 淘汰策略 淘汰策略 队列先进先出 LRU算法(最近未使用，如30分钟) 磁盘设计方案考虑 存储方式 大小限制(100M) 淘汰策略，比如存储事件超过7天 网络部分的设计需要考虑哪些？ 图片请求最大并发 请求超时 优先级 不同格式的图片，解码采用什么方式来做？ 应用策略模式对不同图片格式进行解码 哪个阶段做图片解码？ 磁盘读取后 网络请求返回后 线程处理 时长统计框架 复杂页面设计 UI数据中所有的成员变量，对应一个UI控件，比如Label的frame和value，或者Image的图像数据和大小。 MVVM的架构思想 RN数据流思想 UIView更新机制 AsyncDisplayKit关于预排版的思想 整体架构 客户端解耦 OpenURL 依赖注入 架构的理解我们之所以需要一个架构，本质来讲就是为了解耦，小的来讲是不同的类的交互，大的方面是模块与模块之间的交互。 我们可以通过Delegate和Notificatioin来进行解耦，本质来讲就是A可以不知道B的存在，就可以让B做事情，我只要让我的代理去做事情就可以了，我的代理可以是任何人，这种情况是B知道A存在，但是A不知道B存在，A不需要引用B。 另外一种就是通知，这个就厉害了，可以做到，A和B互相不知道彼此的存在，都统统只要依赖中间的NSNotificationCenter就好了。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式相关]]></title>
    <url>%2F2015%2F07%2F05%2F2015%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[1.代理模式 2.观察者模式 3.MVC模式 4.单例模式 5.策略模式 6.工厂模式 7.适配器 8.命令模式 9.桥接 设计模式责任链:响应者链条 设计原则单一职责:一个类只负责一件事，比如UIView负责事件，CALayer只负责显示 开闭原则:对修改关闭，对扩展开放 对属性的定义要小心，以后扩展要尽量不修改类本身 接口隔离:使用很多专门协议，而不是一个庞大臃肿的协议 协议中的方法尽量少 比如tableview的datasource和delegate两种协议 依赖倒置原则:抽象不应该依赖具体实现，具体实现可以依赖抽象 所有上层只依赖接口定义，具体里边的实现是不关注的 里氏替换:父类可以被子类无缝替换，且原有功能不受影响 比如KVO 迪米特法则:一个对象应当对其他对象尽可能少的了解 这样就可以做到高内聚，低耦合 责任链调整nextResponder指向 桥接模式这个是一个特别牛逼的方法，举一个实际的业务场景，比如现在有3种布局样式的cell，然后还有3种插件，现在你要在一个tableview种任意组合这几种情况，如果所有的cell类型都暴露给tableview，那么这个逻辑将很复杂，那么怎么办呢？ 解决办法是定义一个抽象类叫做A，代表cell，再定义一个抽象类B，代表插件，根据网络数据决定实际初始化A的时候初始化具体哪个子类，但是在tableview写代码的时候只需要面对A就好了，将大大将少控制器对cell的各种类型的依赖。 适配器一个现有类需要适应变化的问题？ 对象适配器 类适配器 解决办法是创建一个新类，对原来的类进行一个包装，然后旧对象做为一个成员变量，把你的新逻辑增加到之前的方法调用之前或者之后。 123456789101112@implementation CoolTarget- (void)request&#123; // 额外处理 [self.target operation]; // 额外处理&#125;@end 单例模式1234567891011121314151617181920212223242526272829#import &quot;Mooc.h&quot;@implementation Mooc+ (id)sharedInstance&#123; // 静态局部变量 static Mooc *instance = nil; // 通过dispatch_once方式 确保instance在多线程环境下只被创建一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 创建实例 instance = [[super allocWithZone:NULL] init]; &#125;); return instance;&#125;// 重写方法【必不可少】+ (id)allocWithZone:(struct _NSZone *)zone&#123; return [self sharedInstance];&#125;// 重写方法【必不可少】- (id)copyWithZone:(nullable NSZone *)zone&#123; return self;&#125;@end 注意三个点: 重写allocWithZone 重写copyWithZone 要调用super allocWithZone，不用self防止循环调用 优点两个要点，全局和只有一次初始化机会 系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能 避免对共享资源的多重占用 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 状态可以得到全局保留 全局变量，确实也可以提供全局访问，但是并不能保证全局唯一实例，我仍然可以实例另外一个能力，且编程规范不建议大量使用全局变量。 可以用来提供一个中间转发的实现，比如NSNotificationCenter。 对全局资源的分配和管理，比如打印机有很多台，用一个单例去管理，哪个任务调度到哪个打印机去打印，或者多线程的管理，都是这个道理，中间协调的功能。 缺点 容易被滥用，单例类的职责过重，在一定程度上违背了“单一职责原则” 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态 适用场景 1.需要频繁实例化然后销毁的对象。 2.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 3.有状态的工具类对象。 4.频繁访问数据库或文件的对象。 实际使用场景 外部资源：每台计算机有若干个打印机，但只能有一个PrinterSpooler，以避免两个打印作业同时输出到打印机。内部资源：大多数软件都有一个（或多个）属性文件存放系统配置，这样的系统应该有一个对象管理这些属性文件 Windows的Task Manager（任务管理器）就是很典型的单例模式（这个很熟悉吧），想想看，是不是呢，你能打开两个windows task manager吗？ 不信你自己试试看哦~ windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 网站的计数器，一般也是采用单例模式实现，否则难以同步。 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。 HttpApplication 也是单位例的典型应用。熟悉ASP.Net(IIS)的整个请求生命周期的人应该知道HttpApplication也是单例模式，所有的HttpModule都共享一个HttpApplication实例. 命令模式行为参数化 作用，降低代码重合度 实际使用场景，转发，评论，赞等，如果没有命令模式，我们需要在每个页面进行相关处理，如果进行了行为参数化，那么就能省下很多东西。 我们需要两个模块，一个是命令管理者，一个是命令的虚拟类，最后是很多命令的具体子类。 当我们需要执行一个命令的时候就直接调用这个管理者，然后执行这个命令就好了。 命令对象封装了如何对目标执行指令的信息，因此客户端或调用者不必了解目标的任何细节，却仍可以对他执行任何已有的操作。通过把请求封装成对象，客 户端可 以把它参数化并置入队列或日志中，也能够支持可撤销操作。命令对象将一个或多个动作绑定到特定的接收器。命令模式消除了作为对象的动作和执行它的接收器之 间的绑定]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络相关]]></title>
    <url>%2F2015%2F07%2F04%2F2015%2F%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[HTTP请求行 首部字段区 实体主体，get没有，post有 响应行 首部字段区 https的建立流程 https建立连接详细 靠签名知道谁是谁，所以，签名一定是私钥。 关于加密算法非对称 RSA 对称 DES TCP/UDP 与http的关系，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据，把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等 UDP ===================特点与功能 特点:面向报文，既不合并也不拆分 差错检测的思路和策略可以用在微信等IM应用上 TCP ======================TCP中的状态码在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG. 其中，对于我们日常的分析有用的就是前面的五个字段。 它们的含义是： SYN表示建立连接， FIN表示关闭连接， ACK表示响应， PSH表示有 DATA数据传输， RST表示连接重置 TCP连接和断开 为什么三次握手？ 假设超时，会触发client的超时重传，新的syn会创建一个新的连接，这个时候服务端会启一个进程来处理这个连接，如果这个时候client的旧的syn到达了，server会给client一个确认，但是在client看来这是一个请求，就不会给ack发送ack确认，那么server就不会启动新进程处理这个，这样就能规避连接异常的问题。 为啥要四次挥手？ 因为建立的连接是双向通讯的，学名叫做双工，先是client到server的传输关闭，这个时候server到client是可以发送数据的，后边在合适的时间，server再断掉它的连接 可靠性如何保证？ 超时重传，丢弃，忽略 面向字节流不管发送方给tcp多少数据，tcp会根据实际情况，进行拆分或者合并，进行传输，这里有一个发送缓存和接收缓存的概念 流量控制基于滑动窗口协议，这个协议也可以保障按序到达 每个数据包先加一个tcp头，再加一个ip头。 TCP并不是每一个报文段都会回复ACK的，可能会对两个报文段发送一个ACK，也可能会对多个报文段发送1个ACK【累计ACK】，比如说发送方有1/2/3 3个报文段，先发送了2,3 两个报文段，但是接收方期望收到1报文段，这个时候2,3报文段就只能放在缓存中等待报文1的空洞被填上，如果报文1，一直不来，报文2/3也将被丢弃，如果报文1来了，那么会发送一个ACK对这3个报文进行一次确认。 举一个例子来说明一下滑动窗口的原理： 假设32~45 这些数据，是上层Application发送给TCP的，TCP将其分成四个Segment来发往internet seg1 32~34 seg3 35~36 seg3 37~41 seg4 42~45 这四个片段，依次发送出去，此时假设接收端之接收到了seg1 seg2 seg4 此时接收端的行为是回复一个ACK包说明已经接收到了32~36的数据，并将seg4进行缓存（保证顺序，产生一个保存seg3 的hole） 发送端收到ACK之后，就会将32~36的数据包从发送并没有确认切到发送已经确认，提出窗口，这个时候窗口向右移动 假设接收端通告的Window Size仍然不变，此时窗口右移，产生一些新的空位，这些是接收端允许发送的范畴 对于丢失的seg3，如果超过一定时间，TCP就会重新传送（重传机制），重传成功会seg3 seg4一块被确认，不成功，seg4也将被丢弃 滑动窗口动画 DNS DNS转发有个问题，就是可能返回一个错误的ip导致跨网访问，就是导致慢 当我们在浏览器输入一个 URL 后，是在什么时候、谁进行的查询？浏览器获得这个请求后，甩给了操作系统，操作系统甩给了网卡，网卡作为真正干活的人把包按照链路层协议送了出去。DNS 发生在 TCP/IP 之前。前面已经提过，到 TCP/IP 协议栈的时候已经是有 IP 地址了。真相就是操作系统进行的 DNS 查询。所以在操作系统的网络设置中，可以进行 DNS 服务器的配置。操作系统也同时管理了 DNS 的缓存。《iOS网络请求优化之DNS映射》中提到： 像 iOS 系统一般是 24 小时之后会过期，还有进入飞行模式再切回来，开关机，重置网络设置等也会导致 DNS cache 的清除。所以一般情况下用户在第二天打开你的 app 都会经历一次完整的 DNS 解析请求。 Session/Cookie]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解block]]></title>
    <url>%2F2015%2F07%2F02%2F2015%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3block%2F</url>
    <content type="text"><![CDATA[block介绍 截获变量 __block 内存管理 循环引用 什么是block是将函数及其执行上下文封装起来的对象。 查看编译后的内容clang -rewrite-objc file.m查看含有UIKit.h的 clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk xxxx 什么是block调用block调用就是函数调用 截获变量 局部变量 基本数据类型，截获其值 对象，连同所有权修饰符一起截获，__weak就是弱引用，没有修饰符就是默认strong，就是强引用 静态局部变量(static)，以指针形式进行截获 全局变量，不截获 静态全局变量，不截获 总结 只有基本数据类型才会直接使用值，如果用__block修饰也就是指针了，其他情况都是指针 __block什么时候使用block 改变存储方式，_block修饰自动变量后，_block的变量也被转化成了一个结构体:Block_byref_i_0,这个结构体有5个成员变量。 1234567struct __Block_byref_i_0 &#123; void *__isa; 指针__Block_byref_i_0 *__forwarding; 指向自身类型的__forwarding指针 int __flags; 标记flag int __size;大小 int i; 变量值&#125;; 一般情况下，对被截获变量进行赋值操作需要添加__block修饰符，注意赋值不等于操作 1234__block NSMutableArray *arr = nil;void(^Block)(void) = ^&#123; arr = [NSMutableArray array];&#125; 这种没有__block直接会报错 __block的原理是什么？__block修饰后的int类型会变成结构体，也就是对象。 12345678__block int muti = 6; int(^newBlock)(int) = ^int(int num) &#123; return muti * num; &#125;; muti = 4; newBlock(2); 这个结果是8 12345678int muti = 6;int(^newBlock)(int) = ^int(int num) &#123; return muti * num;&#125;;muti = 4;newBlock(2); 这个结果是12 12345678static int muti = 6;int(^newBlock)(int) = ^int(int num) &#123; return muti * num;&#125;; muti = 4; newBlock(2); 这个结果也是8 12345678910111213141516171819202122232425262728293031323334353637383940414243NSMutableString *mutable_string = [NSMutableString stringWithString:@&quot;aaa&quot;]; void(^mutable_append)(void)=^&#123; [mutable_string appendString:@&quot;ccc&quot;]; &#125;; [mutable_string appendString:@&quot;bbb&quot;]; mutable_append(); NSLog(@&quot;\\n %@&quot;,mutable_string); //结果：aaabbbccc // 没有__block，但是也没有涉及到直接指针的修改，只是操作而已，因此aaabbbccc NSString *string = @&quot;aaa&quot;; NSString*(^append)(void)=^&#123; return [string stringByAppendingString:@&quot;ccc&quot;]; &#125;; string = @&quot;bbb&quot;; NSLog(@&quot;\\n %@&quot;,append()); //结果：aaaccc // 没有__block，copy值，截获之后和外部都指向@&quot;aaa&quot;，但是外部string修改了指向为@&quot;bbb&quot;,内部指针还是指向@&quot;aaa&quot;，所以aaaccc __block NSString *block_string = @&quot;aaa&quot;; NSString*(^block_append)(void)=^&#123; return [block_string stringByAppendingString:@&quot;ccc&quot;]; &#125;; block_string = @&quot;bbb&quot;; NSLog(@&quot;\\n %@&quot;,block_append()); //结果: bbbccc // 有__block，自动转换成新的结构体，string变成其内部属性，block截获的是新结构体的地址，外部block_string重新赋值，也不是简单的赋值，内部转换成`a.__forwarding.a`的代码，可以理解为通过新的结构体改变指针所指向的值，通过__block所形成的新结构体作为载体，之后所有的操作都是操作同一个对象，理解为指针操作，因此，形成一致，打印bbbccc __block NSString *name = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;mikejing&quot;]; NSString *(^addaa)(void) = ^&#123; return [name stringByAppendingString:@&quot;cjj&quot;]; &#125;; name = @&quot;MKJ&quot;; NSLog(@&quot;\\n %@&quot;,addaa()); // \n MKJcj // 同上 char *ch = &quot;b =\n&quot;; void (^block)(void) = ^&#123; printf(&quot;%s&quot;,ch); // b = &#125;; ch = &quot;value had changed.b =\n&quot;; block(); // 无法修改，上面已经介绍 下边这段代码如何使其打印20？ 123456789int i = 10; void (^block)() = ^ &#123; NSLog(@&quot;%d&quot;, i);&#125;; i = 20; block(); __block或者static 这段代码打印什么？ 12345678910int i = 10; void (^block)() = ^ &#123; i = 30; NSLog(@&quot;%d&quot;, i);&#125;; i = 20; block(); 啥都打印不了，直接报错了 但是改成下边这样就没有问题，或者用static 12345678910__block int i = 10; void (^block)() = ^ &#123; i = 30; NSLog(@&quot;+++++%d&quot;, i); &#125;; i = 20; block(); 这段代码有没有问题？答案是没有，这里是修改的内存中的内容，并没有修改内存地址 12345678910- (void)blockDemo3&#123; NSMutableString *strM= [NSMutableString stringWithString:@&quot;hello&quot;]; void (^block)() = ^ &#123; [strM appendString:@&quot;hehe&quot;]; &#125;; block();&#125; 这样写有没有问题？这样写直接就报错了，没有__block修饰不允许修改指针地址。1234567 NSMutableString *strM= [NSMutableString stringWithString:@&quot;hello&quot;]; void (^block)() = ^ &#123; strM = @&quot;hehe&quot;;&#125;; block(); block内存管理 &gt; 如果block实现中没有访问任何”外部”变量(包括局部和全局), 该block为GlobalBlock 如果block实现中访问了任何”外部”变量(包括局部和全局), 该block为StackBlock 对StackBlock进行拷贝(copy/Block_copy), 该block为MallocBlock 1234567891011__block NSMutableString *strM= [NSMutableString stringWithString:@&quot;hello&quot;]; void (^block)() = ^&#123; strM = @&quot;hehe&quot;;&#125;; block(); NSLog(@&quot;%@&quot;,^&#123;&#125;);NSLog(@&quot;%@&quot;, ^&#123;strM = @&quot;123&quot;;&#125;);NSLog(@&quot;%@&quot;,block); 2018-07-03 10:02:20.760734+0800 xiancheng[77686:36486980] 2018-07-03 10:02:20.763747+0800 xiancheng[77686:36486980] 2018-07-03 10:02:20.764553+0800 xiancheng[77686:36486980] 这个是会有内存泄漏的，栈上的会释放，但是堆上的不会 循环引用weakSelf StrongSelf 的使用解决循环应用的问题一定要分析清楚哪里出现了循环引用，只需要把其中一环加上weakSelf这类似的宏，就可以解决循环引用。_weak的实现原理，在原对象释放之后，_weak对象就会变成null，防止野指针。所以就输出了null了。 那么我们怎么才能在weakSelf之后，block里面还能继续使用weakSelf之后的对象呢？ 究其根本原因就是weakSelf之后，无法控制什么时候会被释放，为了保证在block内不会被释放，需要添加_strong。 在block里面使用的_strong修饰的weakSelf是为了在函数生命周期中防止self提前释放。strongSelf是一个自动变量当block执行完毕就会释放自动变量strongSelf不会对self进行一直进行强引用。 123456789 __weak typeof(student) weakSelf = student;student.study = ^&#123; __strong typeof(student) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;my name is = %@&quot;,strongSelf.name); &#125;);&#125;; 这里有一个问题，看上去最终也是通过__storng来抢引用self的，那么为什么不会引起循环引用呢？其实这里也是会造成循环引用，而且必须是一个循环引用才可以，但是这个循环引用不是永久的，是在一个时间段内，这个时间段就是在block执行的时候。 要有一个概念，block内的代码只有在执行的时候才会生效，但是变量捕获却是在编译的时候就会生效，所以我们捕获了一个weakself，但是在运行的时候对这个self做了一次retain，这就意味着在block运行的时候self绝对不会释放，但是block一旦执行完毕，里边的变量就会被释放，这个时候self就跟我没有关系了，该释放就释放。 如果我们直接引用self，那么这个是永久的，不管你block是否执行，这个引用都是永久存在的 123[UIView animateWithDuration:0.2 animations:^&#123; self.alpha = 1;&#125;]; 这个情况直接使用self是没有问题的，因为引用block的是animation内的某个对象，当动画执行结束之后block就会被释放，self也会被释放。 如果只使用成员变量呢？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253_block = ^NSString *(NSString *num) &#123; return [NSString stringWithFormat:@&quot;%@&quot;, _arr[0]]; &#125;;static NSString * __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself, NSString *num) &#123; ViewController *self = __cself-&gt;self; // bound by copy return ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_h6_b8d2vwjj7hz3kdq9kpxts5j00000gq_T_ViewController_ed107b_mi_1, ((id (*)(id, SEL, NSUInteger))(void *)objc_msgSend)((id)(*(NSMutableArray **)((char *)self + OBJC_IVAR_$_ViewController$_arr)), sel_registerName(&quot;objectAtIndexedSubscript:&quot;), (NSUInteger)0));&#125;//这种情况是捕获self的 _block = ^NSString *(NSString *num) &#123; return [NSString stringWithFormat:@&quot;%@&quot;, self.arr[0]]; &#125;; static NSString * __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself, NSString *num) &#123; ViewController *self = __cself-&gt;self; // bound by copy return ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_h6_b8d2vwjj7hz3kdq9kpxts5j00000gq_T_ViewController_5b51e6_mi_1, ((id (*)(id, SEL, NSUInteger))(void *)objc_msgSend)((id)((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;arr&quot;)), sel_registerName(&quot;objectAtIndexedSubscript:&quot;), (NSUInteger)0));&#125;//这种情况更是捕获self_block = ^NSString *(NSString *num) &#123; return @&quot;afdasf&quot;; &#125;; static NSString * __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself, NSString *num) &#123; return (NSString *)&amp;__NSConstantStringImpl__var_folders_h6_b8d2vwjj7hz3kdq9kpxts5j00000gq_T_ViewController_599c3a_mi_1; &#125;//啥都不捕获_arr = [NSMutableArray arrayWithObject:@&quot;123&quot;]; __unsafe_unretained NSArray * weakArr = _arr; _block = ^NSString *(NSString *num) &#123; return [NSString stringWithFormat:@&quot;%@&quot;, weakArr[0]]; &#125;; static NSString * __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself, NSString *num) &#123; NSArray *weakArr = __cself-&gt;weakArr; // bound by copy return ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_h6_b8d2vwjj7hz3kdq9kpxts5j00000gq_T_ViewController_cba29f_mi_1, ((id (*)(id, SEL, NSUInteger))(void *)objc_msgSend)((id)weakArr, sel_registerName(&quot;objectAtIndexedSubscript:&quot;), (NSUInteger)0)); &#125; //只是捕获weak变量 说明一下_arr实际上是self-&gt;_arr，也是需要依赖self才能访问的，即使在内部，属性和成员变量的访问都是需要依赖对象。再从runtime角度看一下，当我调用一个方法的时候，经过msg_send函数转发，这里的参数只有self，和SEL以及参数，没有self的成员变量，所以只能依靠self去获取，这样的话无论如何都要穿入self才行。 __block在MRC和ARC下的区别使用弱引用打断block里面的retain cycleMRC中 _block 是不会引起retain；但在ARC中 _block 则会引起retain。ARC中应该使用 _weak 或__unsafe_unretained弱引用 下边这种写法使block持有了blockSelf这个对象，这个强引用在，解决的办法是破环，使用完之后释放blockSelf，这个方案的弊端是，如果这个block不调用，那么这个环就一直存在。 我们经常会听说如何解决block的循环引用？一般都会说用weak和block，那么block实现解除循环引用的本质就是下边这段代码，使用完了之后可以将这个引用设置为nil，其他的做法就不可以，因为不用block修饰根本就不能更改指针指向。 12345678910111213141516__block typeof(self) blockSelf = self; _block = ^NSString *(NSString *num) &#123; NSLog(@&quot;%@&quot;, blockSelf.arr[0]);// blockSelf = nil; return @&quot;123&quot;;&#125;; =========================================static NSString * __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself, NSString *num) &#123;__Block_byref_blockSelf_0 *blockSelf = __cself-&gt;blockSelf; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h6_b8d2vwjj7hz3kdq9kpxts5j00000gq_T_ViewController_614b65_mi_0, ((id (*)(id, SEL, NSUInteger))(void *)objc_msgSend)((id)((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)(blockSelf-&gt;__forwarding-&gt;blockSelf), sel_registerName(&quot;arr&quot;)), sel_registerName(&quot;objectAtIndexedSubscript:&quot;), (NSUInteger)0)); return (NSString *)&amp;__NSConstantStringImpl__var_folders_h6_b8d2vwjj7hz3kdq9kpxts5j00000gq_T_ViewController_614b65_mi_1;&#125; block和代理如何选择使用delegate更轻量，但是写起来麻烦，block用起来写起来很简单，但是运行起来消耗大。 优先使用block。如果回调的状态很多，多于三个使用代理。如果回调的很频繁，次数很多，像UITableview，每次初始化、滑动、点击都会回调，使用代理。又或者说， delegate 的回调更多的面向过程，而 block 则是面向结果的。如果你需要得到一条多步进程的通知，你应该使用 delegation，如果你需要一个最终的结果你应该使用delegate]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runloop相关]]></title>
    <url>%2F2015%2F07%2F02%2F2015%2Frunloop%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[什么是runloop是通过内部维护事件循环来对事件/消息进行管理的一个对象。 没有消息处理的时候，是用户态到内核态，有消息需要处理的时候，是内核态到用户态。 状态的切换才是关键。 数据结构解析 说明： 与pthread是一对一的关系 models是一个集合NSMutableSet commonModes也是一个集合，NSMutableSet 说明： source0和source1是NSMutableSet类型，无序 observers和timers是NSMutableArray类型，有序 runloopMode当运行在mode1的情况下，无法接受mode2种的一些事件，比如在滑动的时候无法接受正常状态的事件。 CommonMode不是一种实际存在的mode，它是同步source/timer/observer到多个mode的一种技术方案 从点击app图标开始发生了什么？常驻线程]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程技术]]></title>
    <url>%2F2015%2F07%2F01%2F2015%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[多线程相关概念理解为什么要有多线程这个问题具体来讲，假如cpu是分配时间给一个线程去运行，也不是并行的运算，为什么你开多线程去执行任务会更快呢？ 这个原因在于，并不只有你一个应用在机器上运行，所以你以为你只开了一个没错，但是还有系统级或者其他应用的很多线程在跑，所以你开的线程多，cpu平均来看分配给你应用的时间就多，这样你的任务就更快完成，这是一个零和博弈的游戏，你的对手是系统和其他应用。 并发与并行并行可以在计算机的多个抽象层次上运用，这里仅讨论任务级并行（程序设计层面），不讨论指令级并行等。 并发指能够让多个任务在逻辑上同时执行的程序设计，而并行则是指在物理上真正的同时执行。并行是并发的子集，属于并发的一种实现方式。通过时间片轮转实现的多任务同时执行是通过调度算法实现逻辑上的同步执行，属于并发，他们不是真正物理上的同时执行，不属于并行。当通过多核 CPU 实现并发时，多任务是真正物理上的同时执行，才属于并行。 线程的状态 下面分别阐述线程生命周期中的每一步 新建：实例化线程对象 就绪：向线程对象发送start消息，线程对象被加入可调度线程池等待CPU调度。 运行：CPU 负责调度可调度线程池中线程的执行。线程执行完成之前，状态可能会在就绪和运行之间来回切换。就绪和运行之间的状态变化由CPU负责，程序员不能干预。 阻塞：当满足某个预定条件时，可以使用休眠或锁，阻塞线程执行。sleepForTimeInterval（休眠指定时长），sleepUntilDate（休眠到指定日期），@synchronized(self)：（互斥锁）。 死亡：正常死亡，线程执行完毕。非正常死亡，当满足某个条件后，在线程内部中止执行/在主线程中止线程对象 还有线程的exit和cancel [NSThread exit]：一旦强行终止线程，后续的所有代码都不会被执行。 [thread cancel]取消：并不会直接取消线程，只是给线程对象添加 isCancelled 标记。 线程与队列的关系我们可以把队列理解成生产者，而线程是消费者。 我们是理解runloop来干活的逻辑，但是其实本质来讲真正干活的是线程，只不过没有runloop就干完活，没有新活了就被系统释放掉了，当然如果在线程池里边的线程处理完一个工作之后，有新的工作需要处理，那么它继续处理，不会被释放掉的。 串行队列与并发队列串行队列的任务是一个一个排着队执行的，前一个执行完之后再执行下一个，但是并发队列也是需要排着队执行的，但是不需要等着上一个执行完，下一个就可以接着执行。 那这个是怎么实现的呢？根据上边说线程才是真正干活的角色，所以我们就有了答案，串行队列绑定了一个线程，不一定是主线程，并发队列有开新线程的能力，如果发现线程池里边没有可用的线程，但是我又有一个任务，那我直接开一个新的线程来处理。 这样看的话，并发队列也是一个队列，而不是很多个队列，这个点容易理解错误。 多线程的安全问题多个线程访问同一块资源进行读写，如果不加控制随意访问容易产生数据错乱从而引发数据安全问题。为了解决这一问题，就有了加锁的概念。加锁的原理就是当有一个线程正在访问资源进行写的时候，不允许其他线程再访问该资源，只有当该线程访问结束后，其他线程才能按顺序进行访问。对于读取数据，有些程序设计是允许多线程同时读的，有些不允许。UIKit中几乎所有控件都不是线程安全的，因此需要在主线程上更新UI。 解决多线程安全问题： （1）互斥锁 // 注意：锁定1份代码只用1把锁，用多把锁是无效的@synchronized(锁对象) { // 需要锁定的代码 }使用互斥锁，在同一个时间，只允许一条线程执行锁中的代码。因为互斥锁的代价非常昂贵，所以锁定的代码范围应该尽可能小，只要锁住资源读写部分的代码即可。使用互斥锁也会影响并发的目的。 （2）使用NSLock对象 1234567_lock = [[NSLock alloc] init];- (void)synchronizedMethod &#123; [_lock lock]; //safe [_lock unlock];&#125; （3）atomic加锁 OC在定义属性时有nonatomic和atomic两种选择。 atomic：原子属性，为setter方法加锁（默认就是atomic）。 nonatomic：非原子属性，不会为setter方法加锁。 atomic加锁原理： 123456789@property (assign, atomic) int age;- (void)setAge:(int)age&#123; @synchronized(self) &#123; _age = age; &#125;&#125; atomic：线程安全，需要消耗大量的资源 nonatomic：非线程安全，适合内存小的移动设备 iOS开发的建议: （1）所有属性都声明为nonatomic （2）尽量避免多线程抢夺同一块资源 （3）尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力 自旋锁与互斥锁的比较与选择自旋锁是一种非阻塞锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁。 互斥量是阻塞锁，当某线程无法获取互斥量时，该线程会被直接挂起，该线程不再消耗CPU时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。 两种锁适用于不同场景： 如果是多核处理器，如果预计线程等待锁的时间很短，短到比线程两次上下文切换时间要少的情况下，使用自旋锁是划算的。 如果是多核处理器，如果预计线程等待锁的时间较长，至少比两次线程上下文切换的时间要长，建议使用互斥量。 如果是单核处理器，一般建议不要使用自旋锁。因为，在同一时间只有一个线程是处在运行状态，那如果运行线程发现无法获取锁，只能等待解锁，但因为自身不挂起，所以那个获取到锁的线程没有办法进入运行状态，只能等到运行线程把操作系统分给它的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。 如果加锁的代码经常被调用，但竞争情况很少发生时，应该优先考虑使用自旋锁，自旋锁的开销比较小，互斥量的开销较大。 多线程实现手段 NSThread创建NSThread有三种创建方式： init方式 detachNewThreadSelector创建好之后自动启动 performSelectorInBackground创建好之后也是直接启动 1234567891011121314151617181920212223242526/** 方法一，需要start */NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething1:) object:@&quot;NSThread1&quot;];// 线程加入线程池等待CPU调度，时间很快，几乎是立刻执行[thread1 start]; /** 方法二，创建好之后自动启动 */[NSThread detachNewThreadSelector:@selector(doSomething2:) toTarget:self withObject:@&quot;NSThread2&quot;]; /** 方法三，隐式创建，直接启动 */[self performSelectorInBackground:@selector(doSomething3:) withObject:@&quot;NSThread3&quot;]; - (void)doSomething1:(NSObject *)object &#123; // 传递过来的参数 NSLog(@&quot;%@&quot;,object); NSLog(@&quot;doSomething1：%@&quot;,[NSThread currentThread]);&#125; - (void)doSomething2:(NSObject *)object &#123; NSLog(@&quot;%@&quot;,object); NSLog(@&quot;doSomething2：%@&quot;,[NSThread currentThread]);&#125; - (void)doSomething3:(NSObject *)object &#123; NSLog(@&quot;%@&quot;,object); NSLog(@&quot;doSomething3：%@&quot;,[NSThread currentThread]);&#125; NSThread的类方法123456789101112131415161718192021222324返回当前线程// 当前线程[NSThread currentThread];NSLog(@&quot;%@&quot;,[NSThread currentThread]); // 如果number=1，则表示在主线程，否则是子线程打印结果：&#123;number = 1, name = main&#125;阻塞休眠//休眠多久[NSThread sleepForTimeInterval:2];//休眠到指定时间[NSThread sleepUntilDate:[NSDate date]];类方法补充//退出线程[NSThread exit];//判断当前线程是否为主线程[NSThread isMainThread];//判断当前线程是否是多线程[NSThread isMultiThreaded];//主线程的对象NSThread *mainThread = [NSThread mainThread]; NSThread的一些属性12345678910//线程是否在执行thread.isExecuting;//线程是否被取消thread.isCancelled;//线程是否完成thread.isFinished;//是否是主线程thread.isMainThread;//线程的优先级，取值范围0.0到1.0，默认优先级0.5，1.0表示最高优先级，优先级高，CPU调度的频率高thread.threadPriority; NSThread使用场景常驻线程的实现 1234567891011121314151617181920212223242526272829301.设置成全局的，如果是线程对象是局部的就会死掉@property (nonatomic,strong) NSThread *thread;2.初始化线程并启动self.thread = [[NSThread alloc]initWithTarget:self selector:@selector(run) object:nil];[self.thread start];3.启动RunLoop，子线程的RunLoop默认是停止的- (void)run&#123; //只要往RunLoop中添加了 timer、source或者observer就会继续执行，一个Run Loop通常必须包含一个输入源或者定时器来监听事件，如果一个都没有，Run Loop启动后立即退出。 @autoreleasepool &#123; //1、添加一个input source [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; //2、添加一个定时器 NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; &#125;&#125;这样thread这个线程就会一直存在，当需要使用此线程在处理一些事情的时候就这么调用4.利用常驻线程处理事情[self performSelector:@selector(action) onThread:self.thread withObject:nil waitUntilDone:NO ]; 看一下这个代码的问题: 123456789dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSTimer * timer = [NSTimer timerWithTimeInterval:1.f repeats:YES block:^(NSTimer * _Nonnull timer) &#123; static int count = 0; [NSThread sleepForTimeInterval:1]; //休息一秒钟，模拟耗时操作 NSLog(@&quot;%s - %d&quot;,__func__,count++); &#125;]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; &#125;); 根本啥都不会发生，因为这个子线程的runloop需要调用run方法才可以。 [[NSRunLoop currentRunLoop] run];//子线程需要手动开启Runloop thread启动流程 长驻子线程是在selector中进行，如上 那么这里就有一个问题了，NSThread启动的时候是否需要手动创建释放池？答案是不需要，验证，当pthread_exit退出时，触发了_pthread_tsd_cleanup，触发AutoreleasePoolPage的tls_dealloc(void*)，然后回收autorelease对象。 所以我们可以得出来一个结论，线程创建的时候会自动创建一个自动释放池，当线程退出的时候清空这个池子，释放内存。 GCD的理解与使用GCD是对pthread的封装，目的在于替代NSThread的，有点在于自动管理线程的生命周期(创建，调度，销毁)，我们只需要告诉GCD想要执行什么任务，不需要写任何线程管理代码。 基本概念 并发执行的本质是多线程，不是多队列，一个并发队列搞定 开不开线程，取决于执行任务的队列，如果串行队列，有线程对应该队列就不开了，并发队列如果在线程池取不到队列就会新开线程。 开几条线程，这个如果是串行队列有一个线程就行了，如果是并发队列，就要看具体情况了，这个是由系统来决定的。 主队列： 专门用来在主线程上调度任务的”队列”，主队列不能在其他线程中调度任务！ 如果主线程上当前正在有执行的任务，主队列暂时不会调度任务的执行！主队列同步任务，会造成死锁。原因是循环等待 同步任务可以队列调度多个异步任务前，指定一个同步任务，让所有的异步任务，等待同步任务执行完成，这是依赖关系。 全局队列：并发，能够调度多个线程，执行效率高，但是相对费电。 串行队列效率较低，省电省流量，或者是任务之间需要依赖也可以使用串行队列。 也可以通过判断当前用户的网络环境来决定开的线程数。WIFI下6条，3G/4G下2～3条。 队列的选择选择队列当然是要先了解队列的特点：串行队列：对执行效率要求不高，对执行顺序要求高，性能消耗小并发队列：对执行效率要求高，对执行顺序要求不高，性能消耗大 队列的创建方法使用dispatch_queue_create来创建队列对象，传入两个参数，第一个参数表示队列的唯一标识符，可为空。第二个参数用来表示串行队列（DISPATCH_QUEUE_SERIA）或并发队列（DISPATCH_QUEUE_CONCURRENT）。 123456// 串行队列dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);// 串行队列dispatch_queue_t myQueueS = dispatch_queue_create(&quot;com.kugou.gcd.myQueue&quot;, NULL);// 并发队列dispatch_queue_t queue1 = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT); 第一个参数为名字，一定要设置这个参数，因为发生崩溃的时候，这个将是一个很重要的指引，这个名字会出现在崩溃信息中，第二个参数如果要创建serial queue就设置为NULL，代表空的c指针，如果是另外一种就设置为DISPATCH_QUEUE_CONCURRENT 另外要注意的是，虽然我们已经步入了ARC时代，但是Dispatch Queue必须由开发人员来释放，接着上班的代码 12dispatch_async(myQueueS, ^&#123;NSLog(@&quot;123&quot;)&#125;);dispatch_release(myQueueS); 在调用async之后立刻释放queue，这样并不会有问题，因为此时block已经对齐有一个引用了。当block结束之后就会释放这个queue。凡是由create创建的对象都要记得手动释放。 GCD的队列还有另外两种：主队列：主队列负责在主线程上调度任务，如果在主线程上已经有任务正在执行，主队列会等到主线程空闲后再调度任务。通常是返回主线程更新UI的时候使用。 12345678910dispatch_get_main_queue() dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 耗时操作放在这里3 dispatch_async(dispatch_get_main_queue(), ^&#123; // 回到主线程进行UI操作3 &#125;); &#125;); 全局并发队列：全局并发队列是就是一个并发队列，是为了让我们更方便的使用多线程。 1234567891011dispatch_get_global_queue(0, 0)//全局并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//全局并发队列的优先级#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高优先级#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）优先级#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低优先级#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台优先级//iOS8开始使用服务质量，现在获取全局并发队列时，可以直接传0dispatch_get_global_queue(0, 0); 我们通过dispatch_get_global_queue来获取一个queue，那么问题来了，你获取一个什么样的queue呢？一个有几个全局的queue呢？从下边的参数来看，一共有四种，具体来讲有四个，每种一个。 1234#define DISPATCH_QUEUE_PRIORITY_HIGH 2#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0#define DISPATCH_QUEUE_PRIORITY_LOW (-2)#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN 在并行的队列也就是dispatch_get_global_queue，一共4个可用，当dispatch_sync调用一次，会占用阻塞一个，直到用完，dispatch_get_global_queue只能添加的时候安排优先级，不能去操作里面的调度 任务提交方式dispatch_sync/async我们来看看这两个函数到底该怎么理解。 disptach_async是异步扔一个block到queue中，即扔完我就不管了，继续执行我的下一行代码。实际上当下一行代码执行时，这个block还未执行，只是入了队列queue，queue会排队来执行这个block。 而disptach_sync则是同步扔一个block到queue中，即扔了我就等着，等到queue排队把这个block执行完了之后，才继续执行下一行代码 1234567dispatch_sync(seriqueue, ^&#123; [self test];&#125;); dispatch_async(seriqueue, ^&#123; [self test];&#125;); dispatch_sync使用场景主要用于代码上下文对时序有强要求的场景。简单点说，就是下一行代码的执行，依赖于上一行代码的结果。 例如说，我们需要在子线程中读取一个image对象，使用接口[UIImage imageNamed:]，但imageNamed:实际上在iOS9以后才是线程安全的，iOS9之前都需要在主线程获取。所以，我们需要从子线程切换到主线程获取image，然后再切回子线程拿到这个image。 1234567__block UIImage *image;if (![NSThread isMainThread]) &#123; dispatch_sync(dispatch_get_main_queue(), ^&#123; image = [UIImage imageNamed:@&quot;ceshi&quot;]; &#125;); attachment.image = image;&#125; 这里要说明一点，切换到主线程，使用sync和async其实都可以，区别在于是否会堵塞，在这个场景里，子线程需要等待主线程这个任务完成，所以选择用sync，但是如果是回到主线程刷新一个UI，下边的任务不依赖上边的任务，这个时候我会选择async。 再比如，并发队列中，利用同步任务，能够做到任务依赖关系，第一个任务（登录）是同步任务，这个任务不执行完，队列就不会调度后面的任务（支付、下载）。 12345678910111213141516171819202122232425dispatch_queue_t q = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);//1.用户登录 开启了同步任务，相当于用了一把锁，所有的主线程都执行完后，才会执行队列里的子线程任务dispatch_sync(q, ^&#123; NSLog(@&quot;用户登录：%@&quot;, [NSThread currentThread]);&#125;);//2.用户支付dispatch_async(q, ^&#123; NSLog(@&quot;用户支付：%@&quot;, [NSThread currentThread]);&#125;);//3.用户下载dispatch_async(q, ^&#123; NSLog(@&quot;用户下载：%@&quot;, [NSThread currentThread]);&#125;); 栅栏的使用dispatch_barrier_async当任务需要异步进行，但是这些任务需要分成两组来执行，第一组完成之后才能进行第二组的操作。这时候就用了到GCD的栅栏方法dispatch_barrier_async。 sync与async区别 dispatch_barrier_sync和dispatch_barrier_async的共同点：1、都会等待在它前面插入队列的任务（1、2、3）先执行完2、都会等待他们自己的任务（0）执行完再执行后面的任务（4、5、6） dispatch_barrier_sync和dispatch_barrier_async的不共同点：在将任务插入到queue的时候，dispatch_barrier_sync需要等待自己的任务（0）结束之后才会继续程序，然后插入被写在它后面的任务（4、5、6），然后执行后面的任务而dispatch_barrier_async将自己的任务（0）插入到queue之后，不会等待自己的任务结束，它会继续把后面的任务（4、5、6）插入到queue 所以，dispatch_barrier_async的不等待（异步）特性体现在将任务插入队列的过程，它的等待特性体现在任务真正执行的过程。 如果现在我们是10个读取的操作，然后并发执行并没有问题，但是如果有一个写入的操作掺杂在其中，这个时候就有点问题了，读写同时进行，就会出问题。 该函数与Concurrent Dispatch Queue同时使用12345678dispatch_queue_t queueC = dispatch_queue_create(&quot;com.kugou.gcd.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, blk0_reading);dispatch_async(queue, blk1_reading);dispatch_async(queue, blk2_reading);dispatch_barrier_async(queue, blk3_writing);dispatch_async(queue, blk4_reading);dispatch_async(queue, blk5_reading);dispatch_async(queue, blk6_reading); 这样写系统会等0，1，2并发执行完，执行blk3，等blk3执行完再并发执行4，5，6 再比如多读单写的实现。 队列组/调度组dispatch_group_async异步执行几个耗时操作，当这几个操作都完成之后再回到主线程进行操作，就可以用到队列组了。 队列组有下面几个特点： 所有的任务会并发的执行(不按序)。 所有的异步函数都添加到队列中，然后再纳入队列组的监听范围。 使用dispatch_group_notify函数，来监听上面的任务是否完成，如果完成, 就会调用这个方法。 下载很多图片，当都下载完成之后再进行下一步操作。 很多情况下我们都需要做结束操作，这个操作肯定是在最后的，如果是serial queue肯定没有问题，把代码放在最后就好了，可是concurrent queue怎么办呢？这个时候我们可以考虑dispatch_grounp。 场景1:现在有4个任务，任务1、任务2、任务3、任务4. 任务3必须在任务2之后，任务4必须在前3个任务都执行完成后，才能执行，并且需要在主线程更新UI。 思路分析： 任务3必须在任务2之后，所以这两个必须串行执行，同时，任务2和3整体可以和任务1并行执行，最后，任务4只能等待前3个任务全部执行完成，才能执行。这里就可以用group快速实现场景需求。 1234567891011121314151617-(void)disGroup&#123; dispatch_queue_t globalQuene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_queue_t selfQuene = dispatch_queue_create(&quot;myQuene&quot;, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, globalQuene, ^&#123; NSLog(@&quot;run task 1&quot;); &#125;); dispatch_group_async(group, selfQuene, ^&#123; NSLog(@&quot;run task 2&quot;); &#125;); dispatch_group_async(group, selfQuene, ^&#123; NSLog(@&quot;run task 3&quot;); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;run task 4&quot;); &#125;);&#125; 场景2:dispatch_group_enter的使用某界面存在多个请求，希望所有请求均结束才进行某操作，注意这里的一个不同点，如果只是几个block执行完毕就可以执行一个统一的block，那么用group的notify就可以了，但是这里不但要block执行完，还要监听block里边的一个异步的回调是不是完成，这样直接用group的notify就不好使用。 一个页面同时多个请求的写法 1234567891011121314151617181920212223242526272829dispatch_group_t group = dispatch_group_create();dispatch_group_enter(group);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求1 [网络请求:&#123; 成功：dispatch_group_leave(group); 失败：dispatch_group_leave(group);&#125;];&#125;);dispatch_group_enter(group);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求2 [网络请求:&#123; 成功：dispatch_group_leave; 失败：dispatch_group_leave;&#125;];&#125;);dispatch_group_enter(group);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求3 [网络请求:&#123; 成功：dispatch_group_leave(group); 失败：dispatch_group_leave(group);&#125;]; &#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; //界面刷新 NSLog(@&quot;任务均完成，刷新界面&quot;);&#125;); 这里要用一个dispatch_group_enter，因为我们并不知道网络什么时候回来，如果没有这个group_entre方法，那么网络发送出去，这个block就执行结束了，就回去刷新UI，但是实际情况是网络并没有返回。 思考一个问题如果这里dispatch_group_notify，换成dispatch_group_wait(group, DISPATCH_TIME_FOREVER);会是什么效果呢？ 不同点在于dispatch_group_wait会阻塞线程，而dispatch_group_notify会让线程继续往下走，等group完成之后再回调我的这个block。 一次性执行12345// 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; // 只执行1次的代码(这里面默认是线程安全的)&#125;); dispatch_set_target_queuedispatch_queue_create函数生成的Dispatch Queue不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，多使用与默认优先级Global Dispatch Queue相同执行优先级的线程，变更执行优先级使用dispatch_set_target_queue函数123dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.kugou.mySerQueue&quot;, NULL);dispatch_queue_t myGlobalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);dispatch_set_target_queue(mySerialQueue, myGlobalQueue); 指定第一个参数与第二个参数优先级相同 dispatch_after用于延时执行1234dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,3ULL * NSEC_PER_SEC);dispatch_after(time, dispatch_get_main_queue(),^&#123; NSLog(@&quot;123&quot;);&#125;) 注意，dispatch_after函数并不是在指定时间后执行，而只是在指定时间追加处理到dispatch_queue，此源码在3秒后用dispatch_async函数追加block到main dispatch queue相同。在严格时间要求下这个函数的使用会出问题。 dispatch_applydispatch_semaphore_t123dispatch_semaphore_t t = dispatch_semaphore_create(1); //创建dispatch_semaphore_wait(t, DISPATCH_TIME_FOREVER); //等待哪个，永远dispatch_semaphore_signal(t); 为线程加锁信号量：就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。 其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。 理解成停车位，dispatch_semaphore_t个数，dispatch_semaphore_wait减少一个可用，dispatch_semaphore_signal增加一个可用123456789101112131415161718192021222324252627282930-(void)dispatchSignal&#123; //crate的value表示，最多几个资源可访问 dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); //同时只能有两个线程去处理 dispatch_queue_t quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //任务1 dispatch_async(quene, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 1&quot;); sleep(1); NSLog(@&quot;complete task 1&quot;); dispatch_semaphore_signal(semaphore); &#125;);&lt;br&gt; //任务2 dispatch_async(quene, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 2&quot;); sleep(1); NSLog(@&quot;complete task 2&quot;); dispatch_semaphore_signal(semaphore); &#125;);&lt;br&gt; //任务3 dispatch_async(quene, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 3&quot;); sleep(1); NSLog(@&quot;complete task 3&quot;); dispatch_semaphore_signal(semaphore); &#125;); &#125; 异步线程进行同步12345678910111213141516171819dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); __block int j = 0; dispatch_async(queue, ^&#123; j = 100; dispatch_semaphore_signal(semaphore); &#125;); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;finish j = %zd&quot;, j);``` 结果输出 j ＝ 100； 如果注掉dispatch_semaphore_wait这一行，则 j ＝ 0； 注释： block块异步执行添加到了全局并发队列里，所以程序在主线程会跳过block块（同时开辟子线程异步执行block块），执行块外的代码dispatch_semaphore_wait，因为semaphore信号量为0，且时间为DISPATCH_TIME_FOREVER，所以会阻塞当前线程（主线程），进而只执行子线程的block块，直到执行块内部的dispatch_semaphore_signal使得信号量+1。正在被阻塞的线程（主线程）会恢复继续执行。这样保证了线程之间的同步。##### 通讯录相关 //这个变量用于记录授权是否成功，即用户是否允许我们访问通讯录 int __block tip=0; //创建通讯簿的引用 ABAddressBookRef addressBooks=ABAddressBookCreateWithOptions(NULL, NULL); //创建一个初始信号量为0的信号 dispatch_semaphore_t sema=dispatch_semaphore_create(0); //申请访问权限 ABAddressBookRequestAccessWithCompletion(addressBooks, ^(bool granted, CFErrorRef error) { //granted为YES是表示用户允许，否则为不允许 if (!granted) { tip=1; } //发送一次信号 dispatch_semaphore_signal(sema); }); //等待信号触发 dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); CFRelease(addressBooks); 123##### 使用 Dispatch Semaphore 控制并发线程数量 void dispatch_async_limit(dispatch_queue_t queue,NSUInteger limitSemaphoreCount, dispatch_block_t block) {//控制并发数的信号量 static dispatch_semaphore_t limitSemaphore; //专门控制并发等待的线程 static dispatch_queue_t receiverQueue; //使用 dispatch_once而非 lazy 模式，防止可能的多线程抢占问题 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ limitSemaphore = dispatch_semaphore_create(limitSemaphoreCount); receiverQueue = dispatch_queue_create(&quot;receiver&quot;, DISPATCH_QUEUE_SERIAL); }); // 如不加 receiverQueue 放在主线程会阻塞主线程 dispatch_async(receiverQueue, ^{ //可用信号量后才能继续，否则等待 dispatch_semaphore_wait(limitSemaphore, DISPATCH_TIME_FOREVER); dispatch_async(queue, ^{ !block ? : block(); //在该工作线程执行完成后释放信号量 dispatch_semaphore_signal(limitSemaphore); }); }); }12345678910111213141516171819202122232425262728293031323334353637383940414243444546#### 保持异步线程同步的方案- 1.dispatch_group - 2.dispatch_barrier - 3.dispatch_semaphore### NSOperationNSOperation是一个抽象类，可以使用系统提供的子类或者自己实现它的子类，来完成多线程。我们平时提到的NSOperation就默认包含了它的子类，具有以下特性：- 是OC语言中基于GCD(GCD详解)的面向对象的封装；- 使用起来比GCD更加简单(面向对象)；- 提供了一些用GCD不好实现的功能，比如可以取消在任务处理队列中的任务，添加任务间的依赖关系等等；- 苹果推荐使用,使用NSOperation不用关心线程以及线程的生命周期；- 可以指定操作之间的依赖关系，是将操作添加到队列。- 并发队列，异步执行(多个线程，无序执行)。#### 与GCD对比提供了GCD不好实现的：1.最大并发数2.暂停和继续3.取消所有任务4.依赖关系#### NSOperation子类NSOperation是一个抽象类，实现NSOperation子类的方式有3种：- NSInvocationOperation：较少使用；- NSBlockOperation：最常使用；- 自定义子类继承NSOperation，实现内部相应的方法：很少使用。我们要做的就是将以上3种操作的任意一种添加到NSOperationQueue来使用。 //NSOperation能做啥 添加任务依赖 任务执行状态控制 最大编发量控制 // 任务状态控制有哪些？ isReady isExecting isFinished isCancelled // 怎么控制状态 如果只重写了main，底层控制变更任务执行完成状态 如果重写了start，需要自行控制状态 12##### NSInvocationOperation /// 点击屏幕调用，创建一个操作并执行 (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event { NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo:) object:@”这是一个参数”]; [operation start];}/// 将参数与当前线程打印 (void)demo:(NSString *)str { NSLog(@”%@–%@”,str,[NSThread currentThread]);} /*执行结果**/2015-09-17 15:11:54.030 NSOperationTest[2595:162235] 这是一个参数 {number = 1, name = main} 1234默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。只有将operation放到一个NSOperationQueue中，才会异步执行操作。 /// 点击屏幕调用，创建一个操作并执行 (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event { [self invocationTest];}/// 将操作添加到队列 (void)invocationTest { // 创建操作队列 NSOperationQueue operationQueue = [[NSOperationQueue alloc] init]; // 创建操作（最后的object参数是传递给selector方法的参数） NSInvocationOperation operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo:) object:@”这是一个参数”]; // 将操作添加到操作队列 [operationQueue addOperation:operation];}/// 将参数与当前线程打印 (void)demo:(NSString *)str { NSLog(@”%@–%@”,str,[NSThread currentThread]);} /*执行结果**/2015-09-17 15:36:23.777 NSOperationTest[2943:182362] 这是一个参数–{number = 2, name = (null)} 1234##### NSBlockOperation执行一个操作（同步) NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(){ NSLog(@”%@”,[NSThread currentThread]);}];// 开始执行任务[operation start]; /*执行结果**/2015-09-17 15:47:58.791 NSOperationTest[3015:191317] {number = 1, name = main} 12添加多个操作执行（操作异步，整体还是同步），NSBlockOperation只有在封装的操作数大于1时才会开启子线程执行，否则默认执行在主线程。 NSLog(@”——start one——–”);// 初始化一个对象NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(){ sleep(1); NSLog(@”1：%@”,[NSThread currentThread]);}];// 再添加3操作[operation addExecutionBlock:^() { NSLog(@”2：%@”, [NSThread currentThread]);}];[operation addExecutionBlock:^() { NSLog(@”3：%@”, [NSThread currentThread]);}];[operation addExecutionBlock:^() { sleep(3); NSLog(@”4：%@”, [NSThread currentThread]);}];NSLog(@”——start two——–”);// 开始执行任务[operation start];NSLog(@”=========the end==========”); /*执行结果**/2018-03-19 20:35:14.961863+0800 NSOperationTest[9329:21176421] ——start one——–2018-03-19 20:35:14.962419+0800 NSOperationTest[9329:21176421] ——start two——–2018-03-19 20:35:14.962771+0800 NSOperationTest[9329:21176565] 2：{number = 4, name = (null)}2018-03-19 20:35:14.962771+0800 NSOperationTest[9329:21176566] 3：{number = 3, name = (null)}2018-03-19 20:35:15.963071+0800 NSOperationTest[9329:21176421] 1：{number = 1, name = main}2018-03-19 20:35:17.964043+0800 NSOperationTest[9329:21176568] 4：{number = 5, name = (null)}2018-03-19 20:35:17.964471+0800 NSOperationTest[9329:21176421] =========the end========== 1234567当添加多个操作时，开启新的线程，多个操作之间是异步执行的，以加快效率。整体是还是同步执行。##### 自定义NSOperation自定义NSOperation最主要的就是重载-(void)main这个方法，在这个方法里面添加需要执行的操作。当执行这个操作时，系统会自动调用-(void)main这个方法 #import “CustomOpertaionTest.h” @implementation CustomOpertaionTest (void)main { // 新建一个自动释放池，避免内存泄露 @autoreleasepool {// 执行的代码 NSLog(@&quot;这是一个测试:%@&quot;,[NSThread currentThread]); }}@end 12在主控制器中调用，一共两种：一种同步一种异步 /**1.直接执行，同步*/CustomOpertaionTest *operation = [[CustomOpertaionTest alloc] init];// 开始执行任务[operation start]; /*执行结果**/2015-09-17 16:24:27.620 NSOperationTest[3368:222036] 这是一个测试:{number = 1, name = main} /——————————————————/ /**2.添加到队列，异步*/NSOperationQueue operationQueue = [[NSOperationQueue alloc] init];CustomOpertaionTest operation = [[CustomOpertaionTest alloc] init];[operationQueue addOperation:operation]; /*执行结果**/2015-09-17 16:27:13.594 NSOperationTest[3401:225178] 这是一个测试:{number = 2, name = (null)} 1234##### NSOperationQueue通过上面的三种方式生成NSOperation调用start函数，因为都是默认执行在主任务队列mainQueue中，所以才会执行在主线程中，如果采用下面这种方式都会执行在异步子线程中。 //创建NSOperationQueueNSOperationQueue * queue=[[NSOperationQueue alloc]init];//设置NSOperationQueue最大并发任务数queue.maxConcurrentOperationCount=3; NSInvocationOperation operation1= [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(operationTask) object:nil];NSInvocationOperation operation2= [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(operationTask) object:nil]; NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^{ [NSThread sleepForTimeInterval:1]; NSLog(@”operationTask:%@ isMainThread：%@”,[NSThread currentThread],[[NSThread currentThread] isMainThread]?@”YES”:@”NO”);}]; [operation3 addExecutionBlock:^{ [NSThread sleepForTimeInterval:1]; NSLog(@”operationTask:%@ isMainThread：%@”,[NSThread currentThread],[[NSThread currentThread] isMainThread]?@”YES”:@”NO”); }]; [queue addOperation:operation1];[queue addOperation:operation2];[queue addOperation:operation3]; for (int i =0; i]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI与Runtime]]></title>
    <url>%2F2015%2F07%2F01%2F2015%2FUI%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[UI视图相关UIViewController生命周期当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序 1、 alloc 创建对象，分配空间 2、init (initWithNibName) 初始化对象，初始化数据 3、loadView 从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图 4、viewDidLoad 载入完成，可以进行自定义数据以及动态创建其他控件 5、viewWillAppear 视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了 6、viewDidAppear 视图已在屏幕上渲染完成 当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反 1、viewWillDisappear 视图将被从屏幕上移除之前执行 2、viewDidDisappear 视图已经被从屏幕上移除，用户看不到这个视图了 3、dealloc 视图被销毁，此处需要对你在init和 viewDidLoad中创建的对象进行释放 tableview的cell重用机制tablevie的数据源同步两种一种是拷贝数据，然后并发执行，一种是在串行队列中去执行 UIView与CALayer的区别UIView参与响应链条，处理事件，CALayer负责显示内容单一职责原则 事件传递 如何实现一个正方形，只有中间圆形响应事件呢？重写- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event 问题，如何让一个在父视图外的 1234567891011- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; UIView *view = [super hitTest:point withEvent:event]; if (view == nil) &#123; CGPoint yellowPoint = [self convertPoint:point toView:self.testBtn]; if ([self.testBtn pointInside:yellowPoint withEvent:event]) &#123; view = self.testBtn; &#125;// self.testBtn.istarget = YES; &#125; return view;&#125; 说明当，第一个view返回nil的时候，说明点击不在这个view上，那么下一步判断，点击在不在子控件，testBtn上，注意这里要先转化坐标系，如果在的话那就直接返回这个testBtn 如果是子控件的子控件怎么办呢？提供一个注册类，当返回为nil的时候就交给这个注册的对象来处理事件。 1234567891011121314151617181920212223242526#import &quot;backView.h&quot;@interface backView()@endstatic __weak UIView *targetView;@implementation backView- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; UIView *view = [super hitTest:point withEvent:event]; if (view == nil) &#123; CGPoint yellowPoint = [self convertPoint:point toView:targetView]; if ([targetView pointInside:yellowPoint withEvent:event]) &#123; view = targetView; &#125; &#125; return view;&#125;+ (void)registerTargetView:(UIView *)view &#123; targetView = view;&#125;@end 接着上边的问题，如果是一个下边这样的结构你怎么实现？ 仍然用上边的代码总体结构不动，几点细节需要注意: 注册的tagetView变成tableview 返回的view是最终处理事件的view，所以这里返回的并不是targetview，而是返回其子view，那么怎么返回呢？继续调用hitTest方法，但是这里注意传入的应该是转换后的坐标，否则子试图使用的是在父试图中的坐标，这里肯定对不上 123456789101112131415161718192021222324@interface backView()@endstatic __weak UIView *targetView;@implementation backView- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; UIView *view = [super hitTest:point withEvent:event]; if (view == nil) &#123; CGPoint yellowPoint = [self convertPoint:point toView:targetView]; if ([targetView pointInside:yellowPoint withEvent:event]) &#123; view = [targetView hitTest:yellowPoint withEvent:event];//关键在这里需要传入转换之后的坐标 &#125; &#125; return view;&#125;+ (void)registerTargetView:(UIView *)view &#123; targetView = view;&#125;@end 再注意，-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event和pointInside:(CGPoint)pointwithEvent:(UIEvent *)event中的point都是调用这个方法的view的坐标系内的坐标，所以一定要记得提前转换。 使用的方法就是[self convertPoint:point toView:targetView]，这里也要注意，这个point要是self的坐标系内的，现在给转移到tagetView的坐标系内。 问题？怎么找到一个view所以依赖的第一个控制器？ 答案:响应者链条，最终会找到UIApplication这个类。 cpucpu负责 布局和文本计算，绘制，图片编解码，提交位图 卡顿和掉帧的根本原因滑动优化CPU 对象的创建，销毁，调整 预排版(布局计算，文本计算) 预渲染(文本异步绘制，图片解码) GPU 离屏渲染 视图混合(透明度) UIView绘制流程 系统绘制流程图 异步绘制流程 [layer.delegate displayLayer:] 代理负责生成bitmap 设置bitmap为layer的contents属性 现在问一个问题，异步绘制的时候，是在本次runloop的时候提交gpu的吗？ 并不是，是在下一次绘制的时候。 drawrect为什么会导致内存暴增原文链接 - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;这个方法调用之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，它作为ctx参数传入。在这一步生成的空寄宿图内存是相当巨大的，它就是本次内存问题的关键，一旦你实现了CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的内存可从这个公式得出：图层宽图层高4 字节，宽高的单位均为像素。而我们的画板程序因为要支持像猿题库一样两指挪动的效果，我们开辟的画板大小为： _myDrawer = [[BHBMyDrawer alloc] initWithFrame: CGRectMake(0, 0, SCREEN_SIZE.width*5, SCREEN_SIZE.height*2)];我们的画板程序的画板视图它在iPhone6s plus机器上的上下文内存量就是 19202108054 字节， 相当于79MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。它就是我们画板程序内存暴增的真正原因 drawRect方法依赖Core Graphics框架来进行自定义的绘制，但这种方法主要的缺点就是它处理touch事件的方式：每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例 离屏渲染这个概念起源于GPU，当某些视图的某些属性不能在未合成之前用于屏幕直接显示的时候就会在当前屏幕缓冲区之外再开辟一个缓冲区进行渲染操作。 何时触发？ 圆角和masktobound一起设置 图层蒙版 光栅化 阴影 为何要避免UI卡顿和掉帧 创建新的缓冲区 上下文切换]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中的内存管理]]></title>
    <url>%2F2015%2F06%2F30%2F2015%2FiOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[内存布局 内存管理方案 内存布局 MRC/ARC 引用计数 弱引用 自动释放池 循环引用 内存布局 栈(stack)方法调用都是在栈区，栈向下增长， 堆(heap)alloc的数据都是在堆区间，还有copy过的block 代码段(text)内存管理方案strong实现探究 weak实现探究 不同场景，不同方案 小数据 TaggedPointer(NSNumber) NONPOINTER_ISA，剩余多余的位数用来存储点别的，这个其实就是isa 散列表，包括引用计数表和弱引用表(SideTables) OC引用计数原理 TaggedPointer判断当前对象是否在使用 TaggedPointer 是看标志位是否为 1 ： 1234567891011121314#if SUPPORT_MSB_TAGGED_POINTERS# define TAG_MASK (1ULL&lt;&lt;63)#else# define TAG_MASK 1inline bool objc_object::isTaggedPointer() &#123;#if SUPPORT_TAGGED_POINTERS return ((uintptr_t)this &amp; TAG_MASK);#else return false;#endif&#125; id 其实就是 objc_object 的简写（typedef struct objc_object id;），它的 isTaggedPointer() 方法经常会在操作引用计数时用到，因为这决定了存储引用计数的策略 有些对象如果支持使用 TaggedPointer，苹果会直接将其指针值作为引用计数返回；如果当前设备是 64 位环境并且使用 Objective-C 2.0，那么“一些”对象会使用其 isa 指针的一部分空间来存储它的引用计数；否则 Runtime 会使用一张散列表来管理引用计数 12345678910111213141516NSNumber *nu = [NSNumber numberWithInteger:3]; NSLog(@&quot;%@---%p---%@&quot;, nu,nu,[nu valueForKey:@&quot;retainCount&quot;]); NSNumber *nu1 = [NSNumber numberWithInteger:1]; NSLog(@&quot;%@---%p---%@&quot;, nu1,nu1,[nu1 valueForKey:@&quot;retainCount&quot;]); NSNumber *nu2 = [NSNumber numberWithInteger:2]; NSLog(@&quot;%@---%p---%@&quot;, nu2,nu2,[nu2 valueForKey:@&quot;retainCount&quot;]); 3---0xb000000000000033---92233720368547758071---0xb000000000000013---92233720368547758072---0xb000000000000023---9223372036854775807 看上边数据3，1，2直接存在了指针里，只要指针存在，那么数据就存在，没有isa指针，不受retainCount管理。 TaggedPointer与引用计数TaggedPointer原理 NONPOINTER-ISA与引用计数。12345678struct objc_object &#123;private: isa_t isa;public:xxxxxxxxxxxx 对象中有一个isa_t类型的对象，isa是一个联合体，其中包含了这样的一组定义： 1234567891011121314151617# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL struct &#123; uintptr_t nonpointer : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) &#125;; 我们可以看到，当使用Tagged Pointer时候，从指针的第45位开始，一共19位，存储的都是对象的引用计数信息，标志为extra_rc。当存储空间不够时，苹果会使用对象的sidetable来存储对象的引用计数信息 散列表 如何实现快速分流，也就是找到SideTable的位置的？ 散列式数据结构自旋锁 RedcountMap(引用计数) 弱引用表 MRC和ARC 之所以说ARC需要用到runtime比如weak关键字的实现 禁止调用只是禁止显示调用，我们仍然可以用kvc来进行调用。 这里需要看一下refcntStorage，从下表中可以推测，这个变量size_t类型存储了很多信息，不单单是retainCount那么简单，0位势弱引用信息，是否有弱引用，1位存储了是否要被dealloc，2位才是真正的引用计数，再看一个细节，MSB-ward是什么意思？LSB是最低有效位，那么这个MSB就是最高有效位了 1234#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)#define SIDE_TABLE_DEALLOCATING (1UL&lt;&lt;1) // MSB-ward of weak bit#define SIDE_TABLE_RC_ONE (1UL&lt;&lt;2) // MSB-ward of deallocating bit#define SIDE_TABLE_RC_PINNED (1UL&lt;&lt;(WORD_BITS-1)) 这里又衍生了一个问题，为什么要在这边记录weak和dealloc呢？答案是提供状态查询，查询一个对象是不是有weak引用，或者正在deallocing，注意，这里不是已经dealloc了，而是正在销毁，这是一个过程，一旦进入到了这个过程就会通过这个函数去标记，去告诉别人我要销毁了，不要使用我了。 1234567891011121314151617objc_object::sidetable_isDeallocating()&#123; SideTable&amp; table = SideTables()[this]; // NO SPINLOCK HERE // _objc_rootIsDeallocating() is called exclusively by _objc_storeWeak(), // which already acquired the lock on our behalf. // fixme can&apos;t do this efficiently with os_lock_handoff_s // if (table.slock == 0) &#123; // _objc_fatal(&quot;Do not call -_isDeallocating.&quot;); // &#125; RefcountMap::iterator it = table.refcnts.find(this); return (it != table.refcnts.end()) &amp;&amp; (it-&gt;second &amp; SIDE_TABLE_DEALLOCATING);&#125; 所以说明dealloc是在release方法中调用的。 Objective-C的引用计数管理使用两种方式相结合，sidetable和isa指针（指针并不是对象的真正内存地址，而是某些位用来进行了一些标志位的存放）；接下来，我将以sidetable进行release来讨论dealloc的调用，直接上代码，如下sidetable_release（下文所有都会用sidetable_release来讨论）函数会在给对象发送release消息的时候调用，sidetable_release方法首先获取对象的引用计数，对引用计数相关标志位做操作，若对象实例可以被释放，将通过objc_msgSend发送SEL_dealloc消息，既调用对象的dealloc方法。 12345678910111213141516171819202122232425262728uintptr_tobjc_object::sidetable_release(bool performDealloc)&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer);#endif SideTable&amp; table = SideTables()[this]; bool do_dealloc = false; table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it == table.refcnts.end()) &#123;//如果没有这个对象的引用信息，那么直接走dealloc逻辑，将这个对象的dealloc标记置为1 do_dealloc = true; table.refcnts[this] = SIDE_TABLE_DEALLOCATING; &#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;//如果size_t信息在dealloc信息有效位以下，那么也直接走dealloc逻辑 // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&apos;t change it. do_dealloc = true; it-&gt;second |= SIDE_TABLE_DEALLOCATING; &#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;//如果是有效的那么直接将计数减少4，因为retainCount会右移动4位，所以反应到retainCount就会是1 it-&gt;second -= SIDE_TABLE_RC_ONE; &#125; table.unlock(); if (do_dealloc &amp;&amp; performDealloc) &#123;//如果要销毁那么直接执行dealloc ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); &#125; return do_dealloc;&#125; 1234TestView *test1 = [[TestView alloc] init];self.test = test1;NSLog(@&quot;%@&quot;,[[[TestView alloc] init] valueForKey:@&quot;retainCount&quot;]);NSLog(@&quot;%@&quot;,[test1 valueForKey:@&quot;retainCount&quot;]); 1232018-07-07 17:37:03.997243+0800 gpu[57393:720434] 12018-07-07 17:45:56.191210+0800 gpu[57878:728352] -[TestView dealloc]2018-07-07 17:37:03.997573+0800 gpu[57393:720434] 2 这里要说的是调用alloc以后，并没有对其retain，但是当调用retainCount的时候会变成1的，因为最开始并没有这个对象对应的table，所以不会做到if逻辑里边去， 123456789101112131415objc_object::sidetable_retainCount()&#123; SideTable&amp; table = SideTables()[this]; size_t refcnt_result = 1; table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123; // this is valid for SIDE_TABLE_RC_PINNED too refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; &#125; table.unlock(); return refcnt_result;&#125; dealloc的实现 弱引用相关源码入口NSObject.mm/objc_initWeak weak实现探究 这里有个问题需要思考，既然前边提到table_t中的refcntStorage可以存储弱引用相关的信息，那么为什么还需要一个weak_table呢，并且弱引用并不增加计数，那么我们存储这些信息又有什么意义呢？ 其实这是为了实现后边weak关键字修饰的指针，在对象被释放后指针变为nil的功能，既然要将这个指针设置为nil，那么我们就需要记录这些指向这个对象的这些weak指针，对比看strong修饰的指针就不需要记录。 12345struct SideTable &#123; spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table;&#125; weak_table_t中有一个weak_entries这是一个数组，这里存储的是weak_entry_t类型的结构体。 123456struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;&#125;; weak_entry_t中呢存储的是一个referrers，这个又是一个weak_referrer_t的数组，这里边的成员是weak_referrer_t，我们可以看到，它的实质类型是一个地址，这个地址存储的是weak指针的地址，看清楚这不是对象的地址，是指针的地址，为了方便后边将这个指针设置为nil 12345678910111213141516struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line : 1; uintptr_t num_refs : PTR_MINUS_1; uintptr_t mask; uintptr_t max_hash_displacement; &#125;; struct &#123; // out_of_line=0 is LSB of one of these (don&apos;t care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;;&#125;; 12/// The address of a __weak object referencetypedef objc_object ** weak_referrer_t; weak_clear_no_lock的实现这个实现也印证了我们之前的判断，这里就是通过一个对象的地址referent_id来寻找这个对象存储于哪个weak_table_t找到之后从中找到这个对象的存储实体，weak_entry_t，这里存储的就是这个对象的weak指针了，后边我们看到循环遍历*referrer = nil; 12345678910111213141516171819202122232425262728293031323334353637383940414243weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn&apos;t happen, but does with mismatched CF/objc //printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot; &quot;This is probably incorrect use of &quot; &quot;objc_storeWeak() and objc_loadWeak(). &quot; &quot;Break on objc_weak_error to debug.\n&quot;, referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; weak_entry_remove(weak_table, entry);&#125; 自动释放池AutoreleasePool 原理？为何可以嵌套使用？ 数据结构objc_autoreleasePoolPush调用AutoreleasePoolPage::push，一次pop相当于批量的pop 1234567class AutoreleasePoolPage &#123; id *next; //指向下一个可添加节点 pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child;&#125; 栈结构复习 双向链表结构复习 Push的时候发生了什么创建一个自动释放池就会创建一个哨兵，然后返回这个哨兵的位置，然后next向上移动，然后在池子中间创建的对象都会被自动添加到这个池子中，next不断移动，当执行pop的时候，中间的内容都会接收到release消息被释放，next指针会移动到哨兵的位置。 [obj autorelease]的调用逻辑 这里一个逻辑有一点要注意就是如果这个栈已经满了，再添加节点在链表上，然后增加栈节点。 循环引用 自循环引用 相互循环引用 多循环引用 常考&gt; 代理 Block NSTimer 大环 self把自己给cell用，自己又通过tableview引用了cell 解决思路: 避免产生 在何时时机手动断环 具体的方案: __weak，不增加计数 __block __unsafe_unretained，不会增加计数，但是会产生悬垂指针 __block注意 MRC下，__block修饰对象不会增加引用计数 ARC下，__block修饰的对象会被强引用，无法避免循环引用，需要手动破解环 NSTimer的循环引用 即使对象不引用Timer，也没用，因为Runloop会引用Timer，Timer的taget是对象，依然会增加对其的引用，当然如果timer只执行一次，我们可以断掉runloop的引用，但是如果是多次的timer咋办呢？ 解决方案：增加中间对象 桥接桥接ARC只能作用于 Objective-C 类型，CoreFoundation 等类型的依然需要手动管理。Objective-C 对象的指针和 CoreFoundation 类型的指针是不一样的。 我们一般有三种类型__bridge、__bridge_transfer、__bridge_retained。 如果 CoreFoundation 对象和 Objective-C 对象转换只涉及类型，不涉及所有权的话，可以使用__bridge，比如这样: id obj = (__bridge id)CFDictionaryGetValue(cfDict, key);这时候ARC就可以接管这个对象并自动管理。 但是，如果所有权被变更了，那么，再使用__bridge的话，就会发生内存泄露。 123456789101112131415161718192021NSString *value = (__bridge NSString *)CFPreferencesCopyAppValue(CFSTR(&quot;someKey&quot;), CFSTR(&quot;com.company.someapp&quot;));[self useValue: value];其实，上面这段就等同于：CFStringRef valueCF = CFPreferencesCopyAppValue(CFSTR(&quot;someKey&quot;), CFSTR(&quot;com.company.someapp&quot;)); NSString *value = (__bridge NSString *)valueCF; //CFRelease(valueCF); [self useValue: value];其实这时候是需要加一行CFRelease(valueCF)的，如果没有的话，valueCF是会内存泄露的。当然，上面的写法也是可以的，只是这个临时变量存在的意义不大，写法也比较啰嗦，可以使用__bridge_transfer去解决这个问题。NSString *value = (__bridge_transfer NSString *)CFPreferencesCopyAppValue(CFSTR(&quot;someKey&quot;), CFSTR(&quot;com.company.someapp&quot;));[self useValue: value];和__bridge 不一样，__bridge_transfer会将值和所有权都移交出去，ARC接管到所有权之后，ARC在这个对象用完之后会进行释放。__bridge_retained和__bridge_transfer类似，只是__bridge_retained用于将 Objective-C 对象转化为 CoreFoundation 对象，而__bridge_transfer用于将 CoreFoundation 对象转化为 Objective-C 对象。举个例子，假设[self someString]这个方法会返回一个NSString类型的值，现在要将NSString类型的值转化为CFStringRef类型，使用__bridge_retained的话，相当于告诉ARC，对于这个对象，你的所有权已经没有了，我要自己来管理了。所以，我们要手动在后面加上CFRelease()方法。CFStringRef value = (__bridge_retained CFStringRef)[self someString];UseCFStringValue(value);CFRelease(value);上面的例子来自于Mikeash。 总结一下就是： bridge会将非Objective-C对象和Objective-C对象进行转换，但并不会移交所有权。 bridge_transfer会将非Objective-C对象转化为Objective-C对象，同时会移交所有权，ARC会帮你释放这个对象。__bridge_retained会将Objective-C对象转化为非Objective-C对象，同时会移交所有权，你需要手动管理这个对象。 在内存管理上能够优化的点基础 1.用ARC去管理内存（Use ARC to Manage Memory） 2.适当的地方使用reuseIdentifier（Use a reuseIdentifier Where Appropriate） 3.尽可能设置视图为不透明（Set View as Opaque When Possible） 4.避免臃肿的XIBs文件（Avoid Fat XiBs） 5.不要阻塞主进程（Don’t Block the Main Thread） 6.调整图像视图中的图像尺寸（Size Images to Image Views） 7.选择正确集合（Choose the Correct Collection） 8.启用Gzip压缩（Enable GZIP Compression） 中级 9.重用和延迟加载视图（Reuse and Lazy Load Views） 10.缓存，缓存，缓存（Cache,Cache,Cache） 11.考虑绘图（Consider Drawing） 12.处理内存警告（Handle Memory Warnings） 13.重用大开销对象（Reuse Expensive Objects） 14.使用精灵表（Use Sprite Sheets ） 15.避免重复处理数据（Avoid Re-Processing Data） 16.选择正确的数据格式（Choose the Right Data Format） 17.适当的设置背景图片（Set Background Images Appropriately） 18.减少你的网络占用（Reduce Your Web Footprint） 19.设置阴影路径（Set the Shadow Path ） 20.你的表格视图Optimize Your Table Views） 21.选择正确的数据存储方式（Choose Correct Data Storage Option） 高级 22.加速启动时间（Speed up Launch Time ） 23.使用自动释放池（Use AutoRelease Pool） 24.缓存图像（Cache Images-Or not ） 25.尽可能避免日期格式化器（Avoid Date Formatters Where Possible） 举例图片残留instrument调试后，发现没被释放的全是imageIO，差不多就知道了，把读图的方式，从[UIImage imageNamed:@””],改成imageWithContentsOfFile，就可以了。2.png 问题原因： imageNamed读取图片的方法，会缓存在内存中，所以较大的图片，还是用imageWithContentsOfFile，比如说引导页背景(图片全屏, 有时候运行APP会显示, 有时候根本就用不到). TIPs1：.xcassets里的图片无法用imageWithContentsOfFile读取； TIPs2：imageWithContentsOfFile读取图片需要加文件后缀名如png，jpg等； 懒加载更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。 这里我们用到的技巧就是模仿UITableView和UICollectionView的操作:不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。 这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。 创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法： 创建并隐藏这个view当这个screen加载的时候，当需要时显示它； 当需要时才创建并展示。 每个方案都有其优缺点。用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。 第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。 比较两个对象对NSObject的实例进行比较，有2种不同的方式： 运算符 ==。 方法 - (BOOL)isEqual:(id)anotherInstance 它们的区别在于：方式一，是依据实例的内存地址来进行比较的。如果实例的内存地址相等，说明实例们是指向同一片内存区间，则肯定是相同的。方式二，则比较的是实例的可读属性hash。如果两实例的hash属性值相等，则认为这两个实例是相等的，- (BOOL)isEqual:返回真。 autoreleasepool使用场景我们读取一个文件，然后取其中某些内容，并且循环来做，就会导致文件数据在内存中堆积。 123456789101112131415NSArray *urls = &lt;# An array of file URLs #&gt;;for(NSURL *url in urls) &#123;@autoreleasepool &#123;NSError *error;NSString *fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];/* Process the string, creating and autoreleasing more objects. */&#125;&#125; 内存优化大的思路正确的 创建，懒加载 销毁，autoreleasepool 缓存，高频率，小图，高度等，其他不该缓存的不缓存比如大图 复用，大对象]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中的视图渲染流程 iOS Rendering Process]]></title>
    <url>%2F2015%2F06%2F26%2F2015%2FiOS%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[从软件层面上，iOS借助Core Graohics，Core Animation，Core Image完成图形的处理，它们又都是借助OpenGL ES来完成底层的工作，如下图 计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。 在 iOS上，动画和视图的渲染其实是在另外一个进程做的（下面我们叫这个进程 render server），在 iOS 5 以前这个进程叫 SpringBoard，在 iOS 6 之后叫 BackBoard。 对Core Animation的理解，不能认为这是一个动画框架，其实之前它叫做Layer Kit CoreAnimation的渲染流程可以用下图来概括: 视图或者动画渲染的几个阶段在 APP 内部的有4个阶段 布局：在这个阶段，程序设置 View/Layer 的层级信息，设置 layer 的属性，如 frame，background color 等等。 创建 backing image：在这个阶段程序会创建 layer 的 backing image，无论是通过 setContents 将一个 image 传給 layer，还是通过 drawRect：或 drawLayer:inContext：来画出来的。所以 drawRect：等函数是在这个阶段被调用的。注意最终显示的图像 准备：在这个阶段，Core Animation 框架准备要渲染的 layer 的各种属性数据，以及要做的动画的参数，准备传递給 render server。同时在这个阶段也会解压要渲染的 image。（除了用 imageNamed：方法从 bundle 加载的 image 会立刻解压之外，其他的比如直接从硬盘读入，或者从网络上下载的 image 不会立刻解压，只有在真正要渲染的时候才会解压）。 提交：在这个阶段，Core Animation 打包 layer 的信息以及需要做的动画的参数，通过 IPC（inter-Process Communication）传递給 render server。 在 APP 外部的2个阶段当这些数据到达 render server 后，会被反序列化成 render tree。然后 render server 会做下面的两件事： 根据 layer 的各种属性（如果是动画的，会计算动画 layer 的属性的中间值），用 OpenGL 准备渲染。 渲染这些可视的 layer 到屏幕。 具体的UIView绘制流程下面我们来对这个流程进行说明： 当我们调用[UIView setNeedsDisplay]方法时，并没有执行立即执行绘制工作。 而是马上调用[view.layer setNeedsDisplay]方法，给当前layer打上脏标记。在当前RunLoop快要结束的时候调用layer 的display方法，来进入到当前视图的真正绘制当中。 在layer的display方法内部，系统会判断layer的layer.delegate是否实现了displayLayer:方法，a.如果没有实现，则执行系统的绘制流程;b.如果实现了则会进入异步绘制的入口。 最后把绘制完的backing store（可以理解为位图）提交给GPU。 对流程加以说明： 在layer内部会创建一个backing store，我们可以理解为CGContextRef上下文。判断layer是否有delegate: 如果有delegate，则会执行[layer.delegate drawLayer:inContext]（这个方法的执行是在系统内部执行的），然后在这个方法中会调用view的drawRect:方法，也就是我们重写view的drawRect:方法才会被调用到。 如果没有delegate，会调用layer的drawInContext方法，也就是我们可以重写的layer的该方法，此刻会被调用到。 最后把绘制完的backing store（可以理解为位图）提交给GPU。 与runloop的关系 View的绘制与CPU View的绘制与GPUGPU功能GPU处理的单位是Texture基本上我们控制GPU都是通过OpenGL来完成的，但是从bitmap到Texture之间需要一座桥梁，Core Animation正好充当了这个角色：Core Animation对OpenGL的api有一层封装，当我们的要渲染的layer已经有了bitmap content的时候，这个content一般来说是一个CGImageRef，CoreAnimation会创建一个OpenGL的Texture并将CGImageRef（bitmap）和这个Texture绑定，通过TextureID来标识。这个对应关系建立起来之后，剩下的任务就是GPU如何将Texture渲染到屏幕上了。 GPU工作模式：整个过程也就是一件事：CPU将准备好的bitmap放到RAM里，GPU去搬这快内存到VRAM中处理。而这个过程GPU所能承受的极限大概在16.7ms完成一帧的处理，所以最开始提到的60fps其实就是GPU能处理的最高频率。 GPU性能瓶颈因此，GPU的挑战有两个：• 将数据从RAM搬到VRAM中• 将Texture渲染到屏幕上这两个中瓶颈基本在第二点上。渲染Texture基本要处理这么几个问题： Compositing：Compositing是指将多个纹理拼到一起的过程，对应UIKit，是指处理多个view合到一起的情况，如 [self.view addsubview : subview]1如果view之间没有叠加，那么GPU只需要做普通渲染即可。 如果多个view之间有叠加部分，GPU需要做blending。加入两个view大小相同，一个叠加在另一个上面，那么计算公式如下： R = S+D*(1-Sa) R: 为最终的像素值S: 代表 上面的Texture（Top Texture）D: 代表下面的Texture(lower Texture)Sa代表Texture的alpha值。其中S,D都已经pre-multiplied各自的alpha值。假如Top Texture（上层view）的alpha值为1，即不透明。那么它会遮住下层的Texture。即,R = S。是合理的。 假如Top Texture（上层view）的alpha值为0.5，S 为 (1,0,0)，乘以alpha后为(0.5,0,0）。D为(0，0，1)。 得到的R为（0.5，0，0.5）。基本上每个像素点都需要这么计算一次。因此，view的层级很复杂，或者view都是半透明的（alpha值不为1）都会带来GPU额外的计算工作。应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。 Size这个问题，主要是处理image带来的，假如内存里有一张400x400的图片，要放到100x100的imageview里，如果不做任何处理，直接丢进去，问题就大了，这意味着，GPU需要对大图进行缩放到小的区域显示，需要做像素点的sampling，这种smapling的代价很高，又需要兼顾pixel alignment。计算量会飙升。 shouldRasterize其中shouldRasterize（光栅化）是比较特别的一种：光栅化概念：将图转化为一个个栅格组成的图象。光栅化特点：每个元素对应帧缓冲区中的一像素。 shouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。 相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。 当你使用光栅化时，你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用，红色表示缓存在被重复创建。 如果光栅化的层变红得太频繁那么光栅化对优化可能没有多少用处。位图缓存从内存中删除又重新创建得太过频繁，红色表明缓存重建得太迟。可以针对性的选择某个较小而较深的层结构进行光栅化，来尝试减少渲染时间。 注意：对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费 例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。 Offscreen Rendering And Mask（离屏渲染）GPU屏幕渲染有以下两种方式： On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。 Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。 相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面： 创建新缓冲区要想进行离屏渲染，首先要创建一个新的缓冲区。 上下文切换&gt;离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。 设置了以下属性时，都会触发离屏绘制： shouldRasterize（光栅化）masks（遮罩）shadows（阴影）edge antialiasing（抗锯齿）group opacity（不透明）复杂形状设置圆角等渐变 为什么会使用离屏渲染当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染被唤起。 屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。 渲染优化理论需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。 而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。 在开发时需要根据实际情况来选择最优的实现方式，尽量使用On-Screen Rendering。简单的Off-Screen Rendering可以考虑使用Core Graphics让CPU来渲染。 常见的几个问题图像多层次的合成—为何设置透明会增加GPU工作量所以当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，因为可以直接使用最上边的纹理，而不需要计算多个纹理的融合，这也是为什么 CALayer 有一个叫做 opaque 的属性了。如果这个属性为 NO，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)。 关于卡顿的简单原理解释 在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。最直接的理解，当我们拖动屏幕的时候，画面跟不上手指的移动，因为总是需要显示上一个或者上几个画面的内容。 从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。 扩展: 关于缓冲区的优化经历了三个阶段，最开始是单缓冲区，GPU等待屏幕读取完成之后再写入，有一个效率问题，后来发展为双缓冲区，这个时候的问题在于，缓冲区的切换是由GPU控制的，当GPU在缓冲区写入完成之后就会切换指针，这个时候的问题在于屏幕显示了一半A缓冲区间的内容，然后还显示了一半B缓冲区的内容，解决办法是加了一个垂直同步，也就是说GPU写缓存要等着屏幕的命令，当屏幕开始这一次读取的时候，CPU和GPU开始工作，最终写入缓存，当下一次开始读屏幕的时候会去检查B缓存区是不是更新写入了，如果没有写入就不更新指针，这次刷新仍然读取A，然后GPU这个时候还在写入，当写入成功了只能等着下次有机会显示在屏幕上了。这样就将指针指向切换的触发器由GPU写入完成切换为，屏幕读取完成并且写入成功，引入的新的问题是掉帧。 drawRect导致内存暴增的原理drawRect恶魔 视图的本质是来自于CALayer的contents属性，这是一个CGImage的类型，contents也被称为寄宿图，除了给它赋值CGImage之外，我们也可以直接对它进行绘制，绘制的方法正是这次问题的关键，通过继承UIView并实现-drawRect:方法即可自定义绘制。-drawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，UIView不关心绘制的内容。如果UIView检测到-drawRect:方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以contentsScale(这个属性与屏幕分辨率有关，我们的画板程序在不同模拟器下呈现的内存用量不同也是因为它)的值 我们经常在drawrect方法里绘制代码，但该方法是谁调用的 何时调用的？[self.view addSubview:view][CALayer drawInContext:][UIView(CALayerDelegate) drawLayer:inContext:][ZYYView drawRect:] drawrect方法内为何第一行代码总要获取图形的上下文每一个UIView都有一个layer，每一个layer都有个content，这个content指向的是一块缓存，叫做backing store当UIView被绘制时（从 CA::Transaction::commit:以后），CPU执行drawRect，通过context将数据写入backing store当backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上所以在 drawRect 方法中 要首先获取 context layer的代理必须是view吗，可以是vc吗？为何CALayerDelegate 不能主动遵循？ 不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。UIViewController是可以的。在设置代理的时候，它并不要求我们遵守协议，说明这个方法为非正式协议，就不需要再额外的显示遵守协议了 iOS 为什么必须在主线程中操作UI因为UIKit不是线程安全的。试想下面这几种情况： 两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。 两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。 两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。 iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议讲UI操作保证在主线程中执行。 如何扩大button的点击范围本质是扩大hittest方法内rect的大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import &quot;UIButton+EnlargeTouchArea.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIButton (EnlargeTouchArea)static char topNameKey;static char rightNameKey;static char bottomNameKey;static char leftNameKey;- (void) setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left&#123; objc_setAssociatedObject(self, &amp;topNameKey, [NSNumber numberWithFloat:top], OBJC_ASSOCIATION_COPY_NONATOMIC); objc_setAssociatedObject(self, &amp;rightNameKey, [NSNumber numberWithFloat:right], OBJC_ASSOCIATION_COPY_NONATOMIC); objc_setAssociatedObject(self, &amp;bottomNameKey, [NSNumber numberWithFloat:bottom], OBJC_ASSOCIATION_COPY_NONATOMIC); objc_setAssociatedObject(self, &amp;leftNameKey, [NSNumber numberWithFloat:left], OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (CGRect) enlargedRect&#123; NSNumber* topEdge = objc_getAssociatedObject(self, &amp;topNameKey); NSNumber* rightEdge = objc_getAssociatedObject(self, &amp;rightNameKey); NSNumber* bottomEdge = objc_getAssociatedObject(self, &amp;bottomNameKey); NSNumber* leftEdge = objc_getAssociatedObject(self, &amp;leftNameKey); if (topEdge &amp;&amp; rightEdge &amp;&amp; bottomEdge &amp;&amp; leftEdge) &#123; return CGRectMake(self.bounds.origin.x - leftEdge.floatValue, self.bounds.origin.y - topEdge.floatValue, self.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue, self.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue); &#125; else &#123; return self.bounds; &#125;&#125;- (UIView*) hitTest:(CGPoint) point withEvent:(UIEvent*) event&#123; CGRect rect = [self enlargedRect]; if (CGRectEqualToRect(rect, self.bounds)) &#123; return [super hitTest:point withEvent:event]; &#125; return CGRectContainsPoint(rect, point) ? self : nil;&#125;@end 另外一种风格 123456789101112131415161718192021222324252627282930313233343536373839@interface UIButton (UIButtonTouchHighlighted)@property (nonatomic, strong) CALayer *highlightedLayer;-(void)addButtonHighlightedLayer:(CGRect)frame;@end@implementation UIButton (UIButtonTouchHighlighted)@dynamic highlightedLayer;- (void)setHighlightedLayer:(CALayer *)highlightedLayer&#123; objc_setAssociatedObject(self, @selector(highlightedLayer), highlightedLayer, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //这里可以用一个字符串作为key，也可以用这种@selector作为一个key，这样的话，下边我们就直接用这个get的名字来取，也是很方便，这个实现的这正的就是一个get方法。&#125;- (CALayer *)highlightedLayer&#123; return objc_getAssociatedObject(self, _cmd);&#125;-(void)addButtonHighlightedLayer:(CGRect)frame&#123; if (!self.highlightedLayer) &#123; self.highlightedLayer = [CALayer layer]; [self.layer insertSublayer:self.highlightedLayer atIndex:0]; self.highlightedLayer.backgroundColor = [UIColor colorWithWhite:0 alpha:0.15].CGColor; self.highlightedLayer.hidden = YES; &#125; self.highlightedLayer.frame=CGRectMake(0, 0, frame.size.width, frame.size.height); [self addTarget:self action:@selector(btnTouchUpInSide_JR) forControlEvents:UIControlEventTouchUpInside]; [self addTarget:self action:@selector(btnTouchHighlighted_JR) forControlEvents:UIControlEventTouchDown]; [self addTarget:self action:@selector(btnTouchOutside_JR) forControlEvents:UIControlEventTouchUpOutside]; &#125;@end]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC中的各种变量]]></title>
    <url>%2F2015%2F06%2F10%2F2015%2FOC%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[首先看一下几个概念分类： 成员变量 属性 局部变量 全局变量 静态变量 = 全局变量 + static声明的局部变量 首先声明： 全局变量和静态变量都存在于全局内存区，在app生命周期内只初始化一次 局部变量存在于栈内存区 这里所讨论的是变量，而不是变量的值，这里两个概念int a = 10，a是变量，而10是它的值，这是两个概念 地位内存是全局变量区，高位内存是堆或者栈0x108eae3389位， 0x7fff56d52ad412位 成员变量var 定义：变量存活周期跟你定义的该类实体对象一样；作用域是整个实体对象；可以在h文件中声明或者在m文件中@implementation上面添加的 123456@interface CustomView1()&#123; UIView *_backView1;&#125;@property (nonatomic, strong) UIView *backView;@end 上边的两种写法都是对的，都代表是一个类的成员变量，只不过@property关键字做的事情比较多，上边类名称+()叫做extension，类扩展，如果有括号内加上名字叫做category，是分类。成员变量声明周期与类的对象相同。我们可以通过将一个对象赋值给成员变量来提升他的生命周期。 属性@property关键字标识的变量 全局变量 全局变量指的是存在于全局内存区，这个app声明周期只初始化一次，在所有的文件中不允许重名，下面的情况均属于全局变量.m文件中123456789101112131415161718int a;@interface CustomView1()@endint b;@implementation CustomView1int c;CustomView *_backView;- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; [self initSubViews]; &#125; return self;&#125;@end 说明：a，b，c均为全局变量 .h文件中1234int d;@interface CustomView1@end 说明：主要不是在interface关键字与end关键字之间都是全局变量，如果其他文件中有这个名字的变量，那么编译时不能够通过的 全局变量可以提供全部的外界访问，无论你定义在h文件或者是m文件中，并且无需引入头文件，但是我们需要再重新再定义一下这个变量，否则编译器是不会通过的，他怎么知道你有这个变量呢，你说是吧，所以我们可以像下边这样来使用 123456789101112131415161718192021222324252627282930#import &quot;ViewController.h&quot;#import &quot;CustomView1.h&quot;typedef void(^MyBlcok)();NSString * const waha = @&quot;lalala&quot;;@interface ViewController ()@property (nonatomic, copy) MyBlcok myBlock;@property (nonatomic, strong) UIView *backView;@end#import &quot;AppDelegate.h&quot;@interface AppDelegate ()@end@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. extern NSString *waha; NSLog(@&quot;appdelegate***%@---%p&quot;, waha, &amp;waha); return YES;&#125; 我们需要再重新定义一下这个变量，否则编译器是通不过的，不过要将这变量变为全局才可以，其实也就是改变一下它的内存位置，将其从栈移动到全局内存中去 static + 全局变量这种方式的话这个全局变量就会变成这个类所私有的，声明周期与该类相同，允许重名 iOS中使用全局变量的方法 静态变量 单例 在某个现成的单例中增加属性例如:appdelegate 局部变量除了全局变量剩下的都是局部变量，内存是在栈上的，如果用关键字static来修饰局部变量那么它就变成了一个静态变量，内存也到了全局变量区，只是生命周期发生了改变，但是作用域并没有发生变化。 如果用extern来修饰局部变量，那么它就会直接内存区变为全局区，生命周期和app一样了。如果后边再有其他的同名全局变量，编译器不会报错，但是后边生命的那个不会生效的，不过值还是允许改的。可以打印来验证一下，无论你在后边声明多少个该同名变量，他们的地址总是一样的。 常量与const关键字顾名思义，常量就是不能被修改的变量，说到这里我就有一个疑问，这个跟宏有啥区别？ const简介：之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。 编译时刻:宏是预编译（编译之前处理），const是编译阶段。 编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。 宏的好处:宏能定义一些函数，方法。 const不能。 宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。 注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存 我们确实可以选择使用宏来定义一个常量，然后给很多地方使用，当我需要改变这个变量的时候，我只要改变这个宏后边的值就可以了，使用的场景比如： 项目中的url 项目中的屏幕尺寸 项目中的某些特定颜色和尺寸 有些地方宏会体现出它的优势，比如一些代码块的替换，具体来说，比如屏幕的尺寸的获取，比如weakSelf的定义，但是使用常量的情况使用宏是有些问题的，就是因为宏是没有类型判断的，那么如果某个CGFloat的值，我们使用了宏，那么编译阶段就不会警告任何错误，哪怕你定义了一个NSString类型的宏，然后你又把它当做了CGFloat来使用，所以对于某些值得定义，我们要使用类型常量，而不用宏来定义，比如： 动画时间 按钮尺寸 文字尺寸 等等 具体来讲又可能分为三种情况： 全部文件都使用 只给自己使用 我们先来看看给自己使用的常量的定义： 1234567891011#import &quot;key1.h&quot;static const NSTimeInterval kAnimationDuration = 0.2;@interface key1()@end@implementation key1@end 要点有两个： 要用static和const同时来声明 声明在关键字之外 声明在关键字之外那么就是全局变量，又因为是给自己用的，所以要加上static做限制，而const是为了防止这个变量在后边被修改 再来看一下全局使用的常量，此类常量需要放在全局符号表,下面我们来看一下给全局使用的常量是如何来定义的：12345//In the header fileextern NSString *const EOCStringConst;//这样的const的位置意味着这个指针是一个常量//In the implementation fileNSString *const EOCStringConstant = @&quot;VALUE&quot;; 这种常量一般在头文件中声明，然后在实现文件中定义，注意const的位置，不允许更改指针的指向，另外编译器看到extern关键字，就明白在全局符号表中将会有一个名字叫EOCStringConstant的符号了， static和extern static作用： 修饰局部变量 延长局部变量的生命周期 局部变量只会生成一份内存，初始化一次 改变局部变量的作用域 修饰全局变量 只能在本文件访问，修改全局变量的作用域，生命周期不变 避免重复定义全局变量 extern 作用：获取全局变量的值，不能用来定义变量 工作原理：现在当前文件查找有木有全局变量，没有的话才去其他文件查找 static和conststatic与const作用:声明一个只读的静态变量 extern与const联合使用 开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合。 原因:static与const组合：在每个文件都需要定义一份静态全局变量。 extern与const组合:只需要定义一份全局变量，多个文件共享。 全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。 123456789101112GlobeConst.h/*******************************首页****************************/extern NSString * const nameKey = @&quot;name&quot;;/*******************************首页****************************/GlobeConst.m#import &lt;Foundation/Foundation.h&gt;/*******************************首页****************************/NSString * const nameKey = @&quot;name&quot;;/*******************************首页****************************/ 我们现在来理解一下上面的代码，其实应该反过来看，首先我们在.m文件中声明并且对nameKey进行了赋值，所以我们在.h文件中才可以通过extern来取到nameKey的值，并且使用，其实我们完全可以在其他地方进行nameKey的取值，比如另外一个不相关的.m文件，只不过这样做会比较繁琐，需要重新声明这个变量，所以我们统一将这些个静态变量以extern的方式声明出来，放在.h文件中，让其他的文件调用，注意，这里是不能进行赋值操作的 这里做一个辨析：全局变量并不是因为你用extern关键字，全局变量是由你变量声明的位置所决定的，而extern其实是一个取值的操作，同时告诉编译器这个变量无论声明在哪里，我知道这个全局变量是存在的，放心的使用就好，但是如果真的这个全局变量是不存在的，比如说你把它声明定义在了某个函数内部，那么这个时候肯定报错了另外我们使用extern NSString *name = @&quot;名字&quot;这种写法是没有意义的，因为extern是取值操作，这样写编译器也会报错的 关于extern关键字总结如下： Declaration can be done any number of times but definition only once. “extern” keyword is used to extend the visibility of variables/functions(). Since functions are visible through out the program by default. The use of extern is not needed in function declaration/definition. Its use is redundant. When extern is used with a variable, it’s only declared not defined. As an exception, when an extern variable is declared with initialization, it is taken as definition of the variable as well. weak 与 strong当我们定义一个变量的时候12UIView *view;view = [UIView alloc] init]; 其实这个view前边默认有一个关键字，那就是__strong，这是因为这个关键字，所以我们的=赋值的时候，是一个强引用，所以alloc创建出来的对象是不会被释放的，又因为view这个变量被定义在栈上，所以当代码执行到一个函数结束的时候，这个view变量会被释放，这样alloc出来的对象就失去了强引用，这部分内存也将被系统所回收。 现在我们来理解一下block的赋值操作，我们知道，当一个block被创建的时候，假如没有捕获变量，那么这个block是定义在全局的，对全局block做一个强引用的赋值操作是不会改变它的存储位置的，如果这个block捕获了一个栈上的变量，那么这个block就会被移动到栈上，这个时候如果我们对这个block做了一个强引用的赋值操作，这个block就被移动到了堆上。内存管理策略就变成了是否有强指针引用 使用常量替换宏定义使用宏定义过多的话，随着工程越来越大，编译速度会越来越慢。1234567static CGFloat const kLogoImageWidth = 100; //logo宽度static CGFloat const kLogoImageHeight = 100; //logo宽度static CGFloat const kLogoImageY = 110;static CGFloat const kBtnHeight = 40;static CGFloat const kPadding = 30;static CGFloat const kWeixinTopPadding = 15;static CGFloat const kWeiboLoginBottom = 230;#define kScaleSpace(designSpace) ((designSpace)(SCREEN_HEIGHT/667.0)) //根据iphone6 的设计稿计算缩放高度 替换完成之后代码的编译速度确实上去了，现在编译快了。希望对正在为编译速度慢感到困惑的您有所帮助 补充说明：以上的类型常量替换宏的情况，只是适用于单个文件的情况。如果是多个文件共享的常量，苹果推荐的这样的方式： 12345678910111213UserInfoModelConstants.hextern NSString *const USER_AGE_KEY ;extern NSString *const USER_TELPHONE_KEY ;extern NSString *const USER_ADDRESS_KEY ;extern NSString *const USER_BRIEF_KEY ;UserInfoModelConstants.mNSString *const BKUSER_AGE_KEY = @&quot;XXXXX.userAge&quot;;NSString *const BKUSER_TELPHONE_KEY = @&quot;XXXXX.telphoneNO&quot;;NSString *const BKUSER_ADDRESS_KEY = @&quot;XXXXX.address&quot;;NSString *const BKUSER_BRIEF_KEY = @&quot;XXXXX.brief&quot;; 在需要使用共享常量的文件中引入UserInfoModelConstants.h即可。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block使用总结]]></title>
    <url>%2F2015%2F05%2F02%2F2015%2FBlock%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[block用来保存一段代码，在需要的时候回调，是对闭包的实现 所以，切勿将过程代码当做block的实际实现，切记切记！！！ block的声明123456789101112131415161718192021222324252627//变量void (^myBlock)();int (^myBlock1)(int, int);//属性1typydef void(^Myblock)();//这样Myblock就代表一个block类型了@property (nonatomic, copy) Myblock myblock; //属性2@property (nonatomic, copy) void(^myBlock)(int);//这样仍然是一个block，而且名字就是myBlock//参数- (void) modifyUserInfoWithNickName:(NSString *) nickName userLogo:(NSString *) userLogo sex:(NSNumber *) sex location:(NSString *) location succeed:(void(^)())successBlock fail:(void(^)(NSError *error))errorBlock; //这个时候的格式就变成了(返回+(^)(参数))名字 也可以这样typedef void(^FXSuccessBlock)(id result);typedef void(^FXFailBlock)(NSError *error);- (void)onlyGetLoginUserInfo:(FXSuccessBlock)successHandler failHandler:(FXFailBlock)failHandler; block声明的格式：返回值 + block名字 + 参数 block实现block实现的格式：^(参数){} 注意block实现是要加上变量名字的123self.loginBlock = ^(BOOL complete) &#123; NSLog(@&quot;登录成功&quot;);&#125;; 或者有种偷巧的写法，就是利用set方法123[self setLoginSucBlock:^(BOOL complete) &#123; NSLog(@&quot;登录成功&quot;); &#125;]; Block对外部变量的管理基本数据类型1、局部变量局部自动变量，在Block中只读。Block定义时copy变量的值，在Block中作为常量使用，所以即使变量的值在Block外改变，也不影响他在Block中的值。12345678int base = 100;long (^sum)(int, int) = ^ long (int a, int b) &#123; return base + a + b;&#125;;base = 0;PRintf(&quot;%ld\n&quot;,sum(1,2));// 这里输出是103，而不是3, 因为块内base为拷贝的常量 100&#125; //进入block的是值，而不是地址，因为这个变量是定义在栈内存中的，随时可能被释放，所以我要将它的值copy进来，防止我使用的时候取不到 2、STATIC修饰符的全局变量因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。 加入一个变量定义在函数之外，那么这个变量是全局变量。 123456789static int a = 10; int(^sum)(int) =^(int b) &#123; return a + b;&#125;;a = 0;NSLog(@&quot;----%d&quot;, sum(2));//2 //进入block的是地址而不是值，因为static修饰的变量在内存中存在于静态变量区，是不会被回收或者释放的，即使释放了，也会在爱disk中有备份，当我们使用的时候再创建然后赋值给我就好了，所以不用担心被销毁，所以用地址就好了 3.__block修饰的变量被__block修饰的变量称作Block变量。 基本类型的Block变量等效于全局变量、或静态变量。 12345678910 __block int a = 10; int(^sum)(int) =^(int b) &#123; return a + b;&#125;;a = 0;NSLog(@&quot;----%d&quot;, sum(2));//2//进入block的是地址而不是值，这个道理与static是一致的 注意：如果我们用NSString来验证对象的block的内存管理是没有意义的，因为，某几种情况下NSString对象是存放在常量区的，相当于int这种变量 补充：123NSString *name = @&quot;han&quot;;NSLog(&quot;%p&quot;, name);//打印的是@&quot;han&quot;的地址NSLog(&quot;%p&quot;, &amp;name);//打印的是name这个指针的地址 对象对象一定是存在于堆上的，所以决定要不要拷贝指针的关键在于引用的指针123456789101112131415161718@implementation ViewControllerUIView *view;- (void)viewDidLoad &#123; [super viewDidLoad]; view = [[UIView alloc] init]; void(^stackBlock)() = ^() &#123; NSLog(@&quot;&amp;&amp;&amp;&amp;&amp;%p&quot;, &amp;view); &#125;; NSLog(@&quot;****%p&quot;, &amp;view); stackBlock();&#125;@end//2016-07-11 20:47:36.908 block[1906:517460] ****0x1000d1208//2016-07-11 20:47:36.909 block[1906:517460] &amp;&amp;&amp;&amp;&amp;0x1000d1208 现在是一个全局变量来引用UIView，我们发现指针直接就是原来的地址，并没有发生变化， 123456789101112131415161718192021@implementation ViewControllervoid(^globalBlock)();int a;//UIView *view;- (void)viewDidLoad &#123; [super viewDidLoad]; UIView *view = [[UIView alloc] init]; void(^stackBlock)() = ^() &#123; NSLog(@&quot;&amp;&amp;&amp;&amp;&amp;%p&quot;, &amp;view); &#125;; NSLog(@&quot;****%p&quot;, &amp;view); stackBlock();&#125;//2016-07-11 21:00:51.055 block[1916:519453] ****0x16fd69f28//2016-07-11 21:00:51.056 block[1916:519453] &amp;&amp;&amp;&amp;&amp;0x13563a480 很明显是两个指针 那如果是一个成员变量会是什么效果呢？经过验证也是同一个指针。一个指针和两个指针有啥区别呢？答案就是，如果是两个指针的话，那么即使你外边的指针释放掉，这个对象也是释放不掉的，如果这个block不释放的话，所以如果这个block是一个全局的block这个对象也就没有释放的可能了。解决的方案就是，传入一个弱引用的指针，这样起码这个被引用的对象是不会因为block而不能释放了。从这个角度来理解，为什么会存在堆，栈，全局block，因为如果我引用了某个变量，而这个变量是在栈上的，那么不能因为被block引用而不释放这个变量，所以解决方案就是直接copy一份这个变量的值进来block结构体，用一个指针去引用，而如果引用了一个全局的变量，那么就不存在释放不掉的问题了，那么就不用再复制一份了。 一个block值创建的时候是在全局区的 如果这个时候给我引用了一个全局的变量，那么我仍然在全局 如果这个时候给我引用一个局部变量，那么这个block就会被移动到栈上，这里要注意的是成员变量与局部变量同等对待，因为它毕竟不在全局变量区，但是捕获成员变量的时候，因为这个变量是不会被轻易释放的，所以不会copy这个指针 这个时候如果你在ARC情况下对这个block做一个赋值操作，如果之前这个block在栈上，那么一个strong引用操作之后这个block就被移动到堆上了 //todo autorelease关键字起作用在arc下，需要这个对象是一个autorelease对象，默认情况下，UIView不是这样的对象，其他的是这样的对象，所以 123@autorelease &#123; UIView *view = [UIView alloc] init];//内存会一直增加，不会释放的，以为UIView不会被释放，如果这个换成UIImage或者其他的，那就没有问题&#125; block是不是对象是，因为内存中使用了isa指针的概念]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中的屏幕旋转]]></title>
    <url>%2F2015%2F04%2F12%2F2015%2FiOS%E4%B8%AD%E7%9A%84%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[总述 旋转事件只传递给主window 当我们使用webView播放视频的时候，它会创建一个UIViewController，然后创建一个window，让这个控制器成为这个window的根控制器，然后再将视频显示的view添加到这个UIViewController的控制器view上 屏幕选中的本质是当前主控制器的view跟随屏幕的旋转而旋转，并且调整大小至当前的宽高，所以我们要做的就是控制当前控制器要不要旋转 再本质一些就是，要对当前keywindon的根控制器进行控制＋对你要旋转的界面进行控制 详述第一层设置在这里选择是否支持横竖屏 第二层设置123- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123; return UIInterfaceOrientationMaskAll;&#125; 在Appdelegate中进行设置，实现这个方法，在这里返回你要支持的方向，这个设置会覆盖上边在general中的设置 第三层设置在window的根控制器中实现这两个方法，来加以控制，是否允许旋转以及支持的方向123456789//是否允许旋转- (BOOL)shouldAutorotate &#123; return YES;&#125;//旋转的时候支持的方向- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskAll;&#125; 第四层设置在你要控制是否旋转的这个控制里边实现上边的这两个方法 小结 当屏幕旋转一次就会调用一次这个方法，来询问支持的方向 这里返回的window是Appdelegate这个对象持有的window，也就是说，即使中间你换掉了keywindow这里返回的仍然只是最开始创建的那个window，也就是说，对你最后创建的window这个方法并不能影响 一个控制器到底是否支持横屏，自己说了是不算的，主要看两个东西 AppDelegate中的这个方法返回支持的方向 window的根控制器中是否允许旋转，以及支持的方向 取交集 上边的的四层设置起作用的情况，我们要分三种情况来说 要控制的控制器间接依附最开始创建的window 该控制器是通过navigationcontroller管理的/直接添加childcontrollers present… 要控制的控制器依附于新创建的window 原始window 受到Appdelegate中的方法的影响 如果控制器是modal出来的，那么该控制器中实现的这两个方法会生效，但是依然遵循交集的原则 如果这个控制器是navigationController管理或者直接添加childcontrollers，该控制器中的方法是没有作用的，它只受到appdelegate和window根控制器的影响 依附于新创建的window 不受到APPdelegate方法的影响 其它都一样，但是分析的起点就变成了当前window的根控制器 比如，webView播放视频的时候，它会新创建window，并且以UIViewController为根控制器，所以我们应该在这个控制器中添加控制代码，但是这个是系统的类，我们就只能靠分类来添加代码了 demo整体是支持横屏，但是某个界面禁止根据上边叙述，我们可以得到以下方案： 通过present…来管理控制器 在这个控制器中添加控制器代码，禁止旋转或者只支持竖着123456789101112131415 @implementation HSViewController- (void)viewDidLoad &#123; [super viewDidLoad];&#125;- (BOOL)shouldAutorotate &#123; return YES;&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskPortrait;&#125;@end 不通过present来管理界面 通过在Appdelegate或者根控制器中加判断代码，实现在不同的当前控制器，返回不同的支持的方向 123456789101112 - (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123; HSNavigationContronller *nav = (HSNavigationContronller *)[UIApplication sharedApplication].keyWindow.rootViewController; if ([nav.topViewController isKindOfClass:[HSViewController class]]) &#123; return UIInterfaceOrientationMaskPortrait; &#125; return UIInterfaceOrientationMaskAll; &#125; 整体是支持竖屏，但是某个界面可以横屏这种需求，只能通过加判断代码来做到 控制通过webView加载的视频全屏时的横竖屏webView的视频在全屏的时候，会新创建一个window，所以你在Appdelegate或者当前根控制器下的控制代码统统不会生效，并且以UIViewController为根控制器，所以我们要把控制代码加到UIViewController的分类中，又因为其它的控制器全部继承自这个控制器，所以我们要在这个里边加判断1234567891011121314151617181920212223242526#import &quot;UIViewController+Extension.h&quot;@implementation UIViewController (Extension)#pragma mark - 下面的两个方法主要用于控制webView播放视屏的时候，该是否是否应该横屏/** * 如果当前keywindow的rootController类型为UIViewController，就返回YES，否则返回NO * * @return 返回是否 */- (BOOL)shouldAutorotate &#123; //拿到当前主窗口的根控制器类型名称 NSString *className = NSStringFromClass([[UIApplication sharedApplication].keyWindow.rootViewController class]); //如果是UIViewController就返回YES，让这个控制器view可以跟随屏幕旋转 if ([className isEqualToString:@&quot;UIViewController&quot;]) &#123; return YES; &#125; else &#123; return NO; &#125;&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskAll;&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用总结]]></title>
    <url>%2F2015%2F04%2F10%2F2015%2FGit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.配置：1.设置你的名字与邮箱（可与 git 帐号无关）： git config --global user.name &quot;Your Name&quot;git config --global user.email your@email.com 缓存一段时间的 git 帐号密码（timeout 单位：秒）： git config --global credential.helper &quot;cache --timeout=3600&quot; 2.克隆、签出仓库：git clone &lt;url&gt; 服务器一般会给出两种连接方式 一种是SSH:需要SSH加密 一种是HTTP:直接可以用 以上边的地址为例：git clone http://10.16.1.16/iOS/gitintro.git这样它默认会将文件以gitintro为名，建立在当前文件路径下自定义：git clone http://10.16.1.16/iOS/gitintro.git mygit这样写它会将文件夹的名字从gitintro改为mygit 另外：如果该项目使用了，git submodule子模块 技术，那么还需要增加另外两步操作： git submodule init git submodule update 或者一步到位git clone --recursive http://10.16.1.16/iOS/gitintro.git mygit 3.自建仓库只要是一个文件夹，然后进行git初始化就可以利用命令行将当前目录切换到你要做仓库的那个文件夹，cd xxx然后初始化仓库git init 3.查看远程服务器：git remote -v 进阶：关联远程服务器：git reomte add &lt;origin&gt; &lt;git-repo-url&gt; 查看配置信息，包括 remote、分支关联、本地配置等：cat .git/config 2. 添加、删除、本地提交添加新文件，确认文件修改：git add &lt;file-path&gt; 取消添加新文件：git reset &lt;file-path&gt; 从 git 删除文件（不再在 repo 里管理了）：git rm &lt;file-path&gt; 查看本地未确认的修改（代码、内容变更）：git diff 查看本地已确认（但未提交）的修改：git diff --cached 查看本地修改的文件状态：git status 本地提交（提交上述 add\rm 确认的修改、操作），生成一个版本：git commit -m &quot;short commit message&quot; 追加到上一次本地提交：git commit --amend 查看提交记录：git log 简化版git reflog 查看提交的详细修改记录：git log -p 查看提交修改的文件信息：git log --stat 其它：让当前修改 AFK 一下，好干点别的事情：git stash事情做完，把 AFK 前的修改找回来：git stash pop 3. 撤消撤销一个文件的修改：git checkout -- &lt;file-path&gt; 撤销当前目录的所有修改：git checkout -- . 删除某个文件git rm xxxx 4.版本回退回退到任意版本，需要拿到commit idgit reset --hard 3628164回退到上一个版本 git reset --hard HEAD^ 回退到上100个版本 git reset --hard HEAD~100 但是这样简单的操作只能是把本地的工作空间的内容进行回退，那么如果我想要让远程库也回退怎么办呢？ 回想一下原理，当你对这个分支进行pull的时候 它会去版本库去检查有没有冲突 如果没有那么它直接会覆盖工作空间 如果有冲突它才会提示你解决冲突 那么现在，如果我已经到了第五个 commit，但是我想要回到第3个commit的状态，git reset --hard 87b6a3b你想要把这个状态更新到远程，先要commit，你会发现你commit是无效的，因为你这个commit已经存在了，一摸一样，所以你是不能commit的，现在要自己制造一些修改，然后再commit，就可以了。 所以远程版本回退的根本是制造冲突，然后提交冲突 那么如果是这个文件已经删除了那么这个时候怎么办呢？答案是： 本地进行版本回退git reset --hard 76824 打开这个又恢复的文件，然后修改一些东西 执行 add commit 然后执行pull，最新的修改从远程拉回来，这个时候它会报冲突 它说，这个冲突是修改和删除的冲突，也就是说，一个版本库中它已经被删除了，可是在另外一个版本库中它是被修改的，现在你就要解决冲突，怎么解决呢？原来的冲突最多是这个文件中的代码不一致了，这个时候找你打开代码，删删剪剪就好了，可是现在文件直接没有了咋弄？再次git pull它说你可以用git add/rm xxx来决定你是保留冲突中的哪一方 5. 分支创建分支（基于当前分支）：git branch &lt;new-branch&gt; 基于某个分支创建分支：git branch &lt;new-branch&gt; &lt;base-branch&gt; 查看本地分支：git branch 切换分支：git checkout &lt;branch&gt; 创建新分支并立即切过去：git checkout -b &lt;new-branch&gt; [base-branch] 合并一个分支到当前分支（删除该分支后不保留commit纪录）：git merge &lt;other-branch&gt; 合并分支且删除该分支后保留commit纪录git merge --no-ff -m&quot;xxx&quot; &lt;other-branch&gt; 回滚一个分支的合并：git revert -m (1|2) &lt;merge-commit&gt;参考： http://pms.kugou.com/zentao/doc-view-171.html rebase 把分支的 commit 在基础分支上重放（与 merge 的区别很重要，请只在本地分支 rebase！！！）：git rebase &lt;base-branch&gt; 安全删除（已经合并过的）本地分支：git branch -d &lt;branch&gt; 强行删除本地分支（请先 -d，如果 -d 失败，检查无误后才 -D）：git branch -D &lt;branch&gt; 6. 跟服务器同步：查看远程分支：git branch -r 签出服务器分支工作（会创建本地与服务器分支关联）：git checkout &lt;remote-branch-name&gt;或git checkout -b &lt;local-branch-name&gt; origin/&lt;remote-branch-name&gt; （已存在的）本地分支关联到服务器分支：git branch -u origin/&lt;remote-branch&gt; &lt;local-branch&gt;或：git branch --set-upstream-to=origin/&lt;remote-branch&gt; &lt;local-branch&gt; 获取服务器（所有的）更新，并合并当前远程分支的更新：git pull 使用 rebase 的方式 pull，可能会少产生一条 merge 虚 commit：git pull --rebase 获取某个远程分支的更新（并且合并到当前分支！！）：git pull origin &lt;branch&gt; 仅拉取服务器更新，但不合并或 rebase：git fetch [origin [&lt;remote-branch-name&gt;]] rebase 当前分支已经 fetch 到本地的服务器更新：git rebase pushpush新建的本地分支并且建立连接git push --set-upstream origin &lt;local-branch&gt;git push origin &lt;local-branch&gt;git push -u origin &lt;local-branch&gt; 删除服务器远程分支：git push origin :&lt;remote-branch&gt;或 git 1.7 以后：git push origin --delete &lt;remote-branch&gt; push该分支的内容更新，前提是已经有默认的对应的分支，如果没有就会报错git push 但是这种方式不需要提前关联，因为你已经指明了，我打算把我这个分支推送给谁：git push origin &lt;branch&gt; 清除已被删除远程分支的本地残余：git remote prune origin 7.fork源码之后与源码保持同步1.切换到要保持同步的分支 2.添加一个别名，指向ngqa项目的位置git remote add ngqa https://github.com/howe/ngqa.git 3.pull一下它下边的某个分支，一定要确定一下这个分支是不是有内容git pull ngqa master 4.然后在sourcetree解决一下冲突，一般是点一下最下边的那个红色选框 5.然后git push 6.如果出现如下问题 “please enter a commit message to explain why this merge is necessary,especially if it merges an updated upstream into a topic branch 解决方案： 1-press “i”2-write your merge message3-press “esc”4-write “:wq” then press enter 8.配置SSH 查看git用户名git config user.name 查看git邮箱git config user.email 修改git用户名和邮箱git config --global user.name &quot;username&quot;git config --global user.email &quot;email&quot; 查看是否已经有了ssh密钥：cd ~/.ssh 生成SSHssh-keygen -t rsa -C &quot;你的邮箱&quot; 查看SSHcat ~/.ssh/id_rsa.pub将下面出现的这些个东西都拷贝到你的SSH面板中 9.问题集锦 如果你明明已经有了权限但是还是不能clone代码，那可能是服务器设置了DNS解析，你需要更改本机的DNS解析地址和服务器一致 冲突解决]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime源码下载]]></title>
    <url>%2F2015%2F04%2F02%2F2015%2FiOS%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[runtime源码需要了解runtime的实现原理https://opensource.apple.com/source/objc4/有各个版本，下载的命令 比如下载680wget -c -r -np -k -L -p https://opensource.apple.com/source/objc4/objc4-680/ CoreFoundation源码wget -c -r -np -k -L -p https://opensource.apple.com/source/CF/CF-855.17/ gnustep更多https://github.com/Microsoft/WinObjC https://github.com/BigZaphod/Chameleon]]></content>
      <tags>
        <tag>iOS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 配置/使用教程]]></title>
    <url>%2F2015%2F03%2F09%2F2015%2FHexo-%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[hexo安装 前提已经安装了node.js和git npm install hexo --no-optional hexo init myBlog//创建hexo的文件夹 cd myBlog npm install hexo server//打开对应的链接可看到效果 git配置 创建git仓库name/name.github.io 添加信息到配置文件_config.yml 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:xizhengmeng/xizhengmeng.github.io.git branch: master 安装插件npm install hexo-deployer-git --save 如果要访问这个网站直接xizhengmeng.github.io就好了 使用 进入博客所在的文件夹，比如我说的是~/myBlog hexo clean hexo g//生成 hexo d//推送到github服务器 hexo new &quot;fileName&quot;创建新的文件，在_post文件中 hexo new page fileName创建一个文件夹，然后在其中创建一个index.md文件，比如标签云页面，或者分类页面 绑定域名 申请域名，直接搜索hexo和github，域名和github绑定的问题 生成CNAME文件，并添加到source文件夹下，与post同级目录 更改配置文件–——config.ymlurl: www.hanson647.com 主题安装 进入Hexo文件的根目录cd Hexo 拉取主题文件，并在本地创建对应的文件git clone https://github.com/kathyqian/crisp-ghost-theme.git themes/gost 更改配置文件的主题为该主题 1theme: yilia 重新部署 主题更新git pull 使用了yelee主题，主题使用说明http://moxfive.coding.me/yelee/ 搜索功能配置 安装插件npm install --save hexo-generator-search 设置主题配置文件 123search: on: true onload: true 设置hexo配置文件 123search: path: search.xml field: post 重新生成 最后你会在publick文件中看到一个search.xml文件，最后你会在你的网站中看到你的搜索框 注意在工程的_config文件中，要将url对应的字段设置为/，否则你会发现搜索会自动加上一个前置的url，这样就又错乱了 添加标签以及标签云页面 创建tags页面hexo new page tags 直接在文章中的tags关键字后边添加对应的标签就好 12tags:- 工具 编辑刚才创建的tags页面，将其类型更改为tags 123title: tagsdate: type: &quot;tags&quot; 在主题配置文件中，将tags添加到menu中 1234menu: home: / archives: /archives tags: /tags 创建关于页面hexo new page about 容易出现的问题hexo d Error: ssh_exchange_identification: read: Connection reset by peer说明是网关的问题，我是解决了一下网络解决的，一开始连接的是京东的guest网络，出现该问题，切换为access解决 md文件格式标题中#号要与后边的标题留出间隙，也就是一个空格，否则hexo渲染是不认的 参考链接 next主题设置http://theme-next.iissnan.com hexo官网https://hexo.io/zh-cn/]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中的空值]]></title>
    <url>%2F2015%2F02%2F15%2F2015%2FiOS%E4%B8%AD%E7%9A%84%E7%A9%BA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[nil和NULL和Nil和NSNull的区别 nil nil 是 ObjC 对象的字面空值，对应 id 类型的对象，或者使用 @interface 声明的 ObjC 对象。 例如：12345678910111213141516171819202122NSString *someString = nil;NSURL *someURL = nil;id someObject = nil;if (anotherObject == nil) // do something- 定义：?// objc.h#ifndef nil# if __has_feature(cxx_nullptr)# define nil nullptr# else# define nil __DARWIN_NULL# endif#endif// __DARWIN_NULL in _types.h#define __DARWIN_NULL ((void *)0) Nil Nil 是 ObjC 类类型的书面空值，对应 Class 类型对象。 例如： 12Class someClass = Nil;Class anotherClass = [NSString class]; 定义声明和 nil 是差不多的，值相同：12345678// objc.h#ifndef Nil# if __has_feature(cxx_nullptr)# define Nil nullptr# else# define Nil __DARWIN_NULL# endif#endif NULL NULL 是任意的 C 指针空值。 例如：12345678910int *pointerToInt = NULL;- char *pointerToChar = NULL;- struct TreeNode *rootNode = NULL;- 定义：?// in stddef.h#define NULL ((void*)0) NSNull NSNull 是一个代表空值的类，是一个 ObjC 对象。实际上它只有一个单例方法：+[NSNull null]，一般用于表示集合中值为空的对象。 注意，这里NSNull是一个单例，也就是说同一个数组中，如果我们要删除这个空对象，那么只要调用一次removeobjec:方法就好了。 例子说明：12345678910111213// 因为 nil 被用来用为集合结束的标志，所以 nil 不能存储在 Foundation 集合里。NSArray *array = [NSArray arrayWithObjects:@&quot;one&quot;, @&quot;two&quot;, nil];-// 错误的使用NSMutableDictionary *dict = [NSMutableDictionary dictionary];[dict setObject:nil forKey:@&quot;someKey&quot;];-// 正确的使用NSMutableDictionary *dict = [NSMutableDictionary dictionary];[dict setObject:[NSNull null] forKey:@&quot;someKey&quot;]; ，对于像NSArray这样的类型，nil或NULL不能做为加到其中的Object，如果定义了一个NSArray，为其分配了内存，又想设置其中的内容为空，则可以用[NSNULL null返回的对对象来初始化NSArray中的内容，我的感觉有点像C语言中malloc一个内存空间，然后用memset初始化这段空间里的值为0。 由于服务器的数据库中有些字段为空，然后以Json形式返回给客户端时就会出现这样的数据：“somevalue”:null ，通过JsonKit 这个第三方库解析出来的数据就成了somevalue=””; 这个数据类型不是nil 也不是 String。 解析成对象之后，如果直接向这个对象发送消息（eg：length，count 等等）就会直接崩溃。提示错误为：-[NSNulllength]:unrecognizedselectorsenttoinstance0x388a4a70 ，这个就是NSNull类型的对象，代表空对象。 NIL 或 NSNilObjC 不存在这两个符号！ 小结 虽然 nil, Nil, NULL 的值相同，理解它们之间的书面意义才重要，让代码更加明确，增加可读性。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中的定时和延时]]></title>
    <url>%2F2015%2F01%2F23%2F2015%2FiOS%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%92%8C%E5%BB%B6%E6%97%B6%2F</url>
    <content type="text"><![CDATA[我们使用延时和定时可以使用以下方法： NSTimer NSTimer循环引用我们使用一个nstimer的时候，使用一个类方法来创建一个timer，返回一个timer指针，有时需要把tiemr加到runloop，有时系统自己来帮你做，你会发现，即使我并没有去强引用这个指针，timer只要在runloop中，timer就可以自然的回调，这是因为timer被runloop所引用，我们用控制器去引用这个timer，也只是增加了一个引用而已。 123456789101112131415161718192021222324+(id)scheduledTimerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats&#123; void (^block)() = [inBlock copy]; id ret = [self scheduledTimerWithTimeInterval:inTimeInterval target:self selector:@selector(jdExecuteSimpleBlock:) userInfo:block repeats:inRepeats]; [block release]; return ret;&#125;+(id)timerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats&#123; void (^block)() = [inBlock copy]; id ret = [self timerWithTimeInterval:inTimeInterval target:self selector:@selector(jdExecuteSimpleBlock:) userInfo:block repeats:inRepeats]; [block release]; return ret;&#125;+(void)jdExecuteSimpleBlock:(NSTimer *)inTimer;&#123; if([inTimer userInfo]) &#123; void (^block)() = (void (^)())[inTimer userInfo]; block(); &#125;&#125; 这也是Block实现的tiemr不会被释放的原因。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流媒体技术概述]]></title>
    <url>%2F2015%2F01%2F17%2F2015%2F%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是流媒体技术随着现代技术的发展，网络带给人们形式多样的信息，从第一张图片出现在网络上到如今各种形式的网络视频和三维动画，网络让人们的视听觉得到了很大的满足。然而在流媒体技术出现之前，人们必须要先下载这些多媒体内容到本地计算机，在漫长的等待之后（因为受限于带宽，下载通常要花上较长的时间），才可以看到或听到媒体传达的信息。令人欣慰的是，在流媒体技术出现之后，人们便无需再等待媒体完全下载完成了。流媒体就是指采用流式传输技术在网络上连续实时播放的媒体格式，如音频、视频或多媒体文件。流媒体技术也称流式媒体技术.所谓流媒体技术就是把连续的影像和声音信息经过压缩处理后放上网站服务器,由视频服务器向用户计算机顺序或实时地传送各个压缩包，让用户一边下载一边观看、收听，而不要等整个压缩文件下载到自己的计算机上才可以观看的网络传输技术。该技术先在使用者端的计算机上创建一个缓冲区，在播放前预先下一段数据作为缓冲，在网路实际连线速度小于播放所耗的速度时，播放程序就会取用一小段缓冲区内的数据，这样可以避免播放的中断，也使得播放品质得以保证。 流媒体技术的应用分类流媒体应用形式可以简单分为3类：点播型应用、直播型应用和会议型应用。 （1）点播型应用。点播型应用中，一般点播内容存放在服务器上，根据需要进行发布。在同一时间可多点点播相同或不同的节目，即多个终端可在不同的地点、不同的时刻，实时、交互式地点播同一流文件，用户可以通过门户查看和选择内容进行点播。根据用户的需要，点播过程中还可以实现播放、停止、暂停、快进、后退等功能。 （2）直播型应用。直播服务模式下，用户只能观看播放的内容，无法进行控制。 （3）会议型应用。会议型应用类似于直播型应用，但是两者有不同的要求，如双向通信等。这对一般双方都要有包括媒体采集的硬件和软件，还有流传输技术。会议型的应用有时候不需要很高的音/视频质量。 （4）视频广播，是点播的扩展，把节目源组织成频道，以广播的方式提供，用户通过加入频道收看预定好的节目 (5)视频监视 (6)音乐播放/在线电台 (7)电视上网流媒体技术原理如果将文件传输看作是一次接水的过程，过去的传输方式就像是对用户做了一个规定，必须等到一桶水接满才能使用它，这个等待的时间自然要受到水流量大小和桶的大小的影响。而流式传输则是，打开水头龙，等待一小会儿，水就会源源不断地流出来，而且可以随接随用，因此，不管水流量的大小，也不管桶的大小，用户都可以随时用上水。从这个意义上看，流媒体这个词是非常形象的。流式传输技术又分两种，一种是顺序流式传输，另一种是实时流式传输。顺序流式传输顺序流式传输是顺序下载，在下载文件的同时用户可以观看，但是，用户的观看与服务器上的传输并不是同步进行的，用户是在一段延时后才能看到服务器上传出来的信息，或者说用户看到的总是服务器在若干时间以前传出来的信息。在这过程中，用户只能观看已下载的那部分，而不能要求跳到还未下载的部分。顺序流式传输比较适合高质量的短片段，因为它可以较好地保证节目播放的最终质量。它适合于在网站上发布的供用户点播的音视频节目。对通过调制解调器发布的短片段，顺序流式传输很实用，它允许用比调制解调器跟高的数据速率创建视频片段，尽管有延迟毕竟可让你发布高质量的视频片段。顺序流式文件是放在标准HTTP或FTP服务器上，易管理基本上与防火墙无关，顺序流式传播不适合长片段和有随机访问要求的视频，如演讲，演说与演示，它不支持现场广播，严格来说，它是一种点播技术。 实时流式传输在实时流式传输中，音视频信息可被实时观看到。在观看过程中用户可快进或后退以观看前面或后面的内容，但是在这种传输方式中，如果网络传输状况不理想，则收到的信号效果比较差。实时流式传输必须匹配连接宽带，意味着以调制解调器速度连接时图像质量较差，而且由于出错丢失的信息被忽略掉，网络拥挤或者出现问题时候，视频质量很差，如欲保证视频质量，顺序流式传输也许更好，实时流式传输需要特定的服务器，如QuickTime Streaming Server/Real Server/Windows Media Server这些服务器允许你对媒体发送进行更多级别的控制，因为而系统设置管理比HTTP服务器更复杂，实时流传输还需要特殊的网络协议，比如RTSP(Real time sreming protocol)或MMS(Microsoft Media Server)这些协议在有防火墙的时候会出现问题，导致用户不能看到一些地点的实时内容。 流媒体系统的组成通常，组成一个完整的流媒体系统包括以下5个部分： ①一种用于创建、捕捉和编辑多媒体数据，形成流媒体格式的编码工具; ②流媒体数据; ③一个存放和控制流媒体数据的服务器; ④要有适合多媒体传输协议甚至是实时传输协议的网络; ⑤供客户端浏览流媒体文件的播放器。 流媒体传输的基本原理流媒体传输的基本原理 流媒体服务器架设 流媒体技术也称为流式传输技术，是指在网络上按时间先后次序传输和播放的连续音、视频数据流。随着网络速度的提高，以流媒体技术为核心的视频点播、在线电视、远程培训等业务开展得越来越广泛。本章主要介绍流媒体技术的基础知识、流媒体服务器的安装、运行、配置和使用等内容。 23.1 流媒体技术基础 流媒体是指利用流式传输技术传送的音频、视频等连续媒体数据，它的核心是串流（Streaming）技术和数据压缩技术，具有连续性、实时性、时序性3个特点，可以使用顺序流式传输和实时流式传输两种传输方式。本节主要介绍有关流媒体的技术基础。 23.1.1 流媒体传输的基本原理 实现流式传输需要使用缓存机制。因为音频或视频数据在网络中是以包的形式传输的，而网络是动态变化的，各个数据包选择的路由可能不尽相同，到达客户端所需的时间也就不一样，有可能会出现先发的数据包却后到。因此，客户端如果按照包到达的次序播放数据，必然会得到不正确的结果。使用缓存机制就可以解决这个问题，客户端收到数据包后先缓存起来，播放器再从缓存中按次序读取数据。 使用缓存机制还可以解决停顿问题。网络由于某种原因经常会有一些突发流量，此时会造成暂时的拥塞，使流数据不能实时到达客户端，客户端的播放就会出现停顿。如果采用了缓存机制，暂时的网络阻塞并不会影响播放效果，因为播放器可以读取以前缓存的数据。等网络正常后，新的流数据将会继续添加到缓存中。 虽然音频或视频等流数据容量非常大，但播放流数据时所需的缓存容量并不需要很大，因为缓存可以使用环形链表结构来存储数据，已经播放的内容可以马上丢弃，缓存可以腾出空间用于存放后续尚未播放的内容。 当传输流数据时，需要使用合适的传输协议。TCP虽然是一种可靠的传输协议，但由于需要的开销较多，并不适合传输实时性要求很高的流数据。因此，在实际的流式传输方案中，TCP协议一般用来传输控制信息，而实时的音视频数据则是用效率更高的RTP/UDP等协议来传输。流媒体传输的基本原理如图23-1所示。 在图23-1中，Web服务器只是为用户提供了使用流媒体的操作界面。客户机上的用户在浏览器中选中播放某一流媒体资源后，Web服务器把有关这一资源的流媒体服务器地址、资源路径及编码类型等信息提供给客户端，于是客户端就启动了流媒体播放器，与流媒体服务器进行连接。 客户端的流媒体播放器与流媒体服务器之间交换控制信息时使用的是RTSP协议，它是基于TCP协议的一种应用层协议，默认使用的是554端口。RTSP协议提供了有关流媒体播放、快进、快倒、暂停及录制等操作的命令和方法。通过RTSP协议，客户端向服务器提出了播放某一流媒体资源的请求，服务器响应了这个请求后，就可以把流媒体数据传输给客户端了。 需要注意的是，RTSP协议并不具备传输流媒体数据的功能，承担流媒体数据传输任务的是另一种基于UDP的RTP协议，但在RTP协议传输流媒体数据的过程中，RTSP连接是一直存在的，并且控制着流媒体数据的传输。一旦流媒体数据到达了客户端，流媒体播放器就可以播放输出了。流媒体的数据和控制信息使用不同的协议和连接时，还可以带来一个好处，就是播放流媒体的客户机和控制流媒体播放的客户机可以是不同的计算机。 实时流媒体协议RTSPRTSP（Real Time Streaming Protocol，实时流媒体协议）是由Real Network和Netscape共同提出的一种应用层协议，它定义了如何在IP网络上有效地传输流媒体数据。RTSP提供了一种机制，使音频、视频等数据可以按照需要进行实时传输，并且可以实施诸如暂停、快进等控制。源数据可以是存储的文件，也可以是现场数据的反馈。RTSP协议本身并不传输数据，数据的传输是通过基于UDP协议的RTP协议来完成的。 RTSP协议与HTTP协议有点类似，通信双方是通过请求消息和回应消息进行交互的。请求消息的格式如下：1234&lt;请求方法&gt; &lt;URI&gt; &lt;RTSP版本&gt; [消息头] CR/ LF [消息体] 其中，请求方法包括PLAY、DESCRIBE等，可以通过OPTION方法得到对方所支持的其他方法名称。URI是对方的地址，例如：rtsp://192.168.0.1。”RTSP版本”一般都是RTSP/1.0。每一行的最后都是回车换行符CR/LF，消息头和消息体之间要有一个空行。回应消息格式如下：1234&lt;RTSP版本&gt; &lt;状态码&gt; &lt;解释&gt; [消息头] CR/LF [消息体] 回应消息的格式规定与请求消息类似。其中状态码是一个3位数，后面跟随着解释文本，例如，200表示成功。 HTTP协议是单向的，即只能是客户端提出请求，服务端给予回应，而使用RTSP时，客户机和服务器都可以发出请求，双方都可以对收到的请求进行应答，即RTSP可以是双向的。一个典型的RSTP交互过程如下所示，其中C表示RTSP客户端，S表示RTSP服务端12345678910111213141516171819202122232425C-&gt;S: OPTION request //客户端通过OPTION方法询问服务端支持哪些方法 S-&gt;C: OPTION response //服务端进行回应，提供了所支持方法的名称 C-&gt;S: DESCRIBE request //客户端通过DESCRIBE方法查询服务端媒体的初始化描述//信息 S-&gt;C: DESCRIBE response //服务端回应媒体初始化描述信息，采用的是sdp会话描述//格式 C-&gt;S: SETUP request //客户端通过SETUP方法设置会话的属性、传输模式等参数，//并请求建立会话 S-&gt;C: SETUP response //服务端响应回话请求，与客户端建立会话，并返回会话标识//符及其他相关信息 C-&gt;S: PLAY request //客户端通过PLAY方法请求播放某一多媒体资源 S-&gt;C: PLAY response //服务器回应请求，开始发送流数据 S-&gt;C: … //此时，RTSP通过其他协议发送流媒体数据 C-&gt;S: TEARDOWN request //客户端通过TEARDOWN方法请求关闭会话 S-&gt;C: TEARDOWN response //服务器回应请求，会话关闭，交互结束 实际应用中，RTCP的交互过程可能和以上过程会有区别，但基本的流程是一样的。 说明：还有一种常见的流媒体协议是由Microsoft公司开发的MMS协议，但Microsoft公司没有公开该协议。 流媒体播放方式流媒体服务器可以提供多种播放方式，它可以根据用户的要求，为每个用户独立地传送流数据，实现VOD（Video On Demand）的功能；也可以为多个用户同时传送流数据，实现在线电视或现场直播的功能。下面介绍一下这些播放方式的特点。 单播方式当采用单播方式时，每个客户端都与流媒体服务器建立了一个单独的数据通道，从服务器发送的每个数据包都只能传给一台客户机。对用户来说，单播方式可以满足自己的个性化要求，可以根据需要随时使用停止、暂停、快进等控制功能。但对服务器还说，单播方式无疑会带来沉重的负担，因为它必须为每个用户提供单独的查询，向每个用户发送所申请的数据包复制。当用户数很多时，对网络速度、服务器性能的要求都很高。如果这些性能不能满足要求，就会造成播放停顿，甚至停止播放。 广播方式承载流数据的网络报文还可以使用广播方式发送给子网上所有的用户，此时，所有的用户同时接受一样的流数据，因此，服务器只需要发送一份数据复制就可以为子网上所有的用户服务，大大减轻了服务器的负担。但此时，客户机只能被动地接受流数据，而不能控制流。也就是说，用户不能暂停、快进或后退所播放的内容，而且，用户也不能对节目进行选择。 组播方式单播方式虽然用户提供了最大的灵活性，但网络和服务器的负担很重。广播方式虽然可以减轻服务器的负担，但用户不能选择播放内容，只能被动地接受流数据。组播吸取了上述两种传输方式的长处，可以将数据包复制发送给需要的多个客户，而不是像单播方式那样复制数据包的多个文件到网络上，也不是像广播方式那样将数据包发送给那些不需要的客户，保证数据包占用最小的网络带宽。当然，组播方式需要在具有组播能力的网络上使用。 流媒体关键技术流媒体有三个关键技术:数据压缩/解压缩技术，流媒体网络传输和媒体文件在流式传输中的版权保护问题，其中数据压缩和解压缩技术优势重中之重，核心技术。方发送确认嘻嘻，发送发收到确认嘻嘻猴才继续 流媒体制作技术方面解决的问题在网络中进行流媒体传输，所传输的文件必须制作成适合流媒体传输的流媒体格式文件，由于通常格式存储的多媒体文件容量十分大，传输比较困难，另外流媒体也不能按流媒体传输的协议进行传输，所以必须对问津进行预处理，将文件压缩成流媒体格式文件，这里要注意两点：1，选用合适的算法在质量与体积之间找到平衡，2，需要向文件中添加流式信息。 流媒体传输方面需要解决的问题流媒体传输需要和实施的传输协议，目前文件初三书大部分是建立在TCP协议上的，也有一些以ftp传输协议方式进行传输，但采用这些传输方法都不能实现实时的方式传输，随着流媒体技术的深入研究，目前成熟的流媒体传输一般都采用建立在UDP协议上的RTP/RTSP实时传输协议。之所选择UDP是因为在传输的可靠性上UDP比TCP有很大的有事，TCP协议中包含了专门的数据传送校验机制，当数据接受方收到数据后将自动向发送确认信息，发送方在接收到确认信息后才继续传送数据，否则将一直处于等待状态，而UDP协议则不同，本身并不做任何校验，由此可以看出TCP协议注重传输质量，而UDP注重传输速度，因此对于传输质量要求不是很高，而对速度要求很高的视音频流媒体文件来说，采用UDP更加合适。 流媒体的传说过程中需要缓存的支持因为internet是以包为单位进行异步传输的，所以多媒体数据在传输过程中被分解为许多的包，由于网络传输的不稳定性，各个包选择的路由不同，所以到达客户端的时间次序可能发生改变，甚至产生丢包现象，为此，必须采用正确的书序，从而必须使用缓存技术来纠正由于数据到达次序发生改变而产生的混乱的问题，利用缓存对到达的数据包进行正确的排序，从而使音频数据能够连续正确的播放，缓存中存储的是一段时间内的数据，数据在缓存中存放的时间是暂时的，缓存中的数据也是动态的，不断更新的，流媒体在播放时不断的读取缓存中的数据进行播放，播放完后该数据立刻被清楚，新的数据将加入缓存，因此播放流媒体文件的时候并不需要占用太大的缓存空间。 流媒体传输的网络协议TCP需要较多的开销，所以不太适合传输实时数据，流式传输一般采用HTTP/TCP(RTCP)传输控制信息，而采用RTP/UDP(RTP)来传输实时声音数据。 实时传输协议RTP这种协议在一对一或一对多的传输情况下工作，其目的是提供时间信息和实现流同步，RTP通常使用UDP来传送数据，当引用程序开始一个RTP会话时将使用两个端口，一个给RTP，一个给RTCP，RTP本身并不能为按顺序传送数据包提供可靠的传送机制，也不提供流量控制或拥塞控制，它依靠RTCP提供这些服务，通常RTP算法并不作为一个独立的网络层来实现，而是作为应用程序代码的一部分。 实时传输控制协议RTCP实时传输控制协议RTCP和RTP一起提供流量控制和拥塞控制服务，在RTP会话期间各参与者周期性的传送RTCP包，RTCP包中含有 已发送的数据包的数量，丢失的数据包数量等统计资料，因此服务器可以利用这些信息动态的改变传输速率，甚至改变有效载荷类型。RTP和RTCP配合使用，能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。 实时流协议RTSP实时流协议RTSP定义了一对多应用程序如何有效地通过IP网络传送多媒体数据，RTSP的体系结构上位于RTP和RTCP之上，它使用TCP或RTP完成数据传输，HTTP与RTSP相比，HTTP传送HTML超链接文档，而RTSP传送的是多媒体数据，HTTP请求由客户机发出，服务器作出相应，使用RTSP时，客户机与服务器都可以发出请求，即RTSP可以是双向的，点对点的额手机可视通话，必须在手机终端实现RTSP。 流媒体文件格式将多媒体信息进行压缩生成一定格式的文件，这就是媒体压缩格式，而要将这些压缩的文件在IP网上进行实时传输，就需要将这些压缩文件进行必要的处理，分割成很多小块，以方便传输，比如rm，rmvb，asf，这就是媒体流格式，要在网上传播还需要将一定的格式告诉用户这就是媒体的发布格式。 流式文件格式为了减小用户的播放演示和存储空间，实现边下边播，并保证一定的播放质量，就需要对压缩文件进行特殊的处理，添加一些附属信息，如计时，压缩和版权信息，这就是流式文件格式，常见的有如下集中： flvFlash MX 以前flash中的视频文件导入是一帧一帧变成位图，结果导致文件巨大，限制了它的引用范围，随着Flash MX的退出，macromedia公司开发了属于自己流式视频格式的FLV，这种个试试在sorenson公司的压缩算法的基础上开发出来的，sorenson公司也为MOV格式提供苏犯法。FLV格式不仅可以轻松导入flash中，几百帧的影片两分钟完成导入，同时可以通过rtmp协议从flashcom服务器上流式播出。 流媒体文件的压缩格式数据压缩技术也是流媒体技术的一项重要内容，由于视频数据的容量往往都非常大，如果不经过压缩或压缩得不够，则不仅会增加服务器的负担，更重要的是会占用大量的网络带宽，影响播放效果。因此如何在保证不影响观看效果或对观看效果影响很小的前提下，最大限度地对流数据进行压缩，是流媒体技术研究的一项重要内容。下面介绍一下几种主流的音视频数据压缩格式。 1．AVI格式AVI（Audio Video Interleave，音频视频交错）是符合RIFF文件规范的数字音频与视频文件格式，由Microsoft公司开发，目前得到了广泛的支持。AVI格式支持256色和RLE压缩，并允许视频和音频交错在一起同步播放。但AVI文件并未限定压缩算法，只是提供了作为控制界面的标准，用不同压缩算法生成的AVI文件，必须要使用相同的解压缩算法才能解压播放。AVI文件主要应用在多媒体光盘上，用来保存电影、电视等各种影像信息。 2．MPEG格式MPEG（Moving Picture Experts Group，动态图像专家组）是运动图像压缩算法的国际标准，已被几乎所有的计算机平台共同支持，它采用有损压缩算法减少运动图像中的冗余信息，同时保证每秒30帧的图像刷新率。MPEG标准包括视频压缩、音频压缩和音视频同步3个部分，MPEG音频最典型的应用就是MP3音频文件，广泛使用的消费类视频产品如VCD、DVD其压缩算法采用的也是MPEG标准。 MPEG压缩算法是针对运动图像而设计的，其基本思路是把视频图像按时间分段，然后采集并保存每一段的第一帧数据，其余各帧只存储相对第一帧发生变化的部分，从而达到了数据压缩的目的。MPEG采用了两个基本的压缩技术：运动补偿技术（预测编码和插补码）实现了时间上的压缩，变换域（离散余弦变换DCT）技术实现了空间上的压缩。MPEG在保证图像和声音质量的前提下，压缩效率非常高，平均压缩比为50∶1，最高可达200∶1。 3．RealVideo格式RealVideo格式是由Real Networks公司开发的一种流式视频文件格式，包含在Real Media音频视频压缩规范中，其设计目标是在低速率的广域网上实时传输视频影像。RealVideo可以根据网络的传输速度来决定视频数据的压缩比率，从而提高适应能力，充分利用带宽。本章后面介绍的Real Server软件就是由Real Networks公司提供的，使用的就是Real Video格式的视频文件。 RealVideo格式文件的扩展名有3种，RA是音频文件、RM和RMVB是视频文件。RMVB格式文件具有可变比特率的特性，它在处理较复杂的动态影像时使用较高的采样率，而在处理一般静止画面时则灵活地转换至较低的采样率，从而在不增加文件大小的前提下提高了图像质量。 4．QuickTime格式QuickTime是由Apple公司开发的一种音视频数据压缩格式，得到了Mac OS、Microsoft Windows等主流操作系统平台的支持。QuickTime文件格式提供了150多种视频效果，支持25位彩色，支持RLE、JPEG等领先的集成压缩技术。此外，QuickTime还强化了对Internet应用的支持，并采用一种虚拟现实技术，使用户可以通过鼠标或键盘的交互式控制，观察某一地点周围360度的景像，或者从空间的任何角度观察某一物体。QuickTime以其领先的多媒体技术和跨平台特性、较小的存储空间要求、技术细节的独立性以及系统的高度开放性，得到业界的广泛认可。QuickTime格式文件的扩展是MOV或QT。 5．ASF和WMV格式ASF（Advanced Streaming Format，高级流格式）和WMV是由Microsoft公司推出的一种在Internet上实时传播多媒体数据的技术标准，提供了本地或网络回放、可扩充的媒体类型、部件下载以及可扩展性等功能。ASF的应用平台是Net Show服务器和Net Show播放器。 WMV也是Microsoft公司推出的一种流媒体格式，它是以ASF为基础，升级扩展后得到的。在同等视频质量下，WMV格式的体积非常小，因此很适合在网上播放和传输。WMV文件一般同时包含视频和音频部分，视频部分使用Windows Media Video编码，而音频部分使用Windows Media Audio编码。音频文件可以独立存在，其扩展名是WMA。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>流媒体</tag>
      </tags>
  </entry>
</search>
